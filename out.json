{
  "../include/algorithm/coenumerate.hpp": {
    "body": [
      "template <typename InputIterator, typename OutputIterator>",
      "constexpr OutputIterator",
      "  coenumerate(InputIterator  first,",
      "              InputIterator  last,",
      "              OutputIterator result)",
      "{",
      "  int cnt = 0;",
      "  while (first != last)",
      "  {",
      "    *result = std::make_pair(*first, cnt);",
      "    result++, first++, cnt++;",
      "  }",
      "  return result;",
      "}"
    ],
    "prefix": "coenumerate"
  },
  "../include/algorithm/enumerate.hpp": {
    "body": [
      "template <typename InputIterator, typename OutputIterator>",
      "constexpr OutputIterator",
      "  enumerate(InputIterator  first,",
      "            InputIterator  last,",
      "            OutputIterator result)",
      "{",
      "  int cnt = 0;",
      "  while (first != last)",
      "  {",
      "    *result = std::make_pair(cnt, *first);",
      "    result++, first++, cnt++;",
      "  }",
      "  return result;",
      "}"
    ],
    "prefix": "enumerate"
  },
  "../include/algorithm/zip2.hpp": {
    "body": [
      "template <typename InputIterator1,",
      "          typename InputIterator2, typename OutputIterator>",
      "constexpr OutputIterator",
      "  zip2(InputIterator1 first1,",
      "      InputIterator1 last1,",
      "      InputIterator2 first2,",
      "      OutputIterator result)",
      "{",
      "  while (first1 != last1)",
      "  {",
      "    *result = std::make_pair(*first1, *first2);",
      "    result++, first1++, first2++;",
      "  }",
      "  return result;",
      "}"
    ],
    "prefix": "zip2"
  },
  "../include/algorithm/zip3.hpp": {
    "body": [
      "template <typename InputIterator1,",
      "          typename InputIterator2,",
      "          typename InputIterator3, typename OutputIterator>",
      "constexpr OutputIterator",
      "  zip3(InputIterator1 first1,",
      "      InputIterator1 last1,",
      "      InputIterator2 first2,",
      "      InputIterator3 first3,",
      "      OutputIterator result)",
      "{",
      "  while (first1 != last1)",
      "  {",
      "    *result = std::make_tuple(*first1, *first2, *first3);",
      "    result++, first1++, first2++, first3++;",
      "  }",
      "  return result;",
      "}"
    ],
    "prefix": "zip3"
  },
  "../include/algorithm/zip4.hpp": {
    "body": [
      "template <typename InputIterator1,",
      "          typename InputIterator2,",
      "          typename InputIterator3,",
      "          typename InputIterator4,",
      "          typename OutputIterator>",
      "constexpr OutputIterator",
      "  zip4(InputIterator1 first1,",
      "      InputIterator1 last1,",
      "      InputIterator2 first2,",
      "      InputIterator3 first3,",
      "      InputIterator4 first4,",
      "      OutputIterator result)",
      "{",
      "  while (first1 != last1)",
      "  {",
      "    *result = std::make_tuple(*first1, *first2, *first3, *first4);",
      "    result++, first1++, first2++, first3++, first4++;",
      "  }",
      "  return result;",
      "}",
      ""
    ],
    "prefix": "zip4"
  },
  "../include/combinator/combinator.hpp": {
    "body": [
      "template<typename T>",
      "class fixed_point : T {",
      "  public:",
      "    explicit constexpr fixed_point (T&& t) noexcept",
      "      : T(std::forward<T>(t)) {}",
      "    template<typename... Args>",
      "    constexpr decltype(auto) operator()(Args&&... args) const",
      "      {return T::operator()(*this, std::forward<Args>(args)...);}",
      "};",
      "template<typename T>",
      "static inline constexpr decltype(auto) fix (T&& t) noexcept {",
      "  return fixed_point<T>{std::forward<T>(t)};",
      "}"
    ],
    "prefix": "combinator"
  },
  "../include/disjoint_sets/quick_find.hpp": {
    "body": [
      "class quick_find",
      "{",
      "  int                           n;",
      "  std::vector<int>              prt;",
      "  std::vector<std::vector<int>> child;",
      "",
      "public:",
      "  quick_find (int n) : n(n), prt(n), child(n)",
      "  {",
      "    std::iota(prt.begin(), prt.end(), 0);",
      "    for (int i = 0; i < n; i++) {",
      "      child.at(i) = {i};",
      "    }",
      "  }",
      "",
      "  auto collect ()             const {return prt;}",
      "  bool is_root (int x)        const {return find(x) == x;}",
      "  int  size    (int x)        const {return child.at(prt.at(x)).size();}",
      "  bool same    (int x, int y) const {return find(x) == find(y);}",
      "  int  find    (int x)        const {return prt.at(x);}",
      "",
      "  // Returns `true` if x and y are newly connected.",
      "  bool unite   (int x, int y)",
      "  {",
      "    if ((x = find(x)) == (y = find(y))) return false;",
      "    if (size(x) > size(y)) std::swap(x, y);",
      "    for (auto z : child.at(x))",
      "    {",
      "      prt.at(z) = y;",
      "      child.at(y).push_back(z);",
      "    }",
      "    decltype(child)::value_type{}.swap(child.at(x));",
      "    return true;",
      "  }",
      "};"
    ],
    "prefix": "quick_find"
  },
  "../include/disjoint_sets/union_find.hpp": {
    "body": [
      "class union_find",
      "{",
      "  int n;",
      "  std::vector<int> prt;",
      "",
      "public:",
      "  union_find (int n) : n(n), prt(n, -1){}",
      "",
      "  bool is_root (int x)        const {return prt.at(x) < 0;}",
      "",
      "  int  size    (int x)        const {return -prt.at(find(x));}",
      "",
      "  bool same(int x, int y) const {return find(x) == find(y);}",
      "",
      "  int  find    (int x)        const {",
      "    while (!is_root(x)) x = prt.at(x);",
      "    return x;",
      "  }",
      "",
      "  // Returns `true` if x and y are newly connected.",
      "  // The smaller one x becomes a child of the larger one y.",
      "  bool unite   (int x, int y) {",
      "    if ((x = find(x)) == (y = find(y))) return false;",
      "    if (size(x) > size(y)) std::swap(x, y);",
      "    prt.at(y) += prt.at(x);",
      "    prt.at(x) = y;",
      "    return true;",
      "  }",
      "};"
    ],
    "prefix": "union_find"
  },
  "../include/disjoint_sets/valued_quick_find.hpp": {
    "body": [
      "template <typename Value, typename BinaryOp>",
      "class valued_quick_find",
      "{",
      "  int                           n;",
      "  std::vector<int>              prt;",
      "  std::vector<std::vector<int>> child;",
      "  std::vector<Value>            table;",
      "  BinaryOp                      op;",
      "  Value                         id;",
      "",
      "  auto& op_eq (Value& x, Value y) const {return x = op(x, y);}",
      "",
      "public:",
      "  valued_quick_find (int n, BinaryOp op, Value id, Value init) :",
      "    n(n), prt(n), child(n), table(n, init), op(op), id(id)",
      "  {",
      "    std::iota(prt.begin(), prt.end(), 0);",
      "    for (int i = 0; i < n; i++) {",
      "      child.at(i) = {i};",
      "    }",
      "  }",
      "",
      "  auto collect ()             const {return prt;}",
      "  bool is_root (int x)        const {return find(x) == x;}",
      "  int  size    (int x)        const {return child.at(prt.at(x)).size();}",
      "  bool same    (int x, int y) const {return find(x) == find(y);}",
      "  int  find    (int x)        const {return prt.at(x);}",
      "  auto get     (int x)        const {return table.at(find(x));}",
      "  void set     (int x, Value val)   {table.at(find(x)) = val;}",
      "  void add     (int x, Value val)   {set(x, get(x) + val);}",
      "  auto collect_vals()         const",
      "  {",
      "    auto ret = std::vector<Value>(n);",
      "    for (auto i = 0; i < n; i++)",
      "    {",
      "      ret.at(i) = get(i);",
      "    }",
      "    return ret;",
      "  }",
      "",
      "  // Returns `true` if x and y are newly connected.",
      "  bool unite   (int x, int y)",
      "  {",
      "    if ((x = find(x)) == (y = find(y))) return false;",
      "    if (size(x) < size(y)) std::swap(x, y);",
      "    for (auto z : child.at(y))",
      "    {",
      "      prt.at(z) = x;",
      "      child.at(x).push_back(z);",
      "    }",
      "    op_eq(table.at(x), table.at(y));",
      "    table.at(y) = id;",
      "    typename decltype(child)::value_type{}.swap(child.at(y));",
      "    return true;",
      "  }",
      "};",
      "",
      "template <typename Value, typename BinaryOp, typename BinaryOp2>",
      "auto make_valued_quick_find(int n, BinaryOp op, Value id) {",
      "  return valued_quick_find<Value, BinaryOp>(n, op, id);",
      "}"
    ],
    "prefix": "valued_quick_find"
  },
  "../include/disjoint_sets/valued_union_find.hpp": {
    "body": [
      "",
      "template <typename Value, typename BinaryOp>",
      "class valued_union_find",
      "{",
      "  int                n;",
      "  std::vector<Value> table;",
      "  std::vector<int>   prt;",
      "  BinaryOp           op;",
      "  Value              id;",
      "",
      "public:",
      "  valued_union_find (int n, BinaryOp op, Value id, Value init) :",
      "    n(n), table(n, init), prt(n, -1), op(op), id(id)",
      "    {}",
      "",
      "  bool is_root (int x)        const {return prt.at(x) < 0;}",
      "  int  size    (int x)        const {return -prt.at(find(x));}",
      "  bool same    (int x, int y) const {return find(x) == find(y);}",
      "  int  find    (int x)        const",
      "  {",
      "    while (!is_root(x)) x = prt.at(x);",
      "    return x;",
      "  }",
      "  auto collect ()             const {return prt;}",
      "",
      "  // Returns `true` if x and y are newly connected.",
      "  // y becomes the partent.",
      "  bool unite   (int x, int y)",
      "  {",
      "    if ((x = find(x)) == (y = find(y))) return false;",
      "    if (size(x) > size(y)) std::swap(x, y);",
      "    prt.at(y) += prt.at(x);",
      "    prt.at(x) = y;",
      "    table.at(y) = op(table.at(y), table.at(x));",
      "    table.at(x) = id;",
      "    return true;",
      "  }",
      "",
      "  auto get     (int x)        const {return table.at(find(x));}",
      "  auto collect_vals ()        const",
      "  {",
      "    std::vector<Value> ret(n);",
      "    for (auto i = 0; i < n; i++)",
      "    {",
      "      ret.at(i) = get(i);",
      "    }",
      "    return ret;",
      "  }",
      "  void set     (int x, Value val)    {table.at(find(x)) = val;}",
      "  void add     (int x, Value val)    {set(x, get(x) + val);}",
      "};",
      "",
      "template <typename Value, typename BinaryOp>",
      "auto make_valued_union_find(int n, BinaryOp op, Value id, Value init)",
      "{",
      "  return valued_union_find<Value, BinaryOp>(n, op, id, init);",
      "}"
    ],
    "prefix": "valued_union_find"
  },
  "../include/disjoint_sets/weighted_quick_find.hpp": {
    "body": [
      "template <typename Value, typename BinaryOp1, typename BinaryOp2>",
      "class weighted_quick_find",
      "{",
      "  int                           n;",
      "  std::vector<int>              prt;",
      "  std::vector<std::vector<int>> child;",
      "  std::vector<Value>            table;",
      "  BinaryOp1                     op1;",
      "  BinaryOp2                     op2;",
      "  Value                         id;",
      "",
      "  auto& op1_eq (Value& x, Value y) const {return x = op1(x, y);}",
      "  auto& op2_eq (Value& x, Value y) const {return x = op2(x, y);}",
      "  auto& inv_eq (Value& x)          const {return x = op2(id, x);}",
      "",
      "public:",
      "  weighted_quick_find (int n, BinaryOp1 op1, BinaryOp2 op2, Value id) :",
      "    n(n), prt(n), child(n), table(n, id), op1(op1), op2(op2), id(id)",
      "  {",
      "    std::iota(prt.begin(), prt.end(), 0);",
      "    for (int i = 0; i < n; i++) {",
      "      child.at(i) = {i};",
      "    }",
      "  }",
      "",
      "  auto collect ()             const {return prt;}",
      "  bool is_root (int x)        const {return find(x) == x;}",
      "  int  size    (int x)        const {return child.at(prt.at(x)).size();}",
      "  bool same    (int x, int y) const {return find(x) == find(y);}",
      "  int  find    (int x)        const {return prt.at(x);}",
      "",
      "  // x - y",
      "  auto diff    (int x, int y) const",
      "  {",
      "    assert(same(x, y));",
      "    return op2(table.at(x), table.at(y));",
      "  }",
      "",
      "  // Returns `true` if x and y are newly connected.",
      "  // x - y = d",
      "  bool unite   (int x, int y, Value d)",
      "  {",
      "    inv_eq(d);",
      "    op1_eq(d, table.at(x));",
      "    op2_eq(d, table.at(y));",
      "    if ((x = find(x)) == (y = find(y))) return false;",
      "    if (size(x) < size(y))",
      "    {",
      "      std::swap(x, y);",
      "      inv_eq(d);",
      "    }",
      "    for (auto z : child.at(y))",
      "    {",
      "      prt.at(z) = x;",
      "      op1_eq(table.at(z), d);",
      "      child.at(x).push_back(z);",
      "    }",
      "    typename decltype(child)::value_type{}.swap(child.at(y));",
      "    return true;",
      "  }",
      "};",
      "",
      "template <typename Value, typename BinaryOp1, typename BinaryOp2>",
      "auto make_weighted_quick_find(int n, BinaryOp1 op1, BinaryOp2 op2, Value id) {",
      "  return weighted_quick_find<Value, BinaryOp1, BinaryOp2>(n, op1, op2, id);",
      "}"
    ],
    "prefix": "weighted_quick_find"
  },
  "../include/disjoint_sets/weighted_union_find.hpp": {
    "body": [
      "template <typename Value, typename BinaryOp1, typename BinaryOp2>",
      "class weighted_union_find",
      "{",
      "  int                n;",
      "  std::vector<int>   prt;",
      "  std::vector<Value> wt;",
      "  BinaryOp1          op1;",
      "  BinaryOp2          op2;",
      "  Value              id;",
      "",
      "  auto op1_eq (Value& x, Value y) const {return x = op1(x, y);}",
      "  auto op2_eq (Value& x, Value y) const {return x = op2(x, y);}",
      "  auto inv_eq (Value& x)          const {return x = op2(id, x);}",
      "  auto inv    (Value& x)          const {return inv_eq(x);}",
      "",
      "public:",
      "  weighted_union_find",
      "    (int n, BinaryOp1 op1, BinaryOp2 op2, Value id) :",
      "    n(n), prt(n, -1), wt(n, id), op1(op1), op2(op2), id(id)",
      "    {}",
      "",
      "  bool is_root   (int x)        const {return prt.at(x) < 0;}",
      "  int  size      (int x)              {return -prt.at(find(x));}",
      "  bool same      (int x, int y)       {return find(x) == find(y);}",
      "  auto collect   ()             const {return prt;}",
      "",
      "  auto get       (int x)",
      "  {",
      "    find(x);",
      "    return wt.at(x);",
      "  }",
      "  auto quiet_get (int x) const",
      "  {",
      "    auto ret = id;",
      "    while(!is_root(x))",
      "    {",
      "      op1_eq(ret, wt.at(x));",
      "      x = prt.at(x);",
      "    }",
      "    return ret;",
      "  }",
      "",
      "  // x - y",
      "  auto diff      (int x, int y)",
      "  {",
      "    assert(same(x, y));",
      "    return op2(get(x), get(y));",
      "  }",
      "  auto collect_wts ()",
      "  {",
      "    auto ret = std::vector<Value>(n);",
      "    for (auto i = 0; i < n; i++)",
      "    {",
      "      ret.at(i) = get(i);",
      "    }",
      "    return ret;",
      "  }",
      "  auto quiet_collect_wts() const",
      "  {",
      "    auto ret = std::vector<Value>(n);",
      "    for (auto i = 0; i < n; i++)",
      "    {",
      "      ret.at(i) = quiet_get(i);",
      "    }",
      "    return ret;",
      "  }",
      "",
      "  // Path compression.",
      "  int  find    (int x)",
      "  {",
      "    if (is_root(x)) return x;",
      "    else",
      "    {",
      "      auto root = find(prt.at(x));",
      "      op1_eq(wt.at(x), wt.at(prt.at(x)));",
      "      return prt.at(x) = root;",
      "    }",
      "  }",
      "",
      "  // Returns `true` if x and y are newly connected.",
      "  // x is the parent.",
      "  // x - y = d",
      "  bool unite   (int x, int y, Value d)",
      "  {",
      "    inv_eq(d);",
      "    op1_eq(d, get(x));",
      "    op2_eq(d, get(y));",
      "    if ((x = find(x)) == (y = find(y)))",
      "    {",
      "      assert(op2(get(x), get(y)) == d);",
      "      return false;",
      "    }",
      "    if (size(x) < size(y))",
      "    {",
      "      std::swap(x, y);",
      "      inv_eq(d);",
      "    }",
      "    prt.at(x) += prt.at(y);",
      "    prt.at(y) = x;",
      "    wt.at(y) = d;",
      "    return true;",
      "  }",
      "};",
      "",
      "template <typename Value, typename BinaryOp1, typename BinaryOp2>",
      "auto make_weighted_union_find(int n, BinaryOp1 op1, BinaryOp2 op2, Value id)",
      "{",
      "  return weighted_union_find<Value, BinaryOp1, BinaryOp2>(n, op1, op2, id);",
      "}"
    ],
    "prefix": "weighted_union_find"
  },
  "../include/free_group/free_group.hpp": {
    "body": [
      "class free_group {",
      "  public:",
      "  static inline auto mul(std::string s, std::string t) {",
      "    while (",
      "        !s.empty() && !t.empty() &&",
      "        abs(s.back() - t.front()) == 32",
      "      )",
      "      {",
      "        s.erase(s.end() - 1); t.erase(t.begin());",
      "      }",
      "      return s + t;",
      "  }",
      "  static inline auto inv (std::string s) {",
      "    auto opp = [&] (char& c) {",
      "        if (0 <= c - 'a' && c - 'a' < 26) c -= 32;",
      "        else if (0 <= c - 'A' && c - 'A' < 26) c += 32;",
      "        else assert(false);",
      "      };",
      "    reverse(s.begin(), s.end());",
      "    for_each(s.begin(), s.end(), opp);",
      "    return s;",
      "  }",
      "};"
    ],
    "prefix": "free_group"
  },
  "../include/graph/bellman_ford.hpp": {
    "body": [
      "template <typename T>",
      "class bellman_ford {",
      "  using edge_t = tuple<T, int, int>;",
      "  const int n, r;",
      "  const std::vector<edge_t>& edg;",
      "  bool flg;",
      "  std::vector<long long> dst;",
      "  void cal () {",
      "      dst[r] = 0;",
      "      for (int q = n; q--;) {",
      "        flg = false;",
      "        for (auto const& e : edg) {",
      "          T d; int s, t; std::tie(d, s, t) = e;",
      "          if (dst[s] == inf) continue;",
      "          if (cmn(dst[t], dst[s] + d)) flg = true;",
      "        }",
      "      }",
      "  }",
      "  public:",
      "    const T inf;",
      "    bellman_ford (",
      "        const int n, const int r,",
      "        const std::vector<edge_t>& edg,",
      "        const T inf = numeric_limits<T>::max()",
      "      ) :",
      "      n(n), r(r), edg(edg), ",
      "      flg(false), dst(n, inf), inf(inf)",
      "      {",
      "        cal();",
      "      }",
      "    bellman_ford (",
      "        const int n, const int r,",
      "        const std::vector<edge_t>& edg",
      "      ) :",
      "      bellman_ford(n, r, edg, numeric_limits<T>::max())",
      "      {",
      "      }",
      "    bool has_negative_cycle () const {return flg;}",
      "    auto& result () {return dst;}",
      "};"
    ],
    "prefix": "bellman_ford"
  },
  "../include/graph/centroid.hpp": {
    "body": [
      "class centroid_tree {",
      "  const int n;",
      "  const std::vector<std::vector<int>> grh;",
      "  std::vector<bool> ckd;",
      "  std::vector<std::vector<int>> ctr;",
      "  queue<tuple<int, int, int>> que;",
      "  int rt = -1;",
      "  void build ()",
      "    {",
      "      std::vector<int> sz(n);",
      "      que.emplace(-1, 0, n);",
      "      while (!que.empty()) {",
      "        int prv_ctr, start, bkt; std::tie(prv_ctr, start, bkt) = que.front(); que.pop();",
      "        int new_ctr = -1;",
      "        make_fixed_point ([&](auto dfs, int crr, int prt) -> void {",
      "            sz[crr] = 1;",
      "            for (auto const& nxt : grh[crr]) if (nxt != prt && !ckd[nxt]) {",
      "              dfs(nxt, crr); if (new_ctr != -1) return;",
      "              sz[crr] += sz[nxt];",
      "            }",
      "            if (sz[crr] * 2 >= bkt) {",
      "              for (auto const& nxt : grh[crr]) if (!ckd[nxt]) {",
      "                if (nxt != prt) que.emplace(crr, nxt, sz[nxt]);",
      "                else que.emplace(crr, nxt, bkt - sz[crr]);",
      "              }",
      "              ckd[crr] = true;",
      "              new_ctr = crr;",
      "            }",
      "          })(start, start);",
      "        if (prv_ctr == -1) rt = new_ctr;",
      "        else ctr[prv_ctr].push_back(new_ctr);",
      "      }",
      "    }",
      "  public:",
      "    centroid_tree (",
      "        std::vector<std::vector<int>> grh",
      "      ) :",
      "      n(grh.size()),",
      "      grh(grh), ckd(n, false),",
      "      ctr(n)",
      "      {",
      "        build();",
      "      }",
      "    auto const centroid () const {return rt;}",
      "    auto const& result () const {return ctr;}",
      "    auto const& operator [] (int i) const {return ctr[i];}",
      "    auto const size () const {return n;}",
      "};"
    ],
    "prefix": "centroid"
  },
  "../include/graph/diameter.hpp": {
    "body": [
      "template<typename T>",
      "class diameter {",
      "    struct edge {",
      "      size_t to; T cost;",
      "      edge(size_t to, T cost) : to(to), cost(cost){}",
      "    };",
      "    size_t n;",
      "    std::vector<std::vector<edge>> graph;",
      "",
      "  public:",
      "    diameter(size_t n) : n(n), graph(n){}",
      "",
      "    // Insert an edge.",
      "    void insert(size_t i, size_t j, T cost = 1) {",
      "      assert(0 <= i && i < n);",
      "      assert(0 <= j && j < n);",
      "      graph.at(i).emplace_back(j, cost);",
      "      graph.at(j).emplace_back(i, cost);",
      "    };",
      "",
      "    // Calculate the diameter.",
      "    auto operator()(size_t root = 0){",
      "      std::vector<T> depth; ",
      "      auto cal = [&] (size_t r) {",
      "        depth.assign(n, 0);",
      "        fix ([&](auto dfs, size_t crr, size_t p) -> void {",
      "          for (auto const& e : graph.at(crr)) {",
      "            if (e.to == p) continue;",
      "            depth.at(e.to) = depth.at(crr) + e.cost;",
      "            dfs(e.to, crr);",
      "          }",
      "        })(r, r);",
      "      };",
      "      cal(root);",
      "      auto ex = std::max_element(depth.begin(), depth.end()) - depth.begin();",
      "      cal(ex);",
      "      return *std::max_element(depth.begin(), depth.end());",
      "    }",
      "};"
    ],
    "prefix": "diameter"
  },
  "../include/graph/dijkstra.hpp": {
    "body": [
      "template <typename T>",
      "class dijkstra {",
      "  const int n, r;",
      "  const std::vector<std::vector<std::pair<T, int>>>& grh;",
      "  std::vector<T> dst;",
      "  void cal () {",
      "    priority_queue<",
      "      std::pair<T, int>, std::vector<std::pair<T, int>>, greater<std::pair<T, int>>",
      "      > que;",
      "    que.emplace(0, r);",
      "    while (!que.empty()) {",
      "      T crd; int crr; std::tie(crd, crr) = que.top(), que.pop();",
      "      if (!cmn(dst[crr], crd)) continue;",
      "      for (auto e : grh[crr]) {",
      "        T w; int nxt; std::tie(w, nxt) = e;",
      "        T nxd = crd + w;",
      "        if (nxd < dst[nxt]) que.emplace(nxd, nxt);",
      "      }",
      "    }",
      "  }",
      "  public:",
      "    const T inf;",
      "    dijkstra (",
      "        const int r,",
      "        const std::vector<std::vector<std::pair<T, int>>>& grh,",
      "        const T inf = numeric_limits<T>::max()",
      "      ) :",
      "      n(grh.size()), r(r),",
      "      grh(grh), dst(n, inf), inf(inf)",
      "      {",
      "        cal();",
      "      }",
      "    auto result () const {return dst;}",
      "};"
    ],
    "prefix": "dijkstra"
  },
  "../include/graph/floyd_warshall.hpp": {
    "body": [
      "template<typename T>",
      "struct floyd_warshall {",
      "  const int n;",
      "  const T inf;",
      "  std::vector<std::vector<T>> dst;",
      "  void cal () {",
      "    for (int k = 0; k < n; k++) {",
      "      for (int i = 0; i < n; i++) {",
      "        for (int j = 0; j < n; j++) {",
      "          if (dst[i][k] != inf && dst[k][j] != inf) {",
      "            cmn(dst[i][j], dst[i][k] + dst[k][j]);",
      "          }",
      "        }",
      "      }",
      "    }",
      "  }",
      "  floyd_warshall (",
      "      const std::vector<std::vector<T>> adj,",
      "      const T inf",
      "    ) :",
      "    n(adj.size()), inf(inf), dst(adj)",
      "    {",
      "      cal();",
      "    }",
      "  auto& result () {return dst;}",
      "  bool has_negative_cycle () {",
      "    for (int i = 0; i < n; i++) if (dst[i][i] < 0) return true;",
      "    return false;",
      "  }",
      "};"
    ],
    "prefix": "floyd_warshall"
  },
  "../include/graph/heights.hpp": {
    "body": [
      "template<typename T>",
      "class calculate_heights {",
      "  const int n;",
      "  const std::vector<std::vector<std::pair<T, int>>>& grh;",
      "  std::vector<T> dp, ep;",
      "",
      "  void dfs (",
      "      int crr = 0,",
      "      int prt = 0",
      "    ) {",
      "      for (auto const& e : grh[crr]) {",
      "        T w; int nxt; std::tie(w, nxt) = e;",
      "        if (nxt == prt) continue;",
      "        dfs(nxt, crr);",
      "        chmax(dp[crr], dp[nxt] + w);",
      "      }",
      "    }",
      "",
      "  void efs (",
      "      int crr = 0,",
      "      int prt = 0",
      "    ) {",
      "      std::vector<T> cld = {ep[crr]};",
      "      for (auto const& e : grh[crr]) {",
      "        T w; int nxt; std::tie(w, nxt) = e;",
      "        if (nxt == prt) continue;",
      "        cld.push_back(dp[nxt] + w);",
      "      }",
      "      sort(cld.begin(), cld.end(), greater<T>());",
      "      for (auto const& e : grh[crr]) {",
      "        T w; int nxt; std::tie(w, nxt) = e;",
      "        if (nxt == prt) continue;",
      "        ep[nxt] = dp[nxt] + w == cld[0] ?",
      "            cld[1] + w : cld[0] + w;",
      "      }",
      "      for (auto const& e : grh[crr]) {",
      "        T w; int nxt; std::tie(w, nxt) = e;",
      "        if (nxt == prt) continue;",
      "        efs(nxt, crr);",
      "      }",
      "      chmax(dp[crr], ep[crr]);",
      "    }",
      "",
      "  public:",
      "    calculate_heights(",
      "        std::vector<std::vector<std::pair<T, int>>>& grh",
      "      ) :",
      "      n(grh.size()),",
      "      grh(grh),",
      "      dp(n, 0),",
      "      ep(n, 0)",
      "      {",
      "        dfs();",
      "        efs();",
      "      }",
      "    ",
      "    auto operator[] (int i) const -> const T {return dp[i];}",
      "};"
    ],
    "prefix": "heights"
  },
  "../include/graph/kruskal.hpp": {
    "body": [
      "template<typename T>",
      "struct kruskal {",
      "  using edge_type = tuple<T, int, int>;",
      "  const int n;",
      "  std::vector<edge_type> edg;",
      "  std::vector<edge_type> mst;",
      "  T weight_of_mst;",
      "  kruskal (",
      "      int n,",
      "      std::vector<edge_type> edg",
      "    ) :",
      "    n(n),",
      "    edg(edg),",
      "    mst(n - 1),",
      "    weight_of_mst(0)",
      "    {",
      "      sort(edg.begin(), edg.end());",
      "      disjoint_set djs(n);",
      "      int cnt = 0;",
      "      for (auto e : edg) {",
      "        T w; int s, t; std::tie(w, s, t) = e;",
      "        if (djs.unite(s, t)) {",
      "          weight_of_mst += w;",
      "          mst[cnt] = {w, s, t};",
      "          if (++cnt == n - 1) break;",
      "        }",
      "      }",
      "      if (cnt < n - 1) assert(false);",
      "    }    ",
      "};"
    ],
    "prefix": "kruskal"
  },
  "../include/graph/low_link_tree.hpp": {
    "body": [
      "struct low_link_tree {",
      "  const int n;",
      "  const int r = 0;",
      "  int tmr = 0;",
      "  std::vector<int> ord;",
      "  std::vector<int> low;",
      "  set<int> art;",
      "  set<std::pair<int, int>> bdg;",
      "  std::vector<std::vector<int>> grh;",
      "public:",
      "  low_link_tree (",
      "    std::vector<std::vector<int>> const& grh,",
      "    const int root",
      "  )",
      "  : n(grh.size())",
      "  , r(root)",
      "  , ord(n, -1)",
      "  , low(n, -1)",
      "  , grh(grh)",
      "  {",
      "    dfs(r, r);",
      "  }",
      "  void dfs (",
      "    int crr",
      "  ,  int prt",
      "  ) {",
      "    int cnt = 0;",
      "    ord[crr] = low[crr] = tmr++;",
      "    for (int nxt : grh[crr]) {",
      "      if (ord[nxt] == -1) {",
      "        cnt++;",
      "        dfs(nxt, crr);",
      "        chmin(low[crr], low[nxt]);",
      "        if (crr != r && ord[crr] <= low[nxt]) art.insert(crr);",
      "        if (ord[crr] < low[nxt]) bdg.emplace(min(crr, nxt), max(crr, nxt));",
      "      }",
      "      if (nxt != prt) chmin(low[crr], ord[nxt]);",
      "    }",
      "    if (crr == r && cnt > 1) art.insert(crr);",
      "  }",
      "};"
    ],
    "prefix": "low_link_tree"
  },
  "../include/graph/prim.hpp": {
    "body": [
      "template <typename T>",
      "struct prim {",
      "  const int n;",
      "  std::vector<std::vector<std::pair<T, int>>> grh;",
      "  T weight_of_mst;",
      "  prim (",
      "      std::vector<std::vector<std::pair<T, int>>> grh",
      "    ) :",
      "    n(grh.size()),",
      "    grh(grh),",
      "    weight_of_mst(0)",
      "    {",
      "      std::vector<bool> ckd(n, false);",
      "      priority_queue<",
      "        std::pair<T, int>,",
      "        std::vector<std::pair<T, int>>,",
      "        greater<std::pair<T, int>>",
      "      > que;",
      "      que.emplace(0, 0);",
      "      while (!que.empty()) {",
      "        T w; int t;",
      "        std::tie(w, t) = que.top(), que.pop();",
      "        if (ckd[t]) continue;",
      "        weight_of_mst += w, ckd[t] = true;",
      "        for (auto p : grh[t]) que.push(p);",
      "      }",
      "    }",
      "};"
    ],
    "prefix": "prim"
  },
  "../include/graph/topological_sort_1.hpp": {
    "body": [
      "class topological_sort {",
      "  const int n;",
      "  const std::vector<std::vector<int>>& grh;",
      "  std::vector<int> srd;",
      "  std::vector<int> ckd;",
      "  bool flg;",
      "",
      "  bool dfs (int crr) {",
      "    if (ckd[crr] == 1) return true;",
      "    if (ckd[crr] == 2) return false;",
      "    bool ret = false;",
      "    ckd[crr] = 1;",
      "    for (int nxt : grh[crr]) {",
      "      ret |= dfs(nxt);",
      "    }",
      "    ckd[crr] = 2;",
      "    srd.insert(srd.begin(), crr);",
      "    return ret;",
      "  }",
      "",
      "  public:",
      "    topological_sort (",
      "        const std::vector<std::vector<int>>& grh",
      "      ) :",
      "      n(grh.size()),",
      "      grh(grh),",
      "      srd(),",
      "      ckd(n, 0),",
      "      flg(",
      "          [&](){",
      "            bool ret = false;",
      "            for (int i = 0; i < n; i++) {",
      "              flg |= (ckd[i] == 0 && dfs(i));",
      "            }",
      "            return ret;",
      "          }()",
      "        )",
      "      {",
      "      }",
      "    bool has_cycle () {return flg;}",
      "    auto sorted() const -> const std::vector<int>& {return srd;}",
      "    auto operator [] (int i) const -> int {return srd[i];}",
      "};"
    ],
    "prefix": "topological_sort_1"
  },
  "../include/graph/topological_sort_2.hpp": {
    "body": [
      "// none (tail)"
    ],
    "prefix": "topological_sort_2"
  },
  "../include/io/pair_io.hpp": {
    "body": [
      "template <typename T, typename U>",
      "std::ostream& operator<< (std::ostream& os, const std::pair<T, U>& pair){",
      "  return os << \"(\" << pair.first << \",\" << pair.second << \")\";",
      "}",
      "",
      "template <typename T, typename U>",
      "std::istream& operator>> (std::iostream& is, std::pair<T, U>& pair) {",
      "  return is >> pair.first >> pair.second;",
      "}"
    ],
    "prefix": "pair_io"
  },
  "../include/io/tuple_io.hpp": {
    "body": [
      "template <typename... Args, std::size_t ... Inds>",
      "std::ostream& tuple_output_impl",
      "(",
      "  std::ostream& os,",
      "  const std::tuple<Args...>& tuple,",
      "  std::integer_sequence<std::size_t, Inds...>",
      ")",
      "{",
      "  os << \"(\";",
      "  (void)std::initializer_list<int>{(",
      "    (void)(os << (Inds > 0 ? \",\" : \"\") << std::get<Inds>(tuple)), 0",
      "  )...};",
      "  return os << \")\";",
      "}",
      "template <typename... Args>",
      "std::ostream& operator<< (std::ostream& os, const std::tuple<Args...>& tuple)",
      "{",
      "  return tuple_output_impl(os, tuple, std::index_sequence_for<Args...>());",
      "}",
      "",
      "template <typename... Args, std::size_t ... Inds>",
      "std::istream& tuple_input_impl",
      "(",
      "  std::istream& is,",
      "  std::tuple<Args...>& tuple,",
      "  std::integer_sequence<std::size_t, Inds...>",
      ")",
      "{",
      "  (void)std::initializer_list<int>{(",
      "    (void)(is >> std::get<Inds>(tuple)), 0",
      "  )...};",
      "  return is;",
      "}",
      "template <typename... Args>",
      "std::istream& operator>> (std::istream& is, std::tuple<Args...>& tuple)",
      "{",
      "  return tuple_input_impl(is, tuple, std::index_sequence_for<Args...>());",
      "}"
    ],
    "prefix": "tuple_io"
  },
  "../include/io/vector_io.hpp": {
    "body": [
      "template <typename T>",
      "std::istream& operator>> (std::istream& is, std::vector<T>& v)",
      "{",
      "  for (auto & x : v) is >> x;",
      "  return is;",
      "}",
      "",
      "template <typename T>",
      "std::ostream& operator<< (std::ostream& os, const std::vector<T>& v)",
      "{",
      "  auto n = v.size();",
      "  os << \"{\";",
      "  for (size_t i = 0; i < n; i++)",
      "    os << (i > 0 ? \",\" : \"\") << v[i];",
      "  return os << \"}\";",
      "}"
    ],
    "prefix": "vector_io"
  },
  "../include/matricies/gauss_jordan_int.hpp": {
    "body": [
      "class gauss_jordan {",
      "  const int h, w;",
      "  int rk;",
      "  std::vector<bool> ckd;",
      "  std::vector<int> p, a;",
      "  void init () {",
      "    for (int j = 0; j < w; j++) {",
      "      for (int pvt = 0; pvt < h; pvt++) {",
      "        if (ckd[pvt]) continue;",
      "        if (a[j] >> pvt & 1) {",
      "          ckd[pvt] = true; rk++;",
      "          int comb = a[j] ^ 1 << pvt;",
      "          for (int i = 0; i < h; i++) if (p[i] >> pvt & 1) p[i] ^= comb;",
      "          for (int k = j; k < w; k++) if (a[k] >> pvt & 1) a[k] ^= comb;",
      "          break;",
      "        }",
      "      }",
      "    }",
      "  }",
      "  int transform (int y) const {",
      "    int z = 0;",
      "    for (int i = 0; i < h; i++) {",
      "      if (y >> i & 1) z |= p[i];",
      "    }",
      "    return z;",
      "  }",
      "  public:",
      "    gauss_jordan (",
      "        std::vector<int> a,",
      "        int h",
      "      ) :",
      "      h(h), w(a.size()), rk(0),",
      "      ckd(h, false),",
      "      p([&]{",
      "        std::vector<int> p(h); ",
      "        for (int i = 0, x = 1; i < h; i++, x *= 2) p[i] = x;",
      "        return p;",
      "      }()),",
      "      a(a)",
      "      {",
      "        init();",
      "      }",
      "    int rank () const {return rk;}",
      "    int kernel () const {return w - rk;}",
      "    int image () const {return h - rk;}",
      "    bool solvable (int y) const {",
      "      assert (!(y >> h));",
      "      int acm = accumulate(a.begin(), a.end(), 0, [](int x, int y){return x | y;});",
      "      int z = transform(y);",
      "      return !(~acm & z);",
      "    }",
      "};"
    ],
    "prefix": "gauss_jordan_int"
  },
  "../include/matricies/square_matrix.hpp": {
    "body": [
      "template <int N, typename Semiring>",
      "class square_matrix",
      "{",
      "  template <int N_, typename Semiring_>",
      "  friend bool operator==(const square_matrix<N_, Semiring_>&, const square_matrix<N_, Semiring_>&);",
      "",
      "  public:",
      "    using this_type   = square_matrix<N, Semiring>;",
      "    using value_type  = typename Semiring::type;",
      "    using matrix_type = std::array<std::array<value_type, N>,  N>;",
      "",
      "  private:",
      "    matrix_type storage;",
      "",
      "  public:",
      "    constexpr square_matrix() = default;",
      "    constexpr square_matrix(const square_matrix&) = default;",
      "    constexpr square_matrix(square_matrix&&) = default;",
      "    square_matrix& operator=(const square_matrix&) = default;",
      "    square_matrix& operator=(square_matrix&&) = default;",
      "",
      "    constexpr square_matrix(const matrix_type& x) : storage(x){}",
      "    constexpr square_matrix",
      "    (",
      "      std::initializer_list<std::initializer_list<value_type>> list",
      "    )",
      "    {",
      "      int i = 0;",
      "      for (auto &row: list)",
      "      {",
      "        int j = 0;",
      "        for (auto val : row)",
      "        {",
      "          storage.at(i).at(j) = val;",
      "          j++;",
      "        }",
      "        i++;",
      "      }",
      "    }",
      "",
      "    // Special Elements.",
      "    static auto zero_matrix()",
      "    {",
      "      auto ret = this_type{};",
      "      for (int i = 0; i < N; i++)",
      "      {",
      "        for (int j = 0; j < N; j++)",
      "        {",
      "          ret.at(i, j) = Semiring::add_id();",
      "        }",
      "      }",
      "      return ret;",
      "    }",
      "",
      "    static auto identity_matrix()",
      "    {",
      "      auto ret = this_type{};",
      "      for (int i = 0; i < N; i++)",
      "      {",
      "        for (int j = 0; j < N; j++)",
      "        {",
      "          ret.at(i, j) = i == j",
      "            ? Semiring::mul_id()",
      "            : Semiring::add_id();",
      "        }",
      "      }",
      "      return ret;",
      "    }",
      "",
      "    // Accessors.",
      "    auto& at(int i, int j)       {return storage.at(i).at(j);}",
      "    auto& at(int i, int j) const {return storage.at(i).at(j);}",
      "",
      "    // Operaters.",
      "    auto& operator+=(const square_matrix& other)",
      "    {",
      "      auto ret = zero_matrix();",
      "      for (int i = 0; i < N; i++)",
      "      {",
      "        for (int j = 0; j < N; j++)",
      "        {",
      "          Semiring::add_eq(at(i,j), other.at(i, j));",
      "        }",
      "      }",
      "      return *this;",
      "    }",
      "",
      "    auto& operator*=(const square_matrix& other)",
      "    {",
      "      auto ret = zero_matrix();",
      "      for (int i = 0; i < N; i++)",
      "      {",
      "        for (int j = 0; j < N; j++)",
      "        {",
      "          for (int k = 0; k < N; k++)",
      "          {",
      "            Semiring::add_eq(ret.at(i, k), Semiring::mul(at(i, j), other.at(j, k)));",
      "          }",
      "        }",
      "      }",
      "      return *this = ret;",
      "    }",
      "};",
      "",
      "template <typename T>",
      "struct is_square_matrix : std::false_type{};",
      "",
      "template <int N, typename Semiring>",
      "struct is_square_matrix<square_matrix<N, Semiring>> : std::true_type{};",
      "",
      "template <typename T>",
      "bool operator==(const T& lhs, const T& rhs) { return lhs.value == rhs.value; }",
      "",
      "template <typename T>",
      "bool operator!=(const T& lhs, const T& rhs) { return !(lhs == rhs); }",
      "",
      "template <typename T>",
      "T operator+(T lhs, const T& rhs) { return lhs += rhs; }",
      "",
      "template <typename T>",
      "T operator*(T lhs, const T& rhs) { return lhs *= rhs; }",
      "",
      "",
      "template <int N, typename Semiring>",
      "std::string to_string(const square_matrix<N, Semiring>& a)",
      "{",
      "  using std::literals::string_literals::operator\"\"s;",
      "  auto ret = \"square_matrix{ \"s;",
      "  for (int i = 0; i < N; i++)",
      "  {",
      "    if (i > 0) ret += \", \";",
      "    ret += \"{ \";",
      "    for (int j = 0; j < N; j++)",
      "    {",
      "      if (j > 0) ret += \", \";",
      "      ret += std::to_string(a.at(i, j));",
      "    }",
      "    ret += \" }\";",
      "  }",
      "  ret += \" }\";",
      "  return ret;",
      "}",
      "",
      "template <typename T>",
      "struct min_tolopical",
      "{",
      "  using type = T;",
      "  static auto add_id()  {return std::numeric_limits<T>::max();}",
      "  static auto mul_id()  {return 0;}",
      "  static auto add(T x, T y) {return std::min(x, y);}",
      "  static auto mul(T x, T y)",
      "  {",
      "    if (x == add_id() || y == add_id()) return add_id();",
      "    return x + y;",
      "  }",
      "  static auto add_eq(T& x, T y) {return x = add(x, y);}",
      "};",
      "",
      "template <typename T>",
      "struct min_tolopical",
      "{",
      "  using type = T;",
      "  static auto add_id()  {return std::numeric_limits<T>::min();}",
      "  static auto mul_id()  {return 0;}",
      "  static auto add(T x, T y) {return std::max(x, y);}",
      "  static auto mul(T x, T y)",
      "  {",
      "    if (x == add_id() || y == add_id()) return add_id();",
      "    return x + y;",
      "  }",
      "  static auto add_eq(T& x, T y) {return x = add(x, y);}",
      "};",
      "",
      "template <int N, typename T>",
      "using min_tolopical_matrix = square_matrix<N, min_tolopical<T>>;",
      "",
      "template <int N, typename T>",
      "using max_tolopical_matrix = square_matrix<N, min_tolopical<T>>;"
    ],
    "prefix": "square_matrix"
  },
  "../include/network_flow/bipartite_matching.hpp": {
    "body": [
      "class bipartite_matching",
      "{",
      "    int L, R;",
      "    std::vector<std::vector<int>> graph;",
      "    std::vector<int> match, level;",
      "",
      "    bool bfs()",
      "    {",
      "      std::fill(level.begin(), level.end(), -1);",
      "      std::queue<int> que;",
      "      for (int i = 0; i < L; i++)",
      "      {",
      "        if (match.at(i) < 0)",
      "        {",
      "          level.at(i) = 0;",
      "          que.emplace(i);",
      "        }",
      "      }",
      "      bool ret = false;",
      "      while (!que.empty())",
      "      {",
      "        auto crr = que.front(); que.pop();",
      "        for (auto nxt : graph.at(crr))",
      "        {",
      "          if (level.at(nxt) != -1) continue;",
      "          level.at(nxt) = level.at(crr) + 1;",
      "          auto w = match.at(nxt);",
      "          if (w == -1)",
      "          {",
      "            ret = true;",
      "          }",
      "          else if (level.at(w) == -1)",
      "          {",
      "            level.at(w) = level.at(crr) + 1;",
      "            que.emplace(w);",
      "          }",
      "        }",
      "      }",
      "      return ret;",
      "    }",
      "",
      "    bool dfs(int crr)",
      "    {",
      "      for (auto nxt : graph.at(crr))",
      "      {",
      "        assert(level.at(nxt) <= level.at(crr) + 1);",
      "        if (level.at(nxt) < level.at(crr) + 1) continue;",
      "        level.at(nxt) = -1;",
      "        auto w = match.at(nxt);",
      "        if (w == -1 || dfs(w))",
      "        {",
      "          match.at(nxt) = crr;",
      "          match.at(crr) = nxt;",
      "          level.at(crr) = -1;",
      "          return true;",
      "        }",
      "      }",
      "      level.at(crr) = -1;",
      "      return false;",
      "    }",
      "",
      "  public:",
      "    bipartite_matching()=default;",
      "    bipartite_matching(int L, int R):",
      "      L(L), R(R), graph(L + R), match(L + R, -1), level(L + R)",
      "      {}",
      "",
      "    void insert_edge(int u, int v)",
      "    {",
      "      v += L;",
      "      graph.at(u).emplace_back(v);",
      "      graph.at(v).emplace_back(u);",
      "    }",
      "",
      "",
      "    int build ()",
      "    {",
      "      auto ret = 0;",
      "      while (bfs())",
      "      {",
      "        for (int i = 0; i < L; i++)",
      "        {",
      "          if (match.at(i) == -1 && dfs(i))",
      "          {",
      "            ret++;",
      "          }",
      "        }",
      "      }",
      "      return ret;",
      "    }",
      "",
      "    auto collect() const {return match;}",
      "",
      "    auto count() const",
      "    {",
      "      auto k = L + R - std::count(match.begin(), match.end(), -1);",
      "      assert(k % 2 == 0);",
      "      return k / 2;",
      "    }",
      "};"
    ],
    "prefix": "bipartite_matching"
  },
  "../include/network_flow/dinic.hpp": {
    "body": [
      "template <typename Value>",
      "struct dinic_edge",
      "{",
      "  int to; Value cap; int rev;",
      "  dinic_edge(int to, Value cap, int rev): to(to), cap(cap), rev(rev){}",
      "};",
      "",
      "template <typename Value>",
      "std::ostream& operator<< (std::ostream& os, const dinic_edge<Value>& e)",
      "{",
      "  return os",
      "    << \"dinic_edge{\"",
      "    << \"to:\" << e.to << \",\"",
      "    << \"cap:\" << e.cap << \",\"",
      "    << \"rev:\" << e.rev",
      "    << \"}\";",
      "}",
      "",
      "template <typename Value>",
      "class dinic {",
      "",
      "  const int n, source, sink;",
      "  std::vector<bool> ckd;",
      "  std::vector<int> level;",
      "  std::vector<std::vector<dinic_edge<Value>>> graph;",
      "  static constexpr Value inf = std::numeric_limits<Value>::max();",
      "",
      "  void bfs ()",
      "  {",
      "    std::queue<int> que;",
      "    que.emplace(source); level.at(source) = 0;",
      "    while (!que.empty())",
      "    {",
      "      auto crr = que.front(); que.pop();",
      "      for (auto const& e : graph.at(crr))",
      "      {",
      "        if (e.cap == 0) continue;",
      "        int nxt = e.to;",
      "        if (level.at(nxt) != -1) continue;",
      "        que.push(nxt);",
      "        level.at(nxt) = level.at(crr) + 1;",
      "      }",
      "    }",
      "  }",
      "",
      "  auto dfs (int crr, Value f = inf) -> Value",
      "  {",
      "      if (crr == sink) return f;",
      "      ckd.at(crr) = true;",
      "      for (auto& e : graph.at(crr))",
      "      {",
      "        auto nxt = e.to;",
      "        if (ckd.at(nxt) || e.cap == 0 || level.at(crr) >= level.at(nxt)) continue;",
      "        auto d = dfs(nxt, std::min(f, e.cap));",
      "        if (d > 0)",
      "        {",
      "          e.cap -= d;",
      "          graph.at(nxt).at(e.rev).cap += d;",
      "          return d;",
      "        }",
      "      }",
      "      level.at(crr) = -1;",
      "      return 0;",
      "  }",
      "",
      "  public:",
      "    dinic (int n, int source, int sink) :",
      "      n(n), source(source), sink(sink), graph(n)",
      "      {}",
      "    void insert(int u, int v, Value c)",
      "    {",
      "      int k = graph.at(u).size();",
      "      int l = graph.at(v).size();",
      "      graph.at(u).emplace_back(v, c, l);",
      "      graph.at(v).emplace_back(u, 0, k);",
      "    }",
      "",
      "    Value build()",
      "    {",
      "      Value ret = 0;",
      "      while (true)",
      "      {",
      "        level.assign(n, -1);",
      "        bfs();",
      "        if (level.at(sink) == -1) return ret;",
      "        ckd.assign(n, false);",
      "        while (true)",
      "        {",
      "          Value f = dfs(source);",
      "          if (f == 0) break;",
      "          ret += f;",
      "        }",
      "      }",
      "    }",
      "};"
    ],
    "prefix": "dinic"
  },
  "../include/network_flow/ford_fulkerson.hpp": {
    "body": [
      "template <typename T>",
      "class ford_fulkerson {",
      "  struct edge {",
      "    int to; T cap;",
      "    weak_ptr<edge> rev;",
      "    edge(int to, T cap) : to(to), cap(cap) {}",
      "  };",
      "  const int n, source, sink;",
      "  std::vector<bool> ckd;",
      "  std::vector<std::vector<shared_ptr<edge>>> grh;",
      "  static constexpr T inf = numeric_limits<T>::max();",
      "  T dfs () {",
      "    return fix ([&](auto dfs, int crr, int f = inf) -> T {",
      "      if (crr == sink) return f;",
      "      ckd[crr] = true;",
      "      for (auto& e : grh[crr]) {",
      "        if (ckd[e->to] || !e->cap) continue;",
      "        T d = dfs(e->to, min(f, e->cap));",
      "        if (d) {",
      "          e->cap -= d;",
      "          e->rev.lock()->cap += d;",
      "          return d;",
      "        }",
      "      }",
      "      return 0;",
      "    })(source);",
      "  }",
      "  public:",
      "    ford_fulkerson (int n, int source, int sink) :",
      "      n(n), source(source), sink(sink), grh(n)",
      "      {}",
      "    void insert(int u, int v, T c) {",
      "      auto e = make_shared<edge>(v, c);",
      "      auto r = make_shared<edge>(u, 0);",
      "      e->rev = r;",
      "      r->rev = e;",
      "      grh[u].push_back(e);",
      "      grh[v].push_back(r);",
      "    }",
      "    T cal() {",
      "      T ret = 0;",
      "      while (true) {",
      "        ckd.assign(n, false);",
      "        T f = dfs();",
      "        if (!f) return ret;",
      "        ret += f;",
      "      }",
      "    }",
      "};"
    ],
    "prefix": "ford_fulkerson"
  },
  "../include/network_flow/minimum_cost_flow.hpp": {
    "body": [
      "template <typename Flow, typename Cost>",
      "class minimum_cost_flow {",
      "    struct edge {",
      "      int to; Flow cap; Cost cost; int rev;",
      "      edge(int to, Flow cap, Cost cost, int rev): to(to), cap(cap), cost(cost), rev(rev){}",
      "    };",
      "",
      "    const int                      n, source, sink;",
      "    std::vector<Cost>              distance;",
      "    std::vector<std::vector<edge>> graph;",
      "    std::vector<int>               ckd;",
      "",
      "    const Flow max_flow = std::numeric_limits<Flow>::max();",
      "    const Cost max_dist = std::numeric_limits<Cost>::max();",
      "",
      "    template <typename T, typename U>",
      "    auto cmn(T& a, U b) {if (a > b) {a = b; return true;} return false;}",
      "",
      "    void bellman_ford () {",
      "      distance.assign(n, max_dist);",
      "      distance.at(source) = 0;",
      "      for (int t = 0; t < n; t++) {",
      "        bool renewed = false;",
      "        for (int i = 0; i < n; i++) {",
      "          for (auto const& e : graph.at(i)) {",
      "            if (e.cap == 0) continue;",
      "            auto crr = distance.at(i);",
      "            if (crr == max_dist) continue;",
      "            if (cmn(distance.at(e.to), crr + e.cost)) {",
      "              renewed = true;",
      "            }",
      "          }",
      "        }",
      "        if (!renewed) break;",
      "      }",
      "    }",
      "",
      "    auto flush_impl (int crr, Flow f) {",
      "      if (ckd.at(crr)) return Flow(0);",
      "      ckd.at(crr) = true;",
      "      if (crr == sink) return f;",
      "      for (auto & e : graph.at(crr)) {",
      "        if (e.cap == 0) continue;",
      "        if (distance.at(crr) + e.cost != distance.at(e.to)) continue;",
      "        auto d = flush_impl(e.to, std::min(f, e.cap));",
      "        if (d > 0) {",
      "          e.cap -= d;",
      "          graph.at(e.to).at(e.rev).cap += d;",
      "          return d;",
      "        }",
      "      }",
      "      return Flow(0);",
      "    }",
      "",
      "    auto flush () {",
      "      ckd.assign(n, false);",
      "      return flush_impl(source, max_flow);",
      "    }",
      "",
      "  public:",
      "    minimum_cost_flow (int n, int source, int sink) :",
      "      n(n), source(source), sink(sink), graph(n) {}",
      "",
      "    void insert(int u, int v, Flow cap, Cost cost) {",
      "      graph.at(u).emplace_back(v, cap, cost, graph.at(v).size());",
      "      graph.at(v).emplace_back(u, 0, -cost,  graph.at(u).size() - 1);",
      "    }",
      "",
      "    auto build(Flow required_flow) {",
      "      Cost ret = 0;",
      "      while (true) {",
      "        bellman_ford();",
      "        auto d = distance.at(sink);",
      "        if (distance.at(sink) == max_dist) break;",
      "        auto f = flush();",
      "        if (f >= required_flow) {",
      "          ret += d * required_flow;",
      "          return ret;",
      "        } else {",
      "          ret += d * f;",
      "          required_flow -= f;",
      "        }",
      "      }",
      "      return -1;",
      "    }",
      "};"
    ],
    "prefix": "minimum_cost_flow"
  },
  "../include/number_theory/factorials.hpp": {
    "body": [
      "",
      "class factorials",
      "{",
      "    std::vector<mint> fact, finv;",
      "",
      "  public:",
      "    factorials()=default;",
      "",
      "    void build(int n)",
      "    {",
      "      fact.resize(n), finv.resize(n);",
      "      fact.at(0) = 1;",
      "      for (int i = 1; i < n; i++) fact.at(i) = fact.at(i - 1) * mint(i);",
      "      finv.at(n - 1) = mint(1) / fact.at(n - 1);",
      "      for (int i = n - 2; i >= 0; i--) finv.at(i) = finv.at(i + 1) * mint(i + 1);",
      "    }",
      "",
      "    // Factorial.",
      "    auto operator()(int i) const {return fact.at(i);}",
      "",
      "    // Inverse of Facgorial.",
      "    auto inv       (int i) const {return finv.at(i);}",
      "",
      "    // Binominal Coefficient.",
      "    auto binom(int i, int j) const",
      "    {",
      "      assert(0 <= i);",
      "      if (j < 0 ||i < j) return mint(0);",
      "      return fact.at(i) * finv.at(j) * finv.at(i - j);",
      "    }",
      "",
      "    // Deal Apples.",
      "    auto deal(int i, int j) const",
      "    {",
      "      return binom(i + j - 1, j - 1);",
      "    }",
      "};"
    ],
    "prefix": "factorials"
  },
  "../include/number_theory/factorize.hpp": {
    "body": [
      "class factorize {",
      "  int x;",
      "  map<int, int> mp;",
      "  std::vector<int> pdv;",
      "  std::vector<int> pdv_m;",
      "",
      "  public:",
      "    factorize(",
      "        const int x",
      "      ) :",
      "      x(x), mp(), pdv()",
      "      {",
      "        for (int p = 2; p * p <= x; p++) {",
      "          while (!(x % p)) {",
      "            mp[p]++;",
      "            pdv.push_back(p);",
      "            x /= p;",
      "          }",
      "        }",
      "        if (x != 1) mp[x] = 1;",
      "        pdv.push_back(x);",
      "        pdv_m = pdv.resize(unique(pdv.begin(), pdv.end()) - pdv.begin());",
      "      }",
      "    ",
      "    const auto& factorize () const {return pdv;}",
      "    const auto& prime_divisors () const {return pdv_m;}",
      "    const auto& multiplicities () const {return mp;}",
      "}"
    ],
    "prefix": "factorize"
  },
  "../include/number_theory/gcd.hpp": {
    "body": [
      "template<typename T>",
      "inline T gcd (T a, T b)",
      "{",
      "  if (a < 0) a = -a;",
      "  if (b < 0) b = -b;",
      "  if (a < b) std::swap(a, b);",
      "  while (b)",
      "  {",
      "    a %= b;",
      "    std::swap(a, b);",
      "  }",
      "  return a;",
      "}"
    ],
    "prefix": "gcd"
  },
  "../include/number_theory/mint.hpp": {
    "body": [
      "template <typename T>",
      "T inverse(T a, T m) {",
      "  T u = 0, v = 1;",
      "  while (a != 0) {",
      "    T t = m / a;",
      "    m -= t * a; std::swap(a, m);",
      "    u -= t * v; std::swap(u, v);",
      "  }",
      "  assert(m == 1);",
      "  return u;",
      "}",
      "template <typename T>",
      "class modular {",
      "  private:",
      "    int value;",
      "  public:",
      "    constexpr modular() = default;",
      "    constexpr modular(const modular&) = default;",
      "    constexpr modular(modular&&) = default;",
      "    modular& operator=(const modular&) = default;",
      "    modular& operator=(modular&&) = default;",
      "",
      "    template <typename U>",
      "    modular (const U& x) {value = normalize(x);}",
      "",
      "    template <typename U>",
      "    static auto normalize(const U& x) {",
      "      int v = static_cast<int>(-mod() <= x && x < mod() ? x : x % mod());",
      "      if (v < 0) v += mod();",
      "      return v;",
      "    }",
      "",
      "    auto const& operator()() const { return value; }",
      "    template <typename U>",
      "    explicit operator U() const { return static_cast<U>(value); }",
      "    constexpr static auto mod() { return T::value; }",
      "",
      "    auto& operator+=(const modular& other) {",
      "      if ((value += other.value) >= mod()) value -= mod();",
      "      return *this;",
      "    }",
      "    auto& operator-=(const modular& other) {",
      "      if ((value -= other.value) < 0) value += mod();",
      "      return *this;",
      "    }",
      "    template <typename U>",
      "    auto& operator+=(const U& other) {return *this += modular(other); }",
      "    template <typename U>",
      "    auto& operator-=(const U& other) {return *this -= modular(other); }",
      "    auto operator-() const { return modular(-value); }",
      "    auto& operator++() {return *this += 1;}",
      "    auto& operator--() {return *this -= 1;}",
      "    auto  operator++(int) {modular result(*this); operator++(); return result;}",
      "    auto  operator--(int) {modular result(*this); operator--(); return result;}",
      "",
      "    template <typename U = T>",
      "    auto& operator*=(const modular& rhs) {",
      "      value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));",
      "      return *this;",
      "    }",
      "    auto& operator/=(const modular& other) {",
      "      return *this *= modular(inverse(other.value, mod()));",
      "    }",
      "};",
      "template <typename T> struct is_modular : std::false_type {};",
      "template <typename T> struct is_modular <modular<T>> : std::true_type{};",
      "template <typename T> constexpr bool is_modular_v = is_modular<T>::value;",
      "",
      "template <typename T> bool operator==(const modular<T>& lhs, const modular<T>& rhs) { return lhs.value == rhs.value; }",
      "template <typename T, typename U> bool operator==(const modular<T>& lhs, U rhs) { return lhs == modular<T>(rhs); }",
      "template <typename T, typename U> bool operator==(U lhs, const modular<T>& rhs) { return modular<T>(lhs) == rhs; }",
      "",
      "template <typename T> bool operator!=(const modular<T>& lhs, const modular<T>& rhs) { return !(lhs == rhs); }",
      "template <typename T, typename U> bool operator!=(const modular<T>& lhs, U rhs) { return !(lhs == rhs); }",
      "template <typename T, typename U> bool operator!=(U lhs, const modular<T>& rhs) { return !(lhs == rhs); }",
      "",
      "template <typename T> modular<T> operator+(const modular<T>& lhs, const modular<T>& rhs) { return modular<T>(lhs) += rhs; }",
      "template <typename T, typename U> modular<T> operator+(const modular<T>& lhs, U rhs) { return modular<T>(lhs) += rhs; }",
      "template <typename T, typename U> modular<T> operator+(U lhs, const modular<T>& rhs) { return modular<T>(lhs) += rhs; }",
      "",
      "template <typename T> modular<T> operator-(const modular<T>& lhs, const modular<T>& rhs) { return modular<T>(lhs) -= rhs; }",
      "template <typename T, typename U> modular<T> operator-(const modular<T>& lhs, U rhs) { return modular<T>(lhs) -= rhs; }",
      "template <typename T, typename U> modular<T> operator-(U lhs, const modular<T>& rhs) { return modular<T>(lhs) -= rhs; }",
      "",
      "template <typename T> modular<T> operator*(const modular<T>& lhs, const modular<T>& rhs) { return modular<T>(lhs) *= rhs; }",
      "template <typename T, typename U> modular<T> operator*(const modular<T>& lhs, U rhs) { return modular<T>(lhs) *= rhs; }",
      "template <typename T, typename U> modular<T> operator*(U lhs, const modular<T>& rhs) { return modular<T>(lhs) *= rhs; }",
      "",
      "template <typename T> modular<T> operator/(const modular<T>& lhs, const modular<T>& rhs) { return modular<T>(lhs) /= rhs; }",
      "template <typename T, typename U> modular<T> operator/(const modular<T>& lhs, U rhs) { return modular<T>(lhs) /= rhs; }",
      "template <typename T, typename U> modular<T> operator/(U lhs, const modular<T>& rhs) { return modular<T>(lhs) /= rhs; }",
      "",
      "template<typename T, typename U>",
      "modular<T> pow (const modular<T>& a, U b) {",
      "  assert(b >= 0);",
      "  modular<T> x = a, ret = 1;",
      "  for (; b > 0; b /= 2) {",
      "    if (b % 2 == 1) ret *= x;",
      "    x *= x;",
      "  }",
      "  return ret;",
      "}",
      "",
      "template <typename T>",
      "std::string to_string(const modular<T>& a) {",
      "  return std::to_string(a());",
      "}",
      "template <typename T>",
      "auto operator<<(std::ostream& os, const T& a)",
      "  -> std::enable_if_t<is_modular_v<T>, std::ostream&>{",
      "    return os << a();",
      "  }",
      "template <typename T>",
      "auto operator>>(std::istream& is, T& a)",
      "  -> std::enable_if_t<is_modular_v<T>, std::istream&> {",
      "  long long x; is >> x;",
      "  a = T(x);",
      "  return is;",
      "}",
      "",
      "",
      "using mod_type = int;",
      "",
      "struct voriable_mod { static mod_type value; };",
      "mod_type voriable_mod::value;",
      "// mod_type& md = voriable_mod::value;",
      "// using Mint = Modular<voriable_mod>;",
      "",
      "",
      "constexpr int md = ${1:1'000'000'007};",
      "using mint = modular<std::integral_constant<std::decay_t<decltype(md)>, md>>;"
    ],
    "prefix": "mint"
  },
  "../include/number_theory/sieve_of_eratosthenes.hpp": {
    "body": [
      "template <size_t N>",
      "class sieve_of_eratosthenes {",
      "    std::bitset<N> is_prime_;",
      "",
      "  public:",
      "    constexpr sieve_of_eratosthenes(){",
      "      is_prime_ = ~is_prime_;",
      "      is_prime_.reset(0), is_prime_.reset(1);",
      "      for (size_t p = 2; p < N; p++) {",
      "        if (!is_prime_.test(p)) continue;",
      "        for (size_t j = 2; j * p < N; j++) {",
      "          is_prime_.reset(p * j);",
      "        }",
      "      }",
      "    }",
      "",
      "    // Return the bitset testing if a number is prime.",
      "    constexpr const auto& is_prime() const {return is_prime_;}",
      "",
      "    // Returns the vector of prime numbers.",
      "    template <typename T>",
      "    auto primes() const {",
      "      std::vector<T> primes{}; ",
      "      for (size_t i = 0; i < N; i++) {",
      "        if (is_prime_.test(i)) primes.push_back(i);",
      "      }",
      "      return primes;",
      "    }",
      "};"
    ],
    "prefix": "sieve_of_eratosthenes"
  },
  "../include/number_theory/tropical.hpp": {
    "body": [
      "template <typename T, typename F, std::enable_if_t<",
      "    std::is_same<std::result_of_t<F(T, T)>, T>::value,",
      "    std::nullptr_t> = nullptr>",
      "class tropical {",
      "    T value;",
      "  ",
      "  public:",
      "    using value_type = T;",
      "    constexpr tropical()=default;",
      "    constexpr tropical(const tropical&)=default;",
      "    constexpr tropical(tropical&&)=default;",
      "    tropical& operator=(const tropical&)=default;",
      "    tropical& operator=(tropical&&)=default;",
      "",
      "    constexpr tropical(T t) : value(t){}",
      "",
      "    auto const& operator()() const { return value; }",
      "    template <typename U>",
      "    explicit operator U() const { return static_cast<U>(value); }",
      "",
      "    auto& operator+=(const tropical& other) {",
      "      value = F{}(value, other.value);",
      "      return *this;",
      "    }",
      "    template <typename U>",
      "    auto& operator+=(const U& other) {return *this += tropical(other); }",
      "  ",
      "    template <typename U = T>",
      "    auto& operator*=(const tropical& other) {",
      "      value += other.value;",
      "      return *this;",
      "    }",
      "};",
      "template <typename T> struct is_tropical : std::false_type{};",
      "template <typename T, typename F> struct is_tropical <tropical<T, F>> : std::true_type{};",
      "template <typename T> constexpr bool is_tropical_v = is_tropical<T>::value;",
      "",
      "template <typename T, std::enable_if_t<",
      "  is_tropical_v<T>, std::nullptr_t> = nullptr>",
      "bool operator==(const T& lhs, const T& rhs) {return lhs.value == rhs.value;}",
      "",
      "template <typename T>",
      "auto operator+(const T& lhs, const T& rhs)",
      "  -> std::enable_if_t<is_tropical_v<T>, T>",
      "  {return T(lhs) += rhs;}",
      "",
      "template <typename T>",
      "auto operator*(const T& lhs, const T& rhs)",
      "  -> std::enable_if_t<is_tropical_v<T>, T>",
      "  {return T(lhs) *= rhs;}",
      "",
      "template <typename T, typename F>",
      "std::string to_string(const tropical<T, F>& a)",
      "  {return std::to_string(a());}",
      "",
      "template <typename T, typename F>",
      "std::ostream& operator<<(std::ostream& os, const tropical<T, F>& a)",
      "  {return os << a();}",
      "",
      "template <typename T, typename F>",
      "std::istream& operator>>(std::istream& is, tropical<T, F>& a)",
      "  {T x; is >> x; a = tropical<T, F>(x); return is;}",
      "",
      "template <typename T>",
      "struct min_fn_object {",
      "  auto operator()(T a, T b) {return std::min(a, b);}",
      "};",
      "template <typename T>",
      "struct max_fn_object {",
      "  auto operator()(T a, T b) {return std::max(a, b);}",
      "};",
      "using min_tropical = tropical<int, min_fn_object<int>>;",
      "using max_tropical = tropical<int, max_fn_object<int>>;"
    ],
    "prefix": "tropical"
  },
  "../include/polynominals/convolution.hpp": {
    "body": [
      "template<typename T>",
      "class convolution {",
      "  const T id;",
      "  const std::function<void(T&, T)> add;",
      "  const std::function<T(T, T)> mul;",
      "  public:",
      "    convolution (",
      "        T id,",
      "        std::function<void(T&, T)> add,",
      "        std::function<T(T, T)> mul",
      "      ) :",
      "      id(id),",
      "      add(add),",
      "      mul(mul)",
      "      {",
      "      }",
      "    auto operator () (",
      "        std::vector<T> a,",
      "        std::vector<T> b",
      "      ) -> std::vector<T>",
      "      {",
      "        int l = a.size();",
      "        int m = b.size();",
      "        int n = l + m - 1;",
      "        assert(l && m);",
      "        std::vector<T> c(n, id);",
      "        for (int i = 0; i < l; i++) {",
      "          for (int j = 0; j < m; j++) {",
      "            add(c[i + j], mul(a[i], b[j]));",
      "          }",
      "        }",
      "        return c;",
      "      }",
      "};",
      "convolution<${1:long long}> cnv(",
      "    ${2:id},",
      "    ${3:add},",
      "    ${4:mul}",
      "  );",
      "  "
    ],
    "prefix": "convolution"
  },
  "../include/polynominals/polynominal.hpp": {
    "body": [
      "template <typename T,",
      "  typename T::value_type zero, // TODO: not value_type, but T",
      "  typename T::value_type one,  // TODO: not value_type, but T",
      "  std::enable_if_t<",
      "    is_tropical_v<T>,",
      "  std::nullptr_t> = nullptr>",
      "class polynominal {",
      "  public:",
      "    using value_type     = T;",
      "    using container_type = std::vector<value_type>;",
      "",
      "  private:",
      "    container_type value;",
      "  ",
      "  public:",
      "    constexpr polynominal()=default;",
      "    constexpr polynominal(const polynominal&)=default;",
      "    constexpr polynominal(polynominal&&)=default;",
      "    polynominal& operator=(const polynominal&)=default;",
      "    polynominal& operator=(polynominal&&)=default;",
      "",
      "    template <typename... Args>",
      "    polynominal(Args... args) : value(std::forward<Args>(args)...) {}",
      "",
      "    auto operator()(){return value;}",
      "",
      "",
      "};",
      "",
      "template <typename T> struct is_polynominal : std::false_type{};",
      "template <typename T, T zero, T one> struct is_polynominal <polynominal<T, zero, one>> : std::true_type{};",
      "template <typename T> constexpr bool is_polynominal_v = is_polynominal<T>::value;"
    ],
    "prefix": "polynominal"
  },
  "../include/range_queries/binary_indexed_tree.hpp": {
    "body": [
      "template <typename T, typename Add, typename Sub>",
      "class binary_indexed_tree",
      "{",
      "public:",
      "  using size_type         = int;",
      "  using value_type        = T;",
      "  using add_function_type = Add;",
      "  using sub_function_type = Sub;",
      "  using container_type    = std::vector<T>;",
      "",
      "private:",
      "  size_type         n;",
      "  add_function_type add_function;",
      "  sub_function_type sub_function;",
      "  value_type        id;",
      "  container_type    table;",
      "",
      "public:",
      "  binary_indexed_tree",
      "  (",
      "    size_type         size,",
      "    add_function_type add_function,",
      "    sub_function_type sub_function,",
      "    value_type        id,",
      "    container_type    v",
      "  ) :",
      "  n            (std::pow(2, int(std::log2(size)) + 1)),",
      "  add_function (std::move(add_function)),",
      "  sub_function (std::move(sub_function)),",
      "  id           (id),",
      "  table        (n, id)",
      "  {}",
      "",
      "  binary_indexed_tree(",
      "    size_type         size,",
      "    add_function_type add_function,",
      "    sub_function_type sub_function,",
      "    value_type        id",
      "  ) :",
      "    binary_indexed_tree(",
      "      size,",
      "      std::move(add_function),",
      "      std::move(sub_function),",
      "      id,",
      "      container_type(size, id)",
      "    )",
      "  {}",
      "",
      "  auto operator[] (size_type i) const -> value_type",
      "  {",
      "    assert(0 <= i && i < n);",
      "    return query(i, i + 1);",
      "  }",
      "",
      "  auto at (size_type i) const -> value_type",
      "  {",
      "    return operator[](i);",
      "  }",
      "",
      "  // Returns the sum over [0, k[.",
      "  auto cumulative_sum(size_type k) const -> value_type",
      "  {",
      "    static_assert(std::is_same<size_type, int>::value);",
      "    assert(0 <= k && k <= n);",
      "    value_type ret = id;",
      "    for (k--; k >= 0; k &= k + 1, k--) {",
      "      ret = add_function(ret, table.at(k));",
      "    };",
      "    return ret;",
      "  }",
      "",
      "  // Return the sum over [l, r[.",
      "  auto query (size_type l, size_type r) const -> value_type",
      "  {",
      "    assert(0 <= l && l <= r && r <= n);",
      "    return sub_function(cumulative_sum(r), cumulative_sum(l));",
      "  }",
      "",
      "",
      "  void add (size_type i, value_type x)",
      "  {",
      "    assert(0 <= i && i < n);",
      "    for (; i < n; i |= i + 1) {",
      "      table.at(i) = add_function(table.at(i), x);",
      "    }",
      "  }",
      "",
      "  void update (size_type i, value_type x)",
      "  {",
      "    add(i, sub_function(x, at(i)));",
      "  }",
      "};",
      "",
      "template<typename T, typename Add, typename Sub>",
      "auto make_binary_indexed_tree(",
      "  int size,",
      "  Add add_function,",
      "  Sub sub_function,",
      "  T   id",
      ")",
      "{",
      "  return binary_indexed_tree<T, Add, Sub>",
      "  (",
      "    size,",
      "    std::move(add_function),",
      "    std::move(sub_function),",
      "    id",
      "  );",
      "}",
      "",
      "template<typename T, typename Add, typename Sub>",
      "auto make_binary_indexed_tree",
      "(",
      "  int            size,",
      "  Add            add_function,",
      "  Sub            sub_function,",
      "  T              id,",
      "  std::vector<T> v",
      ")",
      "{",
      "  return binary_indexed_tree<T, Add, Sub>",
      "  (",
      "    size,",
      "    std::move(add_function),",
      "    std::move(sub_function),",
      "    id,",
      "    std::move(v)",
      "  );",
      "}"
    ],
    "prefix": "binary_indexed_tree"
  },
  "../include/range_queries/compressed_segment_tree.hpp": {
    "body": [
      "template<typename T, typename U>",
      "class compressed_segment_tree {",
      "  const std::vector<T> a;",
      "  const size_t sz, Sz;",
      "  std::vector<U> seg;",
      "  const std::function<U(U, U)> o;",
      "  const U id;",
      "  auto find (T k) const {",
      "    auto it = std::lower_bound(a.begin(), a.end(), k);",
      "    assert(it != a.end() && *it == k);",
      "    return it - a.begin() + sz;",
      "  }",
      "  public:",
      "    compressed_segment_tree (",
      "        const std::vector<T> a,",
      "        const std::function<U(U, U)> o,",
      "        const U id",
      "      ) :",
      "      a(a),",
      "      sz([&](){",
      "          size_t ret = 1;",
      "          for (; ret < a.size(); ret <<= 1) {}",
      "          return ret;",
      "        }()),",
      "      Sz(sz << 1),",
      "      seg(Sz, id),",
      "      o(o),",
      "      id(id)",
      "      {",
      "      }",
      "    void update (T x, const U& y) {",
      "      auto k = find(x);",
      "      seg[k] = y;",
      "      while(k >>= 1) {",
      "        seg[k] = o(seg[2 * k], seg[2 * k + 1]);",
      "      }",
      "    }",
      "    void add (T x, const U& y) {",
      "      update(x, at(x) + y);",
      "    }",
      "    U query (T l, T r) {",
      "      l = std::lower_bound(a.begin(), a.end(), l) - a.begin();",
      "      r = std::lower_bound(a.begin(), a.end(), r) - a.begin();",
      "      U L = id, R = id;",
      "      for(l += sz, r += sz; l < r; l >>= 1, r >>= 1) {",
      "        if(l & 1) L = o(L, seg[l++]);",
      "        if(r & 1) R = o(seg[--r], R);",
      "      }",
      "      return o(L, R);",
      "    }",
      "    U at (T x) const {",
      "      return seg[find(x)];",
      "    }",
      "    void print () const {",
      "      int n = a.size();",
      "      std::cout << std::setw(4) << \"----\"; for (int i = 0; i < n; i++) std::cout << std::setw(4) << \"----\" ; std::cout << std::endl;",
      "      std::cout << std::setw(4) << \"\"; for (auto const& e : a) std::cout << std::setw(4) << e; std::cout << std::endl;",
      "      std::cout << std::setw(4) << \"----\"; for (int i = 0; i < n; i++) std::cout << std::setw(4) << \"----\" ; std::cout << std::endl;",
      "      std::cout << std::setw(4) << \"val\"; for (auto const& e : a) std::cout << std::setw(4) << at(e); std::cout << std::endl;",
      "      std::cout << std::setw(4) << \"----\"; for (int i = 0; i < n; i++) std::cout << std::setw(4) << \"----\" ; std::cout << std::endl;",
      "    }",
      "};"
    ],
    "prefix": "compressed_segment_tree"
  },
  "../include/range_queries/disjoint_sparse_table.hpp": {
    "body": [
      "template <typename T>",
      "class disjoint_sparse_table {",
      "  const int n, ht;",
      "  const std::vector<int> msb;",
      "  const std::function<T(T, T)> o;",
      "  const std::vector<std::vector<T>> tab;",
      "  public:",
      "    disjoint_sparse_table (",
      "        const std::vector<T> a,",
      "        const std::function<T(T, T)> o",
      "      ) :",
      "      n(a.size()),",
      "      ht([&](){",
      "          int ret = 1;",
      "          for (int b = 2; b < n; b <<= 1) ret++;",
      "          return ret;",
      "        }()),",
      "      msb([&](){",
      "          int N = 1 << ht;",
      "          auto ret = std::vector<int>(N, 0); ret[0] = -1;",
      "          for (int i = 2; i < N; i++) ret[i] = ret[i >> 1] + 1;",
      "          return ret;",
      "        }()),",
      "      o(o),",
      "      tab([&](){",
      "          auto ret = std::vector<std::vector<T>>(ht, a);",
      "          for (int i = 1; i < ht; i++) {",
      "            int p = 1 << i; int P = p << 1;",
      "            for (int s = 0; s < n; s += P) {",
      "              int t = min(s + p, n);",
      "              for (int j = t - 2; j >= s; j--) ret[i][j] = o(a[j], ret[i][j + 1]);",
      "              for (int j = t + 1; j < min(s + P, n); j++) ret[i][j] = o(ret[i][j - 1], a[j]);",
      "            }",
      "          }",
      "          return ret;",
      "        }())",
      "      {",
      "      }",
      "    auto query (",
      "        int l,",
      "        int r",
      "      ) -> T",
      "      {",
      "        assert(l <= --r);",
      "        int m = msb[l ^ r];",
      "        return m == -1 ? tab[0][l] : o(tab[m][l], tab[m][r]);",
      "      }",
      "};"
    ],
    "prefix": "disjoint_sparse_table"
  },
  "../include/range_queries/lazy_segment_tree.hpp": {
    "body": [
      "template<",
      "  typename Value1,    typename Value2,",
      "  typename BinaryOp1, typename BinaryOp2, typename BinaryOp3,",
      "  typename UnaryOp1,  typename UnaryOp2",
      "  >",
      "class lazy_segment_tree",
      "{",
      "    struct node",
      "    {",
      "      int id, l, r;",
      "      node (int id, int l, int r):",
      "        id(id), l(l), r(r)",
      "        {};",
      "",
      "      auto size () const {return r - l;}",
      "",
      "      auto left_child  () const",
      "      {",
      "        assert(size() > 1);",
      "        return node(id * 2, l, (l + r) / 2);",
      "      }",
      "",
      "      auto right_child () const",
      "      {",
      "        assert(size() > 1);",
      "        return node(id * 2 + 1, (l + r) / 2, r);",
      "      }",
      "    };",
      "",
      "    int                 n, N;",
      "    BinaryOp1           op1;",
      "    BinaryOp2           op2;",
      "    BinaryOp3           op3;",
      "    Value1              id1;",
      "    Value2              id2;",
      "    UnaryOp1            expand;",
      "    UnaryOp2            shrink;",
      "    std::vector<Value1> table;",
      "    std::vector<Value2> lazy;",
      "    node                initial_node;",
      "",
      "    auto& op1_eq (Value1& x, Value1 y) {return x = op1(x, y);}",
      "    auto& op2_eq (Value1& x, Value2 y) {return x = op2(x, y);}",
      "    auto& op3_eq (Value2& x, Value2 y) {return x = op3(x, y);}",
      "",
      "    void cal (int u)",
      "    {",
      "      table.at(u) = op1(table.at(2 * u), table.at(2 * u + 1));",
      "    }",
      "",
      "    auto chain (int u) const",
      "    {",
      "      auto ret = std::vector<int>{};",
      "      for (auto i = u; i > 0; i /= 2)",
      "      {",
      "        ret.emplace_back(i);",
      "      }",
      "      std::reverse(ret.begin(), ret.end());",
      "      return ret;",
      "    }",
      "",
      "    auto prop (int u)",
      "    {",
      "      op2_eq(table.at(u), lazy.at(u));",
      "      if (u < n)",
      "      {",
      "        op3_eq(lazy.at(2 * u),     shrink(lazy.at(u)));",
      "        op3_eq(lazy.at(2 * u + 1), shrink(lazy.at(u)));",
      "      }",
      "      lazy.at(u)     = id2;",
      "      return table.at(u);",
      "    }",
      "",
      "    auto query_base (int l, int r, Value2 val, const node& now)",
      "    {",
      "      prop(now.id);",
      "      if (now.r <= l || r <= now.l) return id1;",
      "      else if (l <= now.l && now.r <= r)",
      "      {",
      "        op3_eq(lazy.at(now.id), val);",
      "        return prop(now.id);",
      "      }",
      "      else",
      "      {",
      "        auto ret =op1(",
      "          query_base(l, r, shrink(val), now.left_child()),",
      "          query_base(l, r, shrink(val), now.right_child())",
      "        );",
      "        cal(now.id);",
      "        return ret;",
      "      }",
      "    }",
      "",
      "  public:",
      "    lazy_segment_tree",
      "    (",
      "      int size,",
      "      BinaryOp1  op1,",
      "      BinaryOp2  op2,",
      "      BinaryOp3  op3,",
      "      Value1     id1,",
      "      Value2     id2,",
      "      UnaryOp1   expand,",
      "      UnaryOp2   shrink",
      "    ):",
      "      n (std::pow(2, int(std::log2(size)) + 1)), N(n * 2),",
      "      op1(std::move(op1)), op2(std::move(op2)), op3(std::move(op3)),",
      "      id1(id1), id2(id2),",
      "      expand(std::move(expand)), shrink(std::move(shrink)),",
      "      table(N, id1), lazy(N, id2),",
      "      initial_node(1, 0, n)",
      "      {",
      "        std::mt19937 mt(std::random_device{}());",
      "        std::uniform_int_distribution<int> dist(-1'000'000, 1'000'000);",
      "        for (int i = 0; i < 20; i++) {",
      "          Value1 ex1 = dist(mt), ex1_ = dist(mt);",
      "          Value2 ex2 = dist(mt);",
      "          assert(op1(ex1, id1)       == ex1);",
      "          assert(op2(ex1, id2)       == ex1);",
      "          assert(op3(ex2, id2)       == ex2);",
      "          assert(shrink(expand(ex2)) == ex2);",
      "          assert(op2(op1(ex1, ex1_), expand(ex2)) == op1(op2(ex1, ex2), op2(ex1_, ex2)));",
      "        }",
      "      }",
      "",
      "    void build (const Value1 x)",
      "    {",
      "      std::fill(table.begin(), table.end(), x);",
      "    }",
      "",
      "    void build (const std::vector<Value1>& v)",
      "    {",
      "      assert(int(v.size()) <= n);",
      "      std::move(v.begin(), v.end(), table.begin() + n);",
      "      for (int i = n - 1; i >= 0; i--) cal(i);",
      "    }",
      "",
      "    void act (int l, int r, Value2 val)",
      "    {",
      "      for (int i = 1; i < n; i *= 2) {",
      "        val = expand(val);",
      "      }",
      "      query_base(l, r, val, initial_node);",
      "    }",
      "",
      "    auto query (int l, int r)",
      "    {",
      "      return query_base(l, r, id2, initial_node);",
      "    }",
      "",
      "    auto quiet_at (int i) const",
      "    {",
      "      i += n;",
      "      auto actor = id2;",
      "      for (auto j : chain(i))",
      "      {",
      "        actor = shrink(actor);",
      "        actor = op3(actor, lazy.at(j));",
      "      }",
      "      return op2(table.at(i), actor);",
      "    }",
      "",
      "    auto quiet_collect () const",
      "    {",
      "      auto ret = std::vector<Value1>(n);",
      "      for (auto i = 0; i < n; i++)",
      "      {",
      "        ret.at(i) = quiet_at(i);",
      "      }",
      "      return ret;",
      "    }",
      "",
      "    auto& at (int i)",
      "    {",
      "      i += n;",
      "      for (auto j : chain(i))",
      "      {",
      "        prop(j);",
      "      }",
      "      return table.at(i);",
      "    }",
      "",
      "    auto& collect ()",
      "    {",
      "      for (int i = 0; i < N; i++)",
      "      {",
      "        prop(i);",
      "      }",
      "      auto ret = std::vector<Value1>(n);",
      "      for (auto i = 0; i < n; i++)",
      "      {",
      "        ret.at(i) = table.at(i + n);",
      "      }",
      "      return ret;",
      "    }",
      "};",
      "",
      "template<",
      "  typename Value1,    typename Value2,",
      "  typename BinaryOp1, typename BinaryOp2, typename BinaryOp3,",
      "  typename UnaryOp1,  typename UnaryOp2",
      "  >",
      "auto make_lazy_segment_tree",
      "(",
      "  int        size,",
      "  BinaryOp1  op1,",
      "  BinaryOp2  op2,",
      "  BinaryOp3  op3,",
      "  Value1     id1,",
      "  Value2     id2,",
      "  UnaryOp1   expand,",
      "  UnaryOp2   shrink",
      ")",
      "{",
      "  return lazy_segment_tree<",
      "    Value1,    Value2,",
      "    BinaryOp1, BinaryOp2, BinaryOp3,",
      "    UnaryOp1,  UnaryOp2",
      "    >",
      "    (",
      "      size, std::move(op1), std::move(op2), std::move(op3),",
      "      id1, id2, std::move(expand), std::move(shrink)",
      "    );",
      "}",
      "",
      "",
      "template<",
      "  typename Value1,    typename Value2,",
      "  typename BinaryOp1, typename BinaryOp2, typename BinaryOp3",
      "  >",
      "auto make_lazy_segment_tree",
      "(",
      "  int        size,",
      "  BinaryOp1  op1,",
      "  BinaryOp2  op2,",
      "  BinaryOp3  op3,",
      "  Value1     id1,",
      "  Value2     id2",
      ")",
      "{",
      "  auto f = [](auto x){return x;};",
      "  return make_lazy_segment_tree",
      "    (",
      "      size, std::move(op1), std::move(op2), std::move(op3),",
      "      id1, id2, std::move(f), std::move(f)",
      "    );",
      "}"
    ],
    "prefix": "lazy_segment_tree"
  },
  "../include/range_queries/segment_tree.hpp": {
    "body": [
      "template<typename Value, typename BinaryOp>",
      "class segment_tree",
      "{",
      "    int                 n, N;",
      "    BinaryOp            op;",
      "    Value               id;",
      "    std::vector<Value>  table;",
      "",
      "    void cal (int u)",
      "    {",
      "      table.at(u) = op(table.at(2 * u), table.at(2 * u + 1));",
      "    }",
      "",
      "  public:",
      "    segment_tree(int size, BinaryOp op, Value id, const std::vector<Value>& v):",
      "      n     (std::pow(2, int(std::log2(2 * size - 1)))),",
      "      N     (n * 2),",
      "      op    (op),",
      "      id    (id),",
      "      table (N, id)",
      "    {",
      "      assert(n > 0);",
      "      std::move(v.begin(), v.end(), table.begin() + n);",
      "      for (int i = n - 1; i != 0; i--) cal(i);",
      "    }",
      "",
      "    segment_tree(int size, BinaryOp op, Value id):",
      "      segment_tree(size, std::move(op), id, std::vector<Value>(size, id))",
      "      {}",
      "",
      "    auto at (int i) const -> Value",
      "    {",
      "      return table.at(n + i);",
      "    }",
      "",
      "    auto collect () const -> std::vector<Value>",
      "    {",
      "      auto ret = std::vector<Value>(n);",
      "      for (auto i = 0; i < n; i++)",
      "      {",
      "        ret.at(i) = at(i);",
      "      }",
      "      return ret;",
      "    }",
      "",
      "    auto query (int l, int r) const -> Value",
      "    {",
      "      struct state {int top, left, right;};",
      "",
      "      auto ret = id;",
      "      std::stack<state> stk; stk.push({1, 0, n});",
      "      while (!stk.empty())",
      "      {",
      "        auto now = stk.top(); stk.pop();",
      "        if (l <= now.left && now.right <= r)",
      "        {",
      "          ret = op(ret, table.at(now.top));",
      "          continue;",
      "        }",
      "        int mid = (now.left + now.right) / 2;",
      "        if (l < mid) stk.push({2 * now.top,     now.left,  mid});",
      "        if (mid < r) stk.push({2 * now.top + 1, mid, now.right});",
      "      }",
      "      return ret;",
      "    }",
      "",
      "    void update (int u, Value val)",
      "    {",
      "      table.at(u += n) = val;",
      "      for (u /= 2; u != 0; u /= 2) cal(u);",
      "    }",
      "",
      "    void add (int u, Value val)",
      "    {",
      "      update(u, at(u) + val);",
      "    }",
      "};",
      "",
      "template<typename Value, typename BinaryOp>",
      "auto make_segment_tree(int size, BinaryOp op, Value vid)",
      "{",
      "  return segment_tree<Value, BinaryOp>(size, std::move(op), vid);",
      "}",
      "",
      "template<typename Value, typename BinaryOp>",
      "auto make_segment_tree(int size, BinaryOp op, Value vid, std::vector<int> v)",
      "{",
      "  return segment_tree<Value, BinaryOp>(size, std::move(op), vid, std::move(v));",
      "}"
    ],
    "prefix": "segment_tree"
  },
  "../include/range_queries/sliding_minimum.hpp": {
    "body": [
      "template <typename T, typename Compare = std::less<T>>",
      "class sliding_minimum {",
      "public:",
      "  using size_type     = int;",
      "  using position_type = int;",
      "  using value_type    = T;",
      "  using sequence_type = std::vector<T>;",
      "  using deque_type    = std::deque<T>;",
      "  using compare_type  = Compare;",
      "",
      "private:",
      "  deque_type que;",
      "",
      "public:",
      "  size_type     n;",
      "  sequence_type v;",
      "  compare_type  cmp;",
      "  position_type left, right;",
      "",
      "  sliding_minimum",
      "  (",
      "    sequence_type const& v",
      "  ) :",
      "  n    (v.size()),",
      "  v    (v),",
      "  cmp  (Compare()),",
      "  left (0),",
      "  right(0)",
      "  {}",
      "",
      "  auto get_left_index() const -> position_type",
      "  {",
      "    return left;",
      "  }",
      "",
      "  auto get_right_index() const -> position_type",
      "  {",
      "    return right;",
      "  }",
      "",
      "  auto query_index() const -> position_type",
      "  {",
      "    assert(!que.empty());",
      "    return que.front();",
      "  }",
      "",
      "  auto query() const -> value_type",
      "  {",
      "    return v.at(query_index());",
      "  }",
      "",
      "  void pop_left()",
      "  {",
      "    if (que.front() == left++) {",
      "      que.pop_front();",
      "    }",
      "    assert(left <= right);",
      "  }",
      "",
      "  void push_right()",
      "  {",
      "    while (!que.empty() && !cmp(v.at(que.back()), v.at(right))) {",
      "      que.pop_back();",
      "    }",
      "    que.push_back(right++);",
      "    assert(right <= n);",
      "  }",
      "",
      "  void slide()",
      "  {",
      "    pop_left();",
      "    push_right();",
      "  }",
      "",
      "  void pop_left_until(int target)",
      "  {",
      "    assert(target <= right);",
      "    while (left < target) pop_left();",
      "  }",
      "",
      "  void push_right_until(int target)",
      "  {",
      "    assert(target <= n);",
      "    while (right < target) push_right();",
      "  }",
      "",
      "  void advance_until(int l, int r)",
      "  {",
      "    push_right_until(r);",
      "    pop_left_until(l);",
      "  }",
      "};"
    ],
    "prefix": "sliding_minimum"
  },
  "../include/range_queries/sparse_table.hpp": {
    "body": [
      "template <typename T>",
      "class sparse_table {",
      "  const int n, ht;",
      "  const std::vector<int> msb;",
      "  const std::function<T(T, T)> o;",
      "  const std::vector<std::vector<T>> tab;",
      "  public:",
      "    sparse_table (",
      "        std::vector<T> a,",
      "        std::function<T(T, T)> o",
      "      ) :",
      "      n(a.size()),",
      "      ht([&](){",
      "          int ret = 1;",
      "          for (int b = 2; b < n; b <<= 1) ret++;",
      "          return ret;",
      "        }()),",
      "      msb([&](){",
      "          int N = 1 << ht;",
      "          auto ret = std::vector<int>(N, 0); ret[0] = -1;",
      "          for (int i = 2; i < N; i++) ret[i] = ret[i >> 1] + 1;",
      "          return ret;",
      "        }()),",
      "      o(o),",
      "      tab([&](){",
      "          auto ret = std::vector<std::vector<T>>(ht, a);",
      "          for (int i = 1, p = 1; i < ht; i++, p <<= 1) {",
      "            for (int j = 0; j < n; j++) {",
      "              ret[i][j] = o(ret[i - 1][j], ret[i - 1][min(j + p, n - 1)]);",
      "            }",
      "          }",
      "          return ret;",
      "        }())",
      "      {",
      "      }",
      "    auto query (",
      "        int l,",
      "        int r",
      "      ) -> T",
      "      {",
      "        assert(0 <= l && l < r && r <= n);",
      "        int i = msb[r - l];",
      "        return o(tab[i][l], tab[i][r - (1 << i)]);",
      "      }",
      "};"
    ],
    "prefix": "sparse_table"
  },
  "../include/string_algorighms/fully_indexable_dictionary.hpp": {
    "body": [
      "class fully_indexable_dictionary {",
      "    using value_t = uint32_t;",
      "    using count_t = unsigned;",
      "    static constexpr size_t sz = 8 * sizeof(uint32_t);",
      "    bool built;",
      "    size_t full_length, n;",
      "    std::vector<value_t> row_data;",
      "    std::vector<count_t> rank_table;",
      "",
      "  public:",
      "    fully_indexable_dictionary(size_t full_length) :",
      "      built(false),",
      "      full_length(full_length),",
      "      n((full_length + sz - 1) / sz),",
      "      row_data(n), rank_table(n) {",
      "        debug(sz, n);",
      "      }",
      "",
      "    // Set the i-th bit.",
      "    void set(size_t i) {",
      "      assert(!built);",
      "      row_data.at(i / sz) |= (1u << i);",
      "    }",
      "",
      "    // Initialize the rank-table.",
      "    void build() {",
      "      assert(!built);",
      "      rank_table = [&]{",
      "        std::vector<count_t> pop_counts(n), rank_table(n);",
      "        std::transform(row_data.begin(), row_data.end(), pop_counts.begin(),",
      "          [](auto x){return __builtin_popcountl(x);});",
      "        std::partial_sum(pop_counts.begin(), pop_counts.end(), rank_table.begin());",
      "        rank_table.insert(rank_table.begin(), 0u);",
      "        return rank_table; ",
      "      }();",
      "      built = true;",
      "      debug(row_data, rank_table);",
      "    }",
      "",
      "    // Access the i-th bit.",
      "    auto access(size_t i) const -> bool {",
      "      return row_data.at(i / sz) >> (i % sz) & 1u;",
      "    }",
      "    // An alias of access",
      "    auto at(size_t i) const -> bool {return access(i);}",
      "    ",
      "    // Count the 1.",
      "    auto rank(size_t i) const -> count_t {",
      "      return rank_table.at(i / sz)",
      "        + __builtin_popcountl(row_data.at(i / sz) & ((1 << (i % sz)) - 1));",
      "    }",
      "",
      "    // Find the k-th 1. (That is the maximal i such that rank(i) <= k.)",
      "    // When not found, returns the full-size of the sequence.",
      "    auto select(size_t k) const -> size_t {",
      "      size_t left = 0, right = full_length + 1, mid;",
      "      while (right - left > 1) {",
      "        mid = (left + right) / 2;",
      "        (rank(mid) <= k ? left : right) = mid;",
      "      }",
      "      return left;",
      "    }",
      "};"
    ],
    "prefix": "fully_indexable_dictionary"
  },
  "../include/string_algorighms/kmp_algorithm.hpp": {
    "body": [
      "auto make_failure_table (std::string w) -> std::vector<int>",
      "{",
      "  int n = w.length();",
      "  std::vector<int> ret(n + 1, -1);",
      "  int len = 0, pos = 1;",
      "  while (pos < n) {",
      "    if (w.at(pos) == w.at(len)) {",
      "      ret.at(pos) = ret.at(len);",
      "    } else {",
      "      ret.at(pos) = len;",
      "      len = ret.at(len);",
      "      while (len >= 0 && w.at(len) != w.at(pos)) len = ret.at(len);",
      "    }",
      "    len++, pos++;",
      "  }",
      "  ret.at(pos) = len;",
      "  return ret;",
      "}",
      "",
      "class kmp_algorithm",
      "{",
      "    std::string w;",
      "    std::vector<int> failure_table;",
      "",
      "  public:",
      "    kmp_algorithm()=default;",
      "",
      "    kmp_algorithm(const std::string& w) :",
      "      w(w),",
      "      failure_table(std::move(make_failure_table(this->w)))",
      "      {}",
      "",
      "    // Returns the starting positions of all the matches.",
      "    auto search(std::string s) -> std::vector<int>",
      "    {",
      "      std::vector<int> ret;",
      "      int pos_w = 0, pos_s = 0;",
      "      while (pos_s < (int)s.length()) {",
      "        if (s.at(pos_s) == w.at(pos_w)) {",
      "          pos_s++, pos_w++;",
      "          if (pos_w == (int)w.length()) {",
      "            ret.push_back(pos_s - pos_w);",
      "            pos_w = failure_table.at(pos_w);",
      "          }",
      "        } else {",
      "          pos_w = failure_table.at(pos_w);",
      "          if (pos_w < 0) {",
      "            pos_s++, pos_w++;",
      "          }",
      "        }",
      "      }",
      "      return ret;",
      "    }",
      "};"
    ],
    "prefix": "kmp_algorithm"
  },
  "../include/string_algorighms/rolling_hash.hpp": {
    "body": [
      "class rolling_hash {",
      "  public:",
      "    using value_type     = long long;",
      "    using container_type = std::vector<value_type>;",
      "",
      "  private:",
      "    static constexpr size_t  mod_num = 2;",
      "    static constexpr std::array<value_type, mod_num> mods = {",
      "        1'000'000'007,",
      "        1'000'000'009",
      "      };",
      "    static constexpr value_type base    = 9973;",
      "",
      "    size_t                       n;",
      "    std::vector<container_type>  hash_table;",
      "    std::vector<container_type>  pow_table;",
      "",
      "    auto inverse(value_type a, value_type m) const -> value_type {",
      "      value_type u = 0, v = 1;",
      "      while (a != 0) {",
      "        value_type t = m / a;",
      "        m -= t * a; std::swap(a, m);",
      "        u -= t * v; std::swap(u, v);",
      "      }",
      "      assert(m == 1);",
      "      return u;",
      "    }",
      "",
      "  public:",
      "    // ctor, dtor",
      "    explicit rolling_hash() = default;",
      "    explicit rolling_hash(const rolling_hash&) = default;",
      "    explicit rolling_hash(rolling_hash&&) = default;",
      "    rolling_hash& operator=(const rolling_hash&) = default;",
      "    rolling_hash& operator=(rolling_hash&&) = default;",
      "    ~rolling_hash() = default;",
      "",
      "    rolling_hash(const std::string s) :",
      "      n(s.length()),",
      "      hash_table(mod_num, container_type(n + 1, 0)),",
      "      pow_table (mod_num, container_type(n + 1, 1))",
      "      {",
      "        for (size_t i = 0; i < mod_num; i++) {",
      "          auto  mod = mods.at(i);",
      "          auto& tab = hash_table.at(i);",
      "          auto& pab = pow_table.at(i);",
      "          for (size_t j = 0; j < n; j++) {",
      "            tab.at(j + 1) = (tab.at(j) * base + s.at(j)) % mod;",
      "            pab.at(j + 1) = (pab.at(j) * base) % mod;",
      "          }",
      "        }",
      "      }",
      "",
      "    // observers",
      "    auto hash(size_t l, size_t r) const {",
      "      auto ret = std::vector<value_type>{};",
      "      for (size_t i = 0; i < mod_num; i++) {",
      "        const auto  mod = mods.at(i);",
      "        const auto& tab = hash_table.at(i);",
      "        const auto& pab = pow_table.at(i);",
      "        auto &      buf = ret.at(i);",
      "        buf = (tab.at(r) - tab.at(l)) * inverse(pab.at(l), mod) % mod;",
      "      }",
      "      return ret;",
      "    }",
      "};"
    ],
    "prefix": "rolling_hash"
  },
  "../include/string_algorighms/run_length_encoding.hpp": {
    "body": [
      "template<typename T>",
      "class run_length_encoding {",
      "  std::vector<std::pair<int, T>> rle;",
      "  public:",
      "    run_length_encoding(",
      "        std::vector<T> input",
      "      ) :",
      "      rle(0)",
      "      {",
      "        int cnt = 0;",
      "        for (auto it = input.begin(); it != input.end(); it++) {",
      "          auto jt = next(it); cnt++;",
      "          if (jt == input.end() || *it != *jt) {",
      "            rle.emplace_back(cnt, *it);",
      "            cnt = 0;",
      "          }",
      "        }",
      "      }",
      "    auto const& code () const {return rle;}",
      "};"
    ],
    "prefix": "run_length_encoding"
  },
  "../include/string_algorighms/suffix_array.hpp": {
    "body": [
      "class suffix_array",
      "{",
      "  private:",
      "    int              n;",
      "    std::string      s;",
      "    std::vector<int> suf;",
      "    std::vector<int> suf_inverse;",
      "    std::vector<int> lcp;",
      "",
      "    template <typename T>",
      "    auto compress(const T& v)",
      "      -> std::vector<int>",
      "    {",
      "      int n = v.size();",
      "      auto ord = std::vector<int>(n);",
      "      std::iota(ord.begin(), ord.end(), 0);",
      "      std::sort(ord.begin(), ord.end(), [&](auto i, auto j)",
      "      {",
      "        return v.at(i) < v.at(j);",
      "      });",
      "      auto c = std::vector<int>(n);",
      "      int classes = 0;",
      "      for (auto it = ord.begin(); it != ord.end(); it++)",
      "      {",
      "        if (it != ord.begin() && v.at(*it) != v.at(*std::prev(it)))",
      "        {",
      "          classes++;",
      "        }",
      "        c.at(*it) = classes;",
      "      }",
      "      return c;",
      "    }",
      "",
      "  public:",
      "    suffix_array()=default;",
      "    suffix_array(const suffix_array&)=default;",
      "    suffix_array(suffix_array&&)=default;",
      "    suffix_array& operator=(const suffix_array&)=default;",
      "    suffix_array& operator=(suffix_array&&)=default;",
      "",
      "    suffix_array(const std::string& s) :",
      "      n(s.length()), s(s)",
      "      {",
      "        assert(s.back() == '$');",
      "      }",
      "",
      "    // Container Accessors.",
      "    auto get_suffix_array() const {assert((int)suf.size() == n); return suf;}",
      "",
      "    auto get_lcp_array()    const {assert((int)lcp.size() == n); return lcp;}",
      "",
      "    // Builders.",
      "    void build_suffix_array()",
      "    {",
      "      auto c = compress(s);",
      "      for (int k = 1; k < n; k *= 2)",
      "      {",
      "        std::vector<std::pair<int, int>> pairs(n);",
      "        for (int i = 0; i < n; i++)",
      "        {",
      "          pairs.at(i) = {c.at(i), c.at((i + k) % n)};",
      "        }",
      "        c = compress(pairs);",
      "      }",
      "      suf_inverse = std::move(c);",
      "      suf.resize(n);",
      "      for (int i = 0; i < n; i++)",
      "      {",
      "        suf.at(suf_inverse.at(i)) = i;",
      "      }",
      "    }",
      "",
      "    void build_lcp_array()",
      "    {",
      "      int now = 0;",
      "      lcp.resize(n, 0);",
      "      for (auto i : suf_inverse)",
      "      {",
      "        if (i == n - 1) continue;",
      "        auto pos = suf.at(i) + now;",
      "        auto qos = suf.at(i + 1) + now;",
      "        while (pos < n && qos < n && s.at(pos) == s.at(qos))",
      "        {",
      "          pos++, qos++, now++;",
      "        }",
      "        lcp.at(i) = now;",
      "        if (now > 0) now--;",
      "      }",
      "    }",
      "};"
    ],
    "prefix": "suffix_array"
  },
  "../include/string_algorighms/trie.hpp": {
    "body": [
      "template <int Num, typename ConvertFn>",
      "class trie",
      "{",
      "  struct node",
      "  {",
      "    int                   sz;",
      "    std::vector<int>      ids;",
      "    std::array <int, Num> nxt;",
      "",
      "    node():",
      "      sz  (0),",
      "      ids ()",
      "      {",
      "        std::fill(nxt.begin(), nxt.end(), -1);",
      "      }",
      "",
      "     auto& next(int i) {return nxt.at(i);}",
      "  };",
      "",
      "  std::vector<node> storage;",
      "  ConvertFn         f;",
      "",
      "  void insert_impl(const std::string& s, int id)",
      "  {",
      "    std::vector<int> seq(s.length());",
      "    std::transform(s.begin(), s.end(), seq.begin(), f);",
      "    auto pos = 0;",
      "    for (auto x : seq)",
      "    {",
      "      auto& now      = storage.at(pos);",
      "      auto& next_pos = now.next(x);",
      "      now.sz++;",
      "      if (next_pos == -1)",
      "      {",
      "        next_pos = storage.size();",
      "        storage.emplace_back();",
      "      }",
      "      pos = next_pos;",
      "    }",
      "    auto& now = storage.at(pos);",
      "    now.sz++;",
      "    now.ids.emplace_back(id);",
      "  }",
      "",
      "public:",
      "  trie()=default;",
      "  trie(const trie&)=default;",
      "  trie(trie&&)=default;",
      "  trie& operator=(const trie&)=default;",
      "  trie& operator=(trie&&)=default;",
      "",
      "  trie(const ConvertFn& f):",
      "    storage {node{}},",
      "    f       (f)",
      "    {}",
      "",
      "  // The id is automatically issued.",
      "  void insert(const std::string& s)",
      "  {",
      "    insert_impl(s, storage.front().sz);",
      "  }",
      "",
      "  // Return the ids.",
      "  auto find(const std::string& s) -> std::vector<int>",
      "  {",
      "    std::vector<int> seq(s.length());",
      "    std::transform(s.begin(), s.end(), seq.begin(), f);",
      "    auto vid = 0;",
      "    for (auto x : seq)",
      "    {",
      "      vid = storage.at(vid).next(x);",
      "      if (vid == -1) return{};",
      "    }",
      "    return storage.at(vid).ids;",
      "  }",
      "",
      "  // Return the pairs of length & id",
      "  auto find_prefixes(const std::string& s) -> std::vector<std::pair<int, int>>",
      "  {",
      "    int  n   = s.length();",
      "    auto ret = std::vector<std::pair<int, int>>{};",
      "    auto vid = 0;",
      "    for (int i = 0; i < n; i++)",
      "    {",
      "      vid = storage.at(vid).next(f(s.at(i)));",
      "      if (vid == -1) return ret;",
      "      for (auto id : storage.at(vid).ids)",
      "      {",
      "        ret.emplace_back(i + 1, id);",
      "      }",
      "    }",
      "    return ret;",
      "  }",
      "};",
      "",
      "template <int Num, typename ConvertFn>",
      "auto make_trie(const ConvertFn& f)",
      "{",
      "  return trie<Num, ConvertFn>(std::move(f));",
      "}"
    ],
    "prefix": "trie"
  },
  "../include/string_algorighms/z_algorithm.hpp": {
    "body": [
      "auto make_z_array(std::string s) -> std::vector<int>",
      "{",
      "  if (s.empty()) return {};",
      "  int n = s.length();",
      "  std::vector<int> ret(n);",
      "  ret.at(0) = n;",
      "  int i = 1, j = 0;",
      "  while (i < n) {",
      "    while (i + j < n && s.at(j) == s.at(i + j)) {",
      "      j++;",
      "    }",
      "    ret.at(i) = j;",
      "    if (j == 0) {",
      "      i++;",
      "    }",
      "    else {",
      "      int k = 1;",
      "      while (i + k < n && k + ret.at(k) < j) {",
      "        ret.at(i + k) = ret.at(k);",
      "        k++;",
      "      }",
      "      i += k, j -= k;",
      "    }",
      "  }",
      "  return ret;",
      "}",
      "",
      "// Returns turns all the occurence of w in s.",
      "auto z_search(std::string w, std::string s, char dammy = '$') -> std::vector<int> {",
      "  if (s.empty()) return {};",
      "  assert(!w.empty());",
      "  int m = w.length(), n = s.length();",
      "  assert(std::find(w.begin(), w.end(), dammy) == w.end());",
      "  assert(std::find(s.begin(), s.end(), dammy) == s.end());",
      "  auto long_string = w + '$' + s;",
      "  auto z_array = make_z_array(std::move(long_string));",
      "  std::vector<int> ret;",
      "  for (int i = 0; i < n; i++) {",
      "    if (z_array.at(m + 1 + i) == m) {",
      "      ret.push_back(i);",
      "    }",
      "  }",
      "  return ret;",
      "}"
    ],
    "prefix": "z_algorithm"
  },
  "../include/tree/heavy_light_decomposition.hpp": {
    "body": [
      "class heavy_light_decomposition",
      "{",
      "  public:",
      "    using size_type  = int;",
      "    using index_type = int;",
      "    using id_type    = int;",
      "    using graph_type = std::vector<std::vector<index_type>>;",
      "    using tablele_type = std::vector<int>;",
      "",
      "  private:",
      "    size_type  n;",
      "    graph_type graph;",
      "    tablele_type prt, sz, depth, vid, ord, head;",
      "",
      "    // Helper",
      "    void first_dfs(index_type x)",
      "    {",
      "      for (auto& y : graph.at(x))",
      "      {",
      "        if (y == prt.at(x)) continue;",
      "        prt.at(y)   = x;",
      "        depth.at(y) = depth.at(x) + 1;",
      "",
      "        first_dfs(y);",
      "",
      "        sz.at(x) += sz.at(y);",
      "        auto& h = graph.at(x).front();",
      "        if (sz.at(h) < sz.at(y))",
      "        {",
      "          std::swap(h, y);",
      "        }",
      "      }",
      "    }",
      "",
      "    // Helper",
      "    void second_dfs(index_type x, id_type& counter)",
      "    {",
      "      ord.at(vid.at(x) = counter++) = x;",
      "      for (auto y : graph.at(x))",
      "      {",
      "        if (y == prt.at(x)) continue;",
      "        head.at(y) = y == graph.at(x).front()",
      "          ? head.at(x)",
      "          : y;",
      "         second_dfs(y, counter);",
      "      }",
      "    }",
      "",
      "  public:",
      "    heavy_light_decomposition()=default;",
      "    heavy_light_decomposition(const heavy_light_decomposition&)=default;",
      "    heavy_light_decomposition(heavy_light_decomposition&&)=default;",
      "    heavy_light_decomposition& operator=(const heavy_light_decomposition&)=default;",
      "    heavy_light_decomposition& operator=(heavy_light_decomposition&&)=default;",
      "",
      "    heavy_light_decomposition(int n) :",
      "      n     (n),",
      "      graph (n),",
      "      prt   (n),",
      "      sz    (n, 1),",
      "      depth (n, 0),",
      "      vid   (n),",
      "      ord   (n),",
      "      head  (n)",
      "      {}",
      "",
      "    // Accessers.",
      "    auto id(index_type x) const {return vid.at(x);}",
      "",
      "    void build (index_type root = 0)",
      "    {",
      "      id_type counter = 0;",
      "      first_dfs(root);",
      "      second_dfs(root, counter);",
      "    }",
      "",
      "    void insert (index_type x, index_type y)",
      "    {",
      "      graph.at(x).push_back(y);",
      "      graph.at(y).push_back(x);",
      "    }",
      "",
      "    template <typename RangeOp>",
      "    void for_each",
      "    (",
      "      index_type     x,",
      "      index_type     y,",
      "      RangeOp const& op,   // range-operation f([vid(x), vid(y)[)",
      "      bool           skip  // skip the top vertex",
      "    )",
      "    {",
      "      while (true)",
      "      {",
      "        if (id(x) > id(y)) std::swap(x, y);",
      "        if (head.at(x) == head.at(y))",
      "        {",
      "          op(id(x) + skip, id(y) + 1);",
      "          break;",
      "        }",
      "        op(id(head.at(y)), id(y) + 1);",
      "        y = prt.at(head.at(y));",
      "      }",
      "    }",
      "};"
    ],
    "prefix": "heavy_light_decomposition"
  },
  "../include/tree/lowest_common_ancestor.hpp": {
    "body": [
      "// Class for calculating LCA.",
      "// Dependent libraries: Combinator.",
      "template <typename T>",
      "class lowest_common_ancestor {",
      "    struct edge {",
      "        size_t to; T cost;",
      "        edge(size_t to, T cost) : to(to), cost(cost){}",
      "      };",
      "    size_t n, lg;",
      "    std::vector<std::vector<edge>>   graph;",
      "    std::vector<unsigned>            depth;",
      "    std::vector<T>                   weighted_depth;",
      "    std::vector<std::vector<size_t>> prt;",
      "  public:",
      "    using cost_type = T;",
      "    lowest_common_ancestor(size_t n) :",
      "      n(n), lg(std::log2(n)),",
      "      graph(n), depth(n, 0), weighted_depth(n, 0),",
      "      prt(lg + 1, std::vector<size_t>(n)) {}",
      "    // Insert an edge.",
      "    void insert (size_t u, size_t v, T cost = 1) {",
      "        graph.at(u).emplace_back(v, cost);",
      "        graph.at(v).emplace_back(u, cost);",
      "      }",
      "    // Build a doubling table.",
      "    void build (size_t root = 0) {",
      "        fix ([&](auto dfs, size_t crr, size_t p) -> void {",
      "          prt.at(0).at(crr) = p;",
      "          for (auto const& e : graph.at(crr)) {",
      "            if (e.to == p) continue;",
      "            depth.at(e.to) = depth.at(crr) + 1;",
      "            weighted_depth.at(e.to) = weighted_depth.at(crr) + e.cost;",
      "            dfs(e.to, crr);",
      "          }",
      "        })(root, root);",
      "        for (size_t p = 1; p <= lg; p++) {",
      "          for (size_t i = 0; i < n; i++) {",
      "            prt.at(p).at(i) = prt.at(p - 1).at(prt.at(p - 1).at(i));",
      "          }",
      "        }",
      "      }",
      "    // Calculate the lca.",
      "    auto operator()(size_t u, size_t v) const -> size_t {",
      "        if (depth.at(u) < depth.at(v)) std::swap(u, v);",
      "        auto diff = depth.at(u) - depth.at(v);",
      "        if (diff > 0) {",
      "          for (size_t p = lg, q = std::pow(2, lg); p <= lg; p--, q /= 2) {",
      "            if (diff > q) u = prt.at(p).at(u), diff -= q;",
      "          }",
      "          u = prt.at(0).at(u), diff--;",
      "        }",
      "        assert(diff == 0), assert(depth.at(u) == depth.at(v));",
      "        if (u == v) return u;",
      "        for (size_t p = lg, q = std::pow(2, lg); p <= lg; p--, q /= 2) {",
      "          auto next_u = prt.at(p).at(u);",
      "          auto next_v = prt.at(p).at(v);",
      "          if (next_u != next_v) u = next_u, v = next_v;",
      "        }",
      "        assert(u != v);",
      "        u = prt.at(0).at(u), v = prt.at(0).at(v), assert(u == v);",
      "        return u;",
      "      }",
      "    // Calculate the count-based distance.",
      "    auto row_dist (size_t u, size_t v) const -> unsigned {",
      "      return depth.at(u) + depth.at(v) - 2 * depth.at(operator()(u, v));}",
      "    // Calculate the count-based distance.",
      "    auto weighted_dist (size_t u, size_t v) const -> T {",
      "      auto& x = weighted_depth;",
      "      return x.at(u) + x.at(v) - 2 * x.at(operator()(u, v));}",
      "};"
    ],
    "prefix": "lowest_common_ancestor"
  },
  "../include/utility/bit_at.hpp": {
    "body": [
      "// Access the j-th bit.",
      "auto bit_at (int x, int j) -> bool {return (x >> j) & 1;}"
    ],
    "prefix": "bit_at"
  },
  "../include/utility/guess.hpp": {
    "body": [
      "struct rational {int n, d;};",
      "auto to_string(rational r) -> std::string {",
      "  return (r.d == 1",
      "    ? std::to_string(r.n)",
      "    : std::to_string(r.n) + \"/\" + std::to_string(r.d));",
      "}",
      "std::ostream& operator << (std::ostream& os, rational r){",
      "  return os << to_string(r);",
      "}",
      "rational guess (mint k) {",
      "  const int dmx = 1000;",
      "  const int nmx = 1000;",
      "  for (int d = 1; d < dmx; d++) {",
      "    int n = int(k * mint(d));",
      "    if (n < nmx) return {n, d};",
      "  }",
      "  return {-1, 0};",
      "}"
    ],
    "prefix": "guess"
  },
  "../include/utility/make_vector.hpp": {
    "body": [
      "template <typename T>",
      "auto make_vector_impl(size_t sz, T t) {return std::vector<T>(sz, t);}",
      "",
      "template <size_t N, typename T, typename U, std::enable_if_t<N == 1, std::nullptr_t> = nullptr>",
      "auto make_vector(size_t sz, U u) {return make_vector_impl(sz, T(u));}",
      "",
      "template <size_t N, typename T, std::enable_if_t<N == 1, std::nullptr_t> = nullptr>",
      "auto make_vector(size_t sz) {return std::vector<T>(sz);}",
      "",
      "template <size_t N, typename T, typename... Args, std::enable_if_t<N != 1, std::nullptr_t> = nullptr>",
      "auto make_vector(size_t a, Args... args) {return make_vector_impl(a, make_vector<N - 1, T>(args...));}",
      "",
      "template <typename T, typename Size_t>",
      "auto& at(T& t, Size_t i) {return t.at(i);}",
      "",
      "template <typename T, typename Size_t, typename... Args>",
      "auto& at(T& t, Size_t i, Args... args) {return at(t.at(i), args...);}"
    ],
    "prefix": "make_vector"
  },
  "../include/utility/remove_bit_insert_bit.hpp": {
    "body": [
      "int remove_bit(int x, int j) {",
      "  int low = x & ((1 << j) - 1);",
      "  return ((x >> (j + 1)) << j) + low;",
      "}",
      "int insert_bit(int x, int j, int v) {",
      "  int low = x & ((1 << j) - 1);",
      "  return ((x >> j) << (j + 1)) + (v << j) + low;",
      "}"
    ],
    "prefix": "remove_bit_insert_bit"
  },
  "../snippets/algorithms/binary_serch.hpp": {
    "body": [
      "${1:int} ok = ${2:0}, ng = ${3:inf}, md;",
      "while (abs(ok - ng) > 1) {",
      "  md = (ok + ng) >> 1;",
      "  if (${4:ck(md)}) ok = md;",
      "  else ng = md;",
      "}"
    ],
    "prefix": "binary_serch"
  },
  "../snippets/algorithms/dfs1.hpp": {
    "body": [
      "fix ([&](auto dfs, int crr, int p) -> void {",
      "  for (auto const& nxt : graph.at(crr)) {",
      "    if (nxt == p) continue;",
      "    dfs(nxt, crr);",
      "  }",
      "})(${1:root}, $1);"
    ],
    "prefix": "dfs1"
  },
  "../snippets/algorithms/dfs2.hpp": {
    "body": [
      "fix ([&](auto dfs, int crr) -> void {",
      "  ckd.at(crr) = true;",
      "  for (auto const& nxt : graph.at(crr)) {",
      "    if (ckd.at(nxt)) continue;",
      "    dfs(nxt);",
      "  }",
      "})(${1:root});"
    ],
    "prefix": "dfs2"
  },
  "../snippets/algorithms/grid_bfs.hpp": {
    "body": [
      "std::vector<std::vector<${1:long long}>> dst(h, std::vector<$1>(w, ${4:-1}));",
      "queue<std::pair<int, int>> que;",
      "dst[${2:si}][${3:sj}] = 0, que.emplace($2, $3);",
      "while (!que.empty()) {",
      "  int cri, crj;",
      "  std::tie(cri, crj) = que.front(), que.pop();",
      "  for (int k = 0; k < 4; k++) {",
      "    int nxi = cri + di[k];",
      "    int nxj = crj + dj[k];",
      "    if (",
      "        0 <= nxi && nxi < h &&",
      "        0 <= nxj && nxj <= w &&",
      "        dst[nxi][nxj] == $4 &&",
      "        !grd[nxi][nxj]",
      "      ) dst[nxi][nxj] = dst[cri][crj] + 1, que.emplace(nxi, nxj);",
      "  }",
      "}"
    ],
    "prefix": "grid_bfs"
  },
  "../snippets/algorithms/inner_dfs1.hpp": {
    "body": [
      "  void dfs (",
      "      int crr = 0,",
      "      int prt = 0",
      "    ) {",
      "      for (int const& nxt : grh[crr]) {",
      "        ${2:T} w; int nxt; std::tie(w, nxt) = e;",
      "        if (nxt == prt) continue;",
      "        dfs(nxt, crr);",
      "        chmax(dp[crr], dp[nxt] + w);",
      "      }",
      "    }"
    ],
    "prefix": "inner_dfs1"
  },
  "../snippets/algorithms/lis.hpp": {
    "body": [
      "std::vector<${1:int}> lis;",
      "for (auto crr : ${2:name}) {",
      "  auto lb = std::lower_bound(lis.begin(), lis.end(), crr);",
      "  if (lb == lis.end()) lis.push_back(crr);",
      "  else *lb = crr;",
      "}"
    ],
    "prefix": "lis"
  },
  "../snippets/algorithms/shakutori.hpp": {
    "body": [
      "/* init crr, ret */",
      "for (int l = 0, r = 0; l < n; l++) {",
      "  if (r <= l) {",
      "    r = l;",
      "    /* re-init crr */;",
      "  }",
      "  for (; r < n; r++) {",
      "    if (/* cannot push r */) break;",
      "    /* push r */;",
      "  }",
      "  ret += r - l;",
      "  /* pop l */",
      "}"
    ],
    "prefix": "shakutori"
  },
  "../snippets/code_fragments/all.hpp": {
    "body": [
      "${1:name}.begin(), $1.end()"
    ],
    "prefix": "all"
  },
  "../snippets/code_fragments/didj.hpp": {
    "body": [
      "int d${1:i}[4] = {-1, +1, 0, 0};",
      "int d${2:j}[4] = {0, 0, -1, +1};"
    ],
    "prefix": "didj"
  },
  "../snippets/code_fragments/for_iterator.hpp": {
    "body": [
      "for (auto ${1:it} = ${2:name}.begin(); $1 != $2.end(); it++)",
      "{",
      "  $0",
      "}"
    ],
    "prefix": "for_iterator"
  },
  "../snippets/code_fragments/for_reverse.hpp": {
    "body": [
      "for (auto ${1:i} = ${2:n - 1}; $1 >= ${3:0}; $1--)",
      "{",
      "  $0",
      "}"
    ],
    "prefix": "for_reverse"
  },
  "../snippets/code_fragments/fors.hpp": {
    "body": [
      "for (${1:int} ${2:i} = ${3:0}; $2 < ${4:n}; $2++)",
      "{",
      "  $0",
      "}"
    ],
    "prefix": "fors"
  },
  "../snippets/code_fragments/inf.hpp": {
    "body": [
      "constexpr int inf = 1 << 30;"
    ],
    "prefix": "inf"
  },
  "../snippets/code_fragments/interval_dp.hpp": {
    "body": [
      "for (int d = 1; d <= ${1:n}; d++) {",
      "  for (int l = 0, r = d; r <= $1; l++, r++) {",
      "    $0",
      "  }",
      "}"
    ],
    "prefix": "interval_dp"
  },
  "../snippets/code_fragments/lambda.hpp": {
    "body": [
      "auto ${1:name} = [&] ($2)",
      "{",
      "  $0",
      "};"
    ],
    "prefix": "lambda"
  },
  "../snippets/code_fragments/long_inf.hpp": {
    "body": [
      "constexpr long long linf = 1LL << 60;"
    ],
    "prefix": "long_inf"
  },
  "../snippets/debug/-pdbg.hpp": {
    "body": [
      "std::cout << \"(\" << ${1:name}${2:->}first << \", \" << $1$2second << \")\";"
    ],
    "prefix": "-pdbg"
  },
  "../snippets/debug/-ppdbg.hpp": {
    "body": [
      "std::cout << \"(\" << get<0>(${1:*it}) << \", \" << get<1>($1) << \", \" << get<2>($1) << \")\";"
    ],
    "prefix": "-ppdbg"
  },
  "../snippets/debug/-sdbg.hpp": {
    "body": [
      "std::cout << ${1:name};"
    ],
    "prefix": "-sdbg"
  },
  "../snippets/debug/1dbg.hpp": {
    "body": [
      "{ // debug",
      "  std::cout << \"${1:a} = \" << $1 << std::endl;",
      "} //"
    ],
    "prefix": "1dbg"
  },
  "../snippets/debug/1prompt.hpp": {
    "body": [
      "std::cout << \"${2:a} > \";",
      "${1:int} $2;",
      "std::cin >> $2;"
    ],
    "prefix": "1prompt"
  },
  "../snippets/debug/1vdebug.hpp": {
    "body": [
      "{ // debug",
      "  int n = 0;",
      "  if (n < (int)${1:name}.size()) n = $1.size();",
      "  std::cout << std::setw(4) << \"----\"; for (int i = 0; i < n; i++) std::cout << std::setw(4) << \"----\" ; std::cout << std::endl;",
      "  std::cout << std::setw(4) << \"\"; for (int i = 0; i < n; i++) std::cout << std::setw(4) << i; std::cout << std::endl;",
      "  std::cout << std::setw(4) << \"----\"; for (int i = 0; i < n; i++) std::cout << std::setw(4) << \"----\" ; std::cout << std::endl;",
      "  std::cout << std::setw(4) << \"$1\"; for (auto const& e : $1) std::cout << std::setw(4) << e; std::cout << std::endl;",
      "  std::cout << std::setw(4) << \"----\"; for (int i = 0; i < n; i++) std::cout << std::setw(4) << \"----\" ; std::cout << std::endl;",
      "} //"
    ],
    "prefix": "1vdebug"
  },
  "../snippets/debug/2dbg.hpp": {
    "body": [
      "{ // debug",
      "  std::cout",
      "    << \"${1:a} = \" << $1 << \", \"",
      "    << \"${2:b} = \" << $2",
      "    << std::endl;",
      "} //"
    ],
    "prefix": "2dbg"
  },
  "../snippets/debug/2prpmpt.hpp": {
    "body": [
      "std::cout << \"${2:a}, ${3:b} > \";",
      "${1:int} $2, $3;",
      "std::cin >> $2 >> $3;"
    ],
    "prefix": "2prpmpt"
  },
  "../snippets/debug/2vdebug.hpp": {
    "body": [
      "{ // debug",
      "  int n = 0;",
      "  if (n < (int)${1:name}.size()) n = $1.size();",
      "  if (n < (int)${2:name}.size()) n = $2.size();",
      "  std::cout << std::setw(4) << \"----\"; for (int i = 0; i < n; i++) std::cout << std::setw(4) << \"----\" ; std::cout << std::endl;",
      "  std::cout << std::setw(4) << \"\"; for (int i = 0; i < n; i++) std::cout << std::setw(4) << i; std::cout << std::endl;",
      "  std::cout << std::setw(4) << \"----\"; for (int i = 0; i < n; i++) std::cout << std::setw(4) << \"----\" ; std::cout << std::endl;",
      "  std::cout << std::setw(4) << \"$1\"; for (auto const& e : $1) std::cout << std::setw(4) << e; std::cout << std::endl;",
      "  std::cout << std::setw(4) << \"$2\"; for (auto const& e : $2) std::cout << std::setw(4) << e; std::cout << std::endl;",
      "  std::cout << std::setw(4) << \"----\"; for (int i = 0; i < n; i++) std::cout << std::setw(4) << \"----\" ; std::cout << std::endl;",
      "} //"
    ],
    "prefix": "2vdebug"
  },
  "../snippets/debug/3dbg.hpp": {
    "body": [
      "{ // debug",
      "  std::cout",
      "    << \"${1:a} = \" << $1 << \", \"",
      "    << \"${2:b} = \" << $2 << \", \"",
      "    << \"${3:c} = \" << $3",
      "    << std::endl;",
      "} //"
    ],
    "prefix": "3dbg"
  },
  "../snippets/debug/3prompt.hpp": {
    "body": [
      "std::cout << \"${2:a}, ${3:b}, ${4:c} > \";",
      "${1:int} $2, $3, $4;",
      "std::cin >> $2 >> $3 >> $4;"
    ],
    "prefix": "3prompt"
  },
  "../snippets/debug/3vdebug.hpp": {
    "body": [
      "{ // debug",
      "  int n = 0;",
      "  if (n < (int)${1:name}.size()) n = $1.size();",
      "  if (n < (int)${2:name}.size()) n = $2.size();",
      "  if (n < (int)${3:name}.size()) n = $3.size();",
      "  std::cout << std::setw(4) << \"----\"; for (int i = 0; i < n; i++) std::cout << std::setw(4) << \"----\" ; std::cout << std::endl;",
      "  std::cout << std::setw(4) << \"\"; for (int i = 0; i < n; i++) std::cout << std::setw(4) << i; std::cout << std::endl;",
      "  std::cout << std::setw(4) << \"----\"; for (int i = 0; i < n; i++) std::cout << std::setw(4) << \"----\" ; std::cout << std::endl;",
      "  std::cout << std::setw(4) << \"$1\"; for (auto const& e : $1) std::cout << std::setw(4) << e; std::cout << std::endl;",
      "  std::cout << std::setw(4) << \"$2\"; for (auto const& e : $2) std::cout << std::setw(4) << e; std::cout << std::endl;",
      "  std::cout << std::setw(4) << \"$3\"; for (auto const& e : $3) std::cout << std::setw(4) << e; std::cout << std::endl;",
      "  std::cout << std::setw(4) << \"----\"; for (int i = 0; i < n; i++) std::cout << std::setw(4) << \"----\" ; std::cout << std::endl;",
      "} //"
    ],
    "prefix": "3vdebug"
  },
  "../snippets/debug/4dbg.hpp": {
    "body": [
      "{ // debug",
      "  std::cout",
      "    << \"${1:a} = \" << $1 << \", \"",
      "    << \"${2:b} = \" << $2 << \", \"",
      "    << \"${3:c} = \" << $3 << \", \"",
      "    << \"${4:d} = \" << $4",
      "    << std::endl;",
      "} //"
    ],
    "prefix": "4dbg"
  },
  "../snippets/debug/4vdebug.hpp": {
    "body": [
      "{ // debug",
      "  int n = 0;",
      "  if (n < (int)${1:name}.size()) n = $1.size();",
      "  if (n < (int)${2:name}.size()) n = $2.size();",
      "  if (n < (int)${3:name}.size()) n = $3.size();",
      "  std::cout << std::setw(4) << \"----\"; for (int i = 0; i < n; i++) std::cout << std::setw(4) << \"----\" ; std::cout << std::endl;",
      "  std::cout << std::setw(4) << \"\"; for (int i = 0; i < n; i++) std::cout << std::setw(4) << i; std::cout << std::endl;",
      "  std::cout << std::setw(4) << \"----\"; for (int i = 0; i < n; i++) std::cout << std::setw(4) << \"----\" ; std::cout << std::endl;",
      "  std::cout << std::setw(4) << \"$1\"; for (auto const& e : $1) std::cout << std::setw(4) << e; std::cout << std::endl;",
      "  std::cout << std::setw(4) << \"$2\"; for (auto const& e : $2) std::cout << std::setw(4) << e; std::cout << std::endl;",
      "  std::cout << std::setw(4) << \"$3\"; for (auto const& e : $3) std::cout << std::setw(4) << e; std::cout << std::endl;",
      "  std::cout << std::setw(4) << \"$4\"; for (auto const& e : $4) std::cout << std::setw(4) << e; std::cout << std::endl;",
      "  std::cout << std::setw(4) << \"----\"; for (int i = 0; i < n; i++) std::cout << std::setw(4) << \"----\" ; std::cout << std::endl;",
      "} //"
    ],
    "prefix": "4vdebug"
  },
  "../snippets/debug/bug.hpp": {
    "body": [
      "/* ↓ 消し忘れないで！！！ ↓ */",
      "$0",
      "/* ↑ いや振りじゃないから ↑ */"
    ],
    "prefix": "bug"
  },
  "../snippets/debug/check.hpp": {
    "body": [
      "std::cout << \"/\" << ${1:crr} << std::endl;",
      "std::cout << \"\\\\\\\\\" << ${1:crr} << std::endl;"
    ],
    "prefix": "check"
  },
  "../snippets/debug/interval_debug.hpp": {
    "body": [
      "{ // debug",
      "  std::cout",
      "    << \"[\" << $1 << \", \" << $2 << \")\" << std::endl;",
      "} //"
    ],
    "prefix": "interval_debug"
  },
  "../snippets/debug/map_debug.hpp": {
    "body": [
      "{ // debug",
      "  for (auto ${2:it} = ${1:mp}.begin(); $2 != $1.end(); $2++) {",
      "    std::cout << \"mp[\";",
      "    std::cout << $0$2->first;",
      "    std::cout << \"] = \";",
      "    std::cout << $2->second;",
      "    std::cout << \"\" << (next($2) == $1.end() ? \"\\n\" : \", \");",
      "  }",
      "} //"
    ],
    "prefix": "map_debug"
  },
  "../snippets/debug/ndbg.hpp": {
    "body": [
      "std::cout << \"$0\" << std::endl;"
    ],
    "prefix": "ndbg"
  },
  "../snippets/debug/new_line.hpp": {
    "body": [
      "{ // debug",
      "  std::cout << std::endl;",
      "} //"
    ],
    "prefix": "new_line"
  },
  "../snippets/debug/pdbg.hpp": {
    "body": [
      "{ // debug",
      "  std::cout << \"${1:name} = (\" << $1${2:.}first << \", \" <<  $1$2second << \")\" << std::endl;",
      "} //"
    ],
    "prefix": "pdbg"
  },
  "../snippets/debug/pretty_debug.hpp": {
    "body": [
      "#define LOCAL",
      "using std::to_string;",
      "auto to_string(std::string s) -> std::string {",
      "  return '\"' + s + '\"';",
      "}",
      "auto to_string(char c) -> std::string {",
      "  return \"'\" + std::string{c} + \"'\";",
      "}",
      "auto to_string(const char* s) -> std::string {",
      "  return to_string((std::string) s);",
      "}",
      "auto to_string(bool b) -> std::string {",
      "  return (b ? \"true\" : \"false\");",
      "}",
      "template <typename T, typename U>",
      "auto to_string(std::pair<T, U> p) -> std::string {",
      "  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";",
      "}",
      "template <size_t N>",
      "auto to_string(std::bitset<N> bs) -> std::string {",
      "  std::string res{};",
      "  for (size_t i = 0; i < N; i++)",
      "    res.insert(res.begin(), bs.test(i) ? '1' : '0');",
      "  return res;",
      "}",
      "template <typename T>",
      "auto to_string(T v) -> std::string {",
      "  bool flg = false;",
      "  std::string res = \"{\";",
      "  for (auto const&x : v) {",
      "    if (flg) res += \", \";",
      "    else flg = true;",
      "    res += to_string(x);",
      "  }",
      "  res += \"}\";",
      "  return res;",
      "}",
      "void debug_out() { std::cerr << std::endl; }",
      "template <typename Head, typename... Tail>",
      "void debug_out(Head H, Tail... T) {",
      "  std::cerr << \" \" << to_string(H);",
      "  debug_out(T...);",
      "}",
      "#ifdef LOCAL",
      "#define debug(...) std::cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)",
      "#else",
      "#define debug(...) 42",
      "#endif"
    ],
    "prefix": "pretty_debug"
  },
  "../snippets/debug/vpdebug.hpp": {
    "body": [
      "{ // debug",
      "  std::cout << \"${1:name}: \";",
      "  for (auto ${2:it} = $1.begin(); $2 != $1.end(); $2++) {",
      "    std::cout << \"(\";",
      "    std::cout << $2->first;",
      "    std::cout << \", \";",
      "    std::cout << $2->second;",
      "    std::cout << \")\" << (next($2) == $1.end() ? \"\\n\" : \", \");",
      "  }",
      "  std::cout << std::endl;",
      "} //"
    ],
    "prefix": "vpdebug"
  },
  "../snippets/debug/vvdbg.hpp": {
    "body": [
      "{ // debug",
      "  int h = ${1:name}.size(); int w = 0;",
      "  int name_length = ${2:3}; int output_length = ${3:4};",
      "  for (int i = 0; i < h; i++) if (w < (int)$1[i].size()) w = $1[i].size();",
      "  std::cout << std::string(name_length, '-') << \"--\";",
      "  for (int j = 0; j < w; j++) std::cout << std::setw(${3:output length}) << \"----\";",
      "  std::cout << std::endl;",
      "  std::cout << std::setw(name_length) << std::right << \"$1\" << \"| \";",
      "  for (int j = 0; j < w; j++) std::cout << std::setw(output_length) << std::right <<  j;",
      "  std::cout << std::endl;",
      "  std::cout << std::string(name_length, '-') << \"+-\";",
      "  for (int j = 0; j < w; j++) std::cout << std::string(output_length, '-');",
      "  std::cout << std::endl;",
      "  for (int i = 0; i < h; i++) {",
      "    std::cout << std::setw(name_length) << std::right << i << \"| \";",
      "    for (auto const& e : $1[i]) std::cout << std::setw(output_length) << std::right << (e == ${4:0} ? \"0\" : std::to_string(e));",
      "    std::cout << std::endl;",
      "  }",
      "  std::cout << std::string(name_length, '-') << \"--\";",
      "  for (int j = 0; j < w; j++) std::cout << std::string(output_length, '-');",
      "  std::cout << std::endl;",
      "} //"
    ],
    "prefix": "vvdbg"
  },
  "../snippets/io/1sin.hpp": {
    "body": [
      "${1:int} $2; std::cin >> $2;"
    ],
    "prefix": "1sin"
  },
  "../snippets/io/2sin.hpp": {
    "body": [
      "${1:int} $2, $3; std::cin >> $2 >> $3;"
    ],
    "prefix": "2sin"
  },
  "../snippets/io/3sin.hpp": {
    "body": [
      "${1:int} $2, $3, $4;",
      "std::cin >> $2 >> $3 >> $4;"
    ],
    "prefix": "3sin"
  },
  "../snippets/io/4sin.hpp": {
    "body": [
      "${1:int} $2, $3, $4, $5;",
      "std::cin >> $2 >> $3 >> $4 >> $5;"
    ],
    "prefix": "4sin"
  },
  "../snippets/io/5sin.hpp": {
    "body": [
      "${1:int} $2, $3, $4, $5, $6;",
      "std::cin >> $2 >> $3 >> $4 >> $5 >> $6;"
    ],
    "prefix": "5sin"
  },
  "../snippets/io/err.hpp": {
    "body": [
      "auto err = [&] {",
      "  std::cout << $0 << std::endl;",
      "  exit(0);",
      "};"
    ],
    "prefix": "err"
  },
  "../snippets/io/sout.hpp": {
    "body": [
      "std::cout << $0 << std::endl;"
    ],
    "prefix": "sout"
  },
  "../snippets/io/tin.hpp": {
    "body": [
      "${1:int} ${2:tmp};",
      "std::cin >> $2;",
      "$0;"
    ],
    "prefix": "tin"
  },
  "../snippets/stemp.hpp": {
    "body": [
      "#include <bits/stdc++.h>",
      "#define loop(n) for (int ngtkana_is_genius = 0; ngtkana_is_genius < int(n); ngtkana_is_genius++)",
      "#define rep(i, begin, end) for(int i = int(begin); i < int(end); i++)",
      "#define lint long long",
      "auto cmn = [](auto& a, auto b){if (a > b) {a = b; return true;} return false;};",
      "auto cmx = [](auto& a, auto b){if (a < b) {a = b; return true;} return false;};",
      "void debug_impl() { std::cerr << std::endl; }",
      "template <typename Head, typename... Tail>",
      "void debug_impl(Head head, Tail... tail){",
      "  std::cerr << \" \" << head;",
      "  debug_impl(tail...);",
      "}",
      "#define debug(...) std::cerr << std::boolalpha << \"[\" << #__VA_ARGS__ << \"]:\";\\",
      "  debug_impl(__VA_ARGS__);\\",
      "  std::cerr << std::noboolalpha;",
      "",
      "int main()",
      "{",
      "  std::cin.tie(0); std::cin.sync_with_stdio(false);",
      "  $0",
      "  return 0;",
      "}"
    ],
    "prefix": "stemp"
  }
}