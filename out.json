{
  "../include/ALL.hpp": {
    "body": [
      "#define ALL(a) std::begin(a),std::end(a)"
    ],
    "prefix": "ALL"
  },
  "../include/LOOP.hpp": {
    "body": [
      "#define LOOP(x) for(lint ngtkana_is_a_genius=0;ngtkana_is_a_genius!=x;ngtkana_is_a_genius++)"
    ],
    "prefix": "LOOP"
  },
  "../include/REP.hpp": {
    "body": [
      "#define REP(type,i,l,r) for(type i=(l);i!=(r);i++)"
    ],
    "prefix": "REP"
  },
  "../include/bat.hpp": {
    "body": [
      "template < class Value >",
      "bool bat(Value x, std::size_t pos) { return (x >> pos) & Value{1}; }"
    ],
    "prefix": "bat"
  },
  "../include/bipartite_matching.hpp": {
    "body": [
      "class bipartite_matching {",
      "        int L, R;",
      "        std::vector<std::vector<int>> graph;",
      "        std::vector<int> match, level;",
      "",
      "        bool bfs() {",
      "            std::fill(level.begin(), level.end(), -1);",
      "            std::queue<int> que;",
      "            for (auto i = 0; i < L; i++) {",
      "                if (match.at(i) < 0) {",
      "                    level.at(i) = 0;",
      "                    que.emplace(i);",
      "                }",
      "            }",
      "            bool ret = false;",
      "            while (!que.empty()) {",
      "                auto crr = que.front(); que.pop();",
      "                for (auto nxt : graph.at(crr)) {",
      "                    if (level.at(nxt) != -1) continue;",
      "                    level.at(nxt) = level.at(crr) + 1;",
      "                    auto w = match.at(nxt);",
      "                    if (w == -1)",
      "                        { ret = true; }",
      "                    else if (level.at(w) == -1) {",
      "                        level.at(w) = level.at(crr) + 1;",
      "                        que.emplace(w);",
      "                    }",
      "                }",
      "            }",
      "            return ret;",
      "        }",
      "",
      "        bool dfs(int crr) {",
      "            for (auto nxt : graph.at(crr)) {",
      "                assert(level.at(nxt) <= level.at(crr) + 1);",
      "                if (level.at(nxt) < level.at(crr) + 1) continue;",
      "                level.at(nxt) = -1;",
      "                auto w = match.at(nxt);",
      "                if (w == -1 || dfs(w)) {",
      "                    match.at(nxt) = crr;",
      "                    match.at(crr) = nxt;",
      "                    level.at(crr) = -1;",
      "                    return true;",
      "                }",
      "            }",
      "            level.at(crr) = -1;",
      "            return false;",
      "        }",
      "",
      "    public:",
      "        bipartite_matching()=default;",
      "        bipartite_matching(int L, int R):",
      "            L(L), R(R), graph(L + R), match(L + R, -1), level(L + R)",
      "            {}",
      "",
      "        void insert(int u, int v) {",
      "            v += L;",
      "            graph.at(u).emplace_back(v);",
      "            graph.at(v).emplace_back(u);",
      "        }",
      "",
      "",
      "        int build () {",
      "            auto ret = 0;",
      "            while (bfs()) {",
      "                for (int i = 0; i < L; i++) {",
      "                    if (match.at(i) == -1 && dfs(i))",
      "                        { ret++; }",
      "                }",
      "            }",
      "            return ret;",
      "        }",
      "",
      "        auto collect() const {return match;}",
      "",
      "        auto count() const {",
      "            auto k = L + R - std::count(match.begin(), match.end(), -1);",
      "            assert(k % 2 == 0);",
      "            return k / 2;",
      "        }",
      "};"
    ],
    "prefix": "bipartite_matching"
  },
  "../include/centroid_tree.hpp": {
    "body": [
      "",
      "class centroid_tree {",
      "        int n;",
      "        int centroid;",
      "        std::vector< std::vector< int > > graph;",
      "        std::vector< int > depth;",
      "        std::vector< int > size;",
      "        std::vector< std::vector< int > > subtrees;",
      "",
      "        auto dead(int i) { return depth.at(i) != -1; }",
      "",
      "        auto build_impl(int root, int n, int d) -> int {",
      "            auto ctr = -1;",
      "            auto dfs = [&, this](auto&& f, int crr, int prv) -> int {",
      "                auto sz = 1;",
      "                for (auto const nxt : graph.at(crr)) {",
      "                    if (nxt == prv || this->dead(nxt)) continue;",
      "                    sz += f(f, nxt, crr);",
      "                }",
      "                if (ctr == -1 && n <= 2 * sz)",
      "                    { ctr = crr; }",
      "                return size.at(crr) = sz;",
      "            };",
      "            dfs(dfs, root, root);",
      "",
      "            depth.at(ctr) = d;",
      "            for (auto const & nxt : graph.at(ctr)) {",
      "                if (dead(nxt)) continue;",
      "                auto sz = size.at(nxt);",
      "                if (n <= 2 * sz)",
      "                    { sz = n - size.at(ctr); }",
      "                subtrees.at(ctr).emplace_back(build_impl(nxt, sz, d + 1));",
      "            }",
      "            size.at(ctr) = n;",
      "            return ctr;",
      "        }",
      "",
      "    public:",
      "        centroid_tree(std::vector< std::vector< int > > const& graph) :",
      "            n(graph.size()),",
      "            graph(graph),",
      "            depth(n, -1),",
      "            size(n),",
      "            subtrees(n)",
      "            {}",
      "",
      "        void build() {",
      "            centroid = build_impl(0, n, 0);",
      "        }",
      "",
      "        auto get_depth     () const { return depth;        }",
      "        auto get_size        () const { return size;         }",
      "        auto get_subtrees() const { return subtrees; }",
      "        auto get_centroid() const { return centroid; }",
      "};"
    ],
    "prefix": "centroid_tree"
  },
  "../include/check.hpp": {
    "body": [
      "std::cout << \"/\" << ${1:crr} << std::endl;",
      "std::cout << \"\\\\\\\\\" << ${1:crr} << std::endl;"
    ],
    "prefix": "check"
  },
  "../include/cmn_cmx.hpp": {
    "body": [
      "[[maybe_unused]]auto cmn=[](auto&& a,auto b){if(a>b){a=b;return true;}return false;};",
      "[[maybe_unused]]auto cmx=[](auto&& a,auto b){if(a<b){a=b;return true;}return false;};"
    ],
    "prefix": "cmn_cmx"
  },
  "../include/container_io.hpp": {
    "body": [
      "template < typename Container, typename Value = typename Container::value_type, std::enable_if_t<!std::is_same< Container, std::string >::value, std::nullptr_t> = nullptr>",
      "std::istream& operator>> (std::istream& is, Container& v)",
      "    { for (auto & x : v) { is >> x; } return is; }",
      "",
      "template < typename Container, typename Value = typename Container::value_type, std::enable_if_t<!std::is_same< Container, std::string >::value, std::nullptr_t> = nullptr >",
      "std::ostream& operator<< (std::ostream& os, Container const& v) {",
      " os << \"{\";",
      "    for (auto it = v.begin(); it != v.end(); it++)",
      "        {os << (it != v.begin() ? \",\" : \"\") << *it;}",
      "    return os << \"}\";",
      "}"
    ],
    "prefix": "container_io"
  },
  "../include/debug.hpp": {
    "body": [
      "void debug_impl() { std::cerr << std::endl; }",
      "template <typename Head, typename... Tail>",
      "void debug_impl(Head head, Tail... tail) { std::cerr << \" \" << head; debug_impl(tail...); }",
      "#define DEBUG 1",
      "#if DEBUG",
      "#define debug(...)\\",
      "    do {\\",
      "        std::cerr << std::boolalpha << \"[\" << #__VA_ARGS__ << \"]:\";\\",
      "        debug_impl(__VA_ARGS__);\\",
      "        std::cerr << std::noboolalpha;\\",
      "    } while (false)",
      "#else",
      "#define debug(...) {}",
      "#endif"
    ],
    "prefix": "debug"
  },
  "../include/didj.hpp": {
    "body": [
      "std::array<int,4>di={-1,+1,0,0};",
      "std::array<int,4>dj={0,0,-1,+1};"
    ],
    "prefix": "didj"
  },
  "../include/dinic.hpp": {
    "body": [
      "template <typename Flow>",
      "struct residue_edge {",
      "    int to; Flow cap, original_cap; int rev;",
      "    residue_edge(int to, Flow cap, int rev):",
      "        to(to), cap(cap), original_cap(cap), rev(rev){}",
      "};",
      "",
      "template <typename Flow>",
      "std::ostream& operator<< (std::ostream& os, const residue_edge<Flow>& e){",
      "    return os",
      "        << \"residue_edge{\"",
      "        << \"to:\" << e.to << \",\"",
      "        << \"cap:\" << e.cap << \",\"",
      "        << \"rev:\" << e.rev",
      "        << \"}\";",
      "}",
      "",
      "template <typename Flow>",
      "struct flow_edge {",
      "    int to; Flow flow;",
      "    flow_edge(int to, Flow flow) : to(to), flow(flow){}",
      "};",
      "",
      "template <typename Flow>",
      "std::ostream& operator<< (std::ostream& os, const flow_edge<Flow>& e) {",
      "    return os",
      "        << \"flow_edge{\"",
      "        << \"to:\" << e.to << \",\"",
      "        << \"flow:\" << e.flow",
      "        << \"}\";",
      "}",
      "",
      "template <typename Flow>",
      "class dinic {",
      "        int                                                                                    n, source, sink;",
      "        std::vector<bool>                                                        ckd;",
      "        std::vector<int>                                                         level;",
      "        std::vector<std::vector<residue_edge<Flow>>> graph;",
      "",
      "        static constexpr Flow inf_flow = std::numeric_limits<Flow>::max();",
      "",
      "        void bfs () {",
      "            std::queue<int> que;",
      "            que.emplace(source); level.at(source) = 0;",
      "            while (!que.empty()) {",
      "                auto crr = que.front(); que.pop();",
      "                for (auto const& e : graph.at(crr)) {",
      "                    if (e.cap == 0) continue;",
      "                    int nxt = e.to;",
      "                    if (level.at(nxt) != -1) continue;",
      "                    que.push(nxt);",
      "                    level.at(nxt) = level.at(crr) + 1;",
      "                }",
      "            }",
      "        }",
      "",
      "        auto dfs (int crr, Flow f = inf_flow) {",
      "            if (crr == sink) return f;",
      "            ckd.at(crr) = true;",
      "            for (auto& e : graph.at(crr)) {",
      "                auto nxt = e.to;",
      "                if (ckd.at(nxt) || e.cap == 0 || level.at(crr) >= level.at(nxt)) continue;",
      "                auto d = dfs(nxt, std::min(f, e.cap));",
      "                if (d > 0) {",
      "                    e.cap -= d;",
      "                    graph.at(nxt).at(e.rev).cap += d;",
      "                    return d;",
      "                }",
      "            }",
      "            level.at(crr) = -1;",
      "            return Flow(0);",
      "        }",
      "",
      "    public:",
      "        dinic (int n, int source, int sink):",
      "            n(n), source(source), sink(sink), graph(n){}",
      "",
      "        void insert(int u, int v, Flow c) {",
      "            graph.at(u).emplace_back(v, c, graph.at(v).size());",
      "            graph.at(v).emplace_back(u, 0, graph.at(u).size() - 1);",
      "        }",
      "",
      "        auto build() {",
      "            Flow ret = 0;",
      "            while (true) {",
      "                level.assign(n, -1);",
      "                bfs();",
      "                if (level.at(sink) == -1) return ret;",
      "                ckd.assign(n, false);",
      "                while (true) {",
      "                    auto f = dfs(source);",
      "                    if (f == 0) break;",
      "                    ret += f;",
      "                }",
      "            }",
      "        }",
      "",
      "        auto collect() const {",
      "            std::vector<std::vector<flow_edge<Flow>>> ret(n);",
      "            for (auto i = 0; i < n; i++) {",
      "                for (auto const& e : graph.at(i)) {",
      "                    auto flow = e.original_cap - e.cap;",
      "                    if (flow > 0) ret.at(i).emplace_back(e.to, flow);",
      "                }",
      "            }",
      "            return ret;",
      "        }",
      "};"
    ],
    "prefix": "dinic"
  },
  "../include/disjoint_sparse_table.hpp": {
    "body": [
      "template <typename T>",
      "class disjoint_sparse_table {",
      "    const int n, ht;",
      "    const std::vector<int> msb;",
      "    const std::function<T(T, T)> o;",
      "    const std::vector<std::vector<T>> tab;",
      "    public:",
      "        disjoint_sparse_table (",
      "                const std::vector<T> a,",
      "                const std::function<T(T, T)> o",
      "            ) :",
      "            n(a.size()),",
      "            ht([&](){",
      "                    int ret = 1;",
      "                    for (int b = 2; b < n; b <<= 1) ret++;",
      "                    return ret;",
      "                }()),",
      "            msb([&](){",
      "                    int N = 1 << ht;",
      "                    auto ret = std::vector<int>(N, 0); ret[0] = -1;",
      "                    for (int i = 2; i < N; i++) ret[i] = ret[i >> 1] + 1;",
      "                    return ret;",
      "                }()),",
      "            o(o),",
      "            tab([&](){",
      "                    auto ret = std::vector<std::vector<T>>(ht, a);",
      "                    for (int i = 1; i < ht; i++) {",
      "                        int p = 1 << i; int P = p << 1;",
      "                        for (int s = 0; s < n; s += P) {",
      "                            int t = min(s + p, n);",
      "                            for (int j = t - 2; j >= s; j--) ret[i][j] = o(a[j], ret[i][j + 1]);",
      "                            for (int j = t + 1; j < min(s + P, n); j++) ret[i][j] = o(ret[i][j - 1], a[j]);",
      "                        }",
      "                    }",
      "                    return ret;",
      "                }())",
      "            {",
      "            }",
      "        auto query (",
      "                int l,",
      "                int r",
      "            ) -> T",
      "            {",
      "                assert(l <= --r);",
      "                int m = msb[l ^ r];",
      "                return m == -1 ? tab[0][l] : o(tab[m][l], tab[m][r]);",
      "            }",
      "};"
    ],
    "prefix": "disjoint_sparse_table"
  },
  "../include/divisors.hpp": {
    "body": [
      "template < class Value >",
      "inline auto divisors(Value x) {",
      "    std::vector< Value > ret;",
      "    std::stack < Value > stk;",
      "    for (Value i = 1; i * i <= x; i++) {",
      "        if (x % i == 0) {",
      "            ret.emplace_back(i);",
      "            if (i * i < x)",
      "                { stk.emplace(x / i); }",
      "        }",
      "    }",
      "    while (!stk.empty())",
      "        { ret.emplace_back(stk.top()), stk.pop(); }",
      "    return ret;",
      "}"
    ],
    "prefix": "divisors"
  },
  "../include/err.hpp": {
    "body": [
      "void err() { std::cout << $1 << std::endl; exit(0); }",
      "#define require(exp) do { if (!(exp)) { err(); } } while(false)"
    ],
    "prefix": "err"
  },
  "../include/factorials.hpp": {
    "body": [
      "template < typename Value >",
      "class factorials {",
      "        std::vector< Value > fact, finv;",
      "",
      "    public:",
      "        factorials()=default;",
      "",
      "        void build(int n) {",
      "            fact.resize(n), finv.resize(n);",
      "            fact.at(0) = 1;",
      "            for (int i = 1; i < n; i++) fact.at(i) = fact.at(i - 1) * Value(i);",
      "            finv.at(n - 1) = Value(1) / fact.at(n - 1);",
      "            for (int i = n - 2; i >= 0; i--) finv.at(i) = finv.at(i + 1) * Value(i + 1);",
      "        }",
      "        auto operator()    (int i) const {return fact.at(i);}",
      "        auto inv                 (int i) const {return finv.at(i);}",
      "        auto binom(int i, int j) const {",
      "            assert(0 <= i);",
      "            if (j < 0 ||i < j) return Value(0);",
      "            return fact.at(i) * finv.at(j) * finv.at(i - j);",
      "        }",
      "        auto deal(int i, int j) const",
      "            { return binom(i + j - 1, j - 1); }",
      "};"
    ],
    "prefix": "factorials"
  },
  "../include/factorize.hpp": {
    "body": [
      "inline auto factorize(long long x) {",
      "    std::vector<std::pair<long long,int>> ret;",
      "    for (long long p=2;p*p<=x;p++) {",
      "        int m=0;",
      "        for (;x%p==0;m++)",
      "            {x /= p; }",
      "        if (m>0)",
      "            {ret.emplace_back(p, m);}",
      "    }",
      "    if (1<x)",
      "        {ret.emplace_back(x,1);}",
      "    return ret;",
      "}"
    ],
    "prefix": "factorize"
  },
  "../include/floyd_warshall.hpp": {
    "body": [
      "template < class Value >",
      "auto floyd_warshall(std::vector< std::vector< Value > > adj, Value inf) {",
      "    assert(inf <= std::numeric_limits< Value >::max() / 2);",
      "    int n = adj.size();",
      "    for (auto k = 0; k < n; k++) {",
      "        for (auto i = 0; i < n; i++) {",
      "            for (auto j = 0; j < n; j++) {",
      "                auto & crr = adj.at(i).at(j);",
      "                auto x = adj.at(i).at(k);",
      "                auto y = adj.at(k).at(j);",
      "                if (x < inf && y < inf) {",
      "                    crr = std::min(crr, x + y);",
      "                }",
      "            }",
      "        }",
      "    }",
      "    return adj;",
      "}"
    ],
    "prefix": "floyd_warshall"
  },
  "../include/fmt.hpp": {
    "body": [
      "template <class Key>",
      "class fmt_t {",
      "        Key key;",
      "",
      "        template <class Value>",
      "        auto is_exact_match(long, Value) const {",
      "            return false;",
      "        }",
      "",
      "        template <class Value, class = decltype(std::declval< Value >() == key)>",
      "        auto is_exact_match(int, Value x) const {",
      "            return x == key;",
      "        }",
      "",
      "",
      "        // tuple_format_impl",
      "        template < class Tuple,    std::size_t ... Is >",
      "        std::string tuple_format_impl(const Tuple& tuple, std::integer_sequence< std::size_t, Is ... >) const {",
      "            std::string ret = \"(\";",
      "            (void)std::initializer_list< std::nullptr_t >",
      "                { (ret = ret + (Is == 0 ? \"\" : \",\") + format(std::get< Is >(tuple)), nullptr) ... };",
      "            return ret + \")\";",
      "        }",
      "",
      "        // usual_format",
      "        template < class Value >",
      "        std::string usual_format(long, Value x) const",
      "            { return std::to_string(x); }",
      "",
      "        template < class Value, std::enable_if_t< std::is_same< std::decay_t< Value >, char >::value, std::nullptr_t > = nullptr >",
      "        std::string usual_format(int, Value c) const",
      "            { return std::string{'\\''} + std::string{c} + std::string{'\\''}; }",
      "",
      "        std::string usual_format(int, char const* s) const",
      "            { return \"\\\"\" + std::string(s) + \"\\\"\"; }",
      "",
      "        std::string usual_format(int, std::string const s) const",
      "            { return \"\\\"\" + s + \"\\\"\"; }",
      "",
      "        template < class Container, class = typename Container::value_type >",
      "        std::string usual_format(int, Container const & v) const {",
      "            return \"{\" + std::accumulate(v.begin(), v .end(), std::string{},",
      "                [this](auto const& s, auto const x) { return s + (s.empty() ? \"\" : \",\") + this->format(x); })",
      "                + \"}\";",
      "        }",
      "",
      "        template < class Tuple, std::size_t N = std::tuple_size< Tuple >::value >",
      "        std::string usual_format(int, Tuple const& tuple) const",
      "            { return tuple_format_impl(tuple, std::make_index_sequence< N >()); }",
      "",
      "        // format",
      "        template < class Value > std::string format(Value&& x) const",
      "            { return is_exact_match(int{}, x) ? std::string{'_'} : usual_format(int{}, x); }",
      "",
      "    public:",
      "        fmt_t()=default;",
      "        fmt_t(Key&& key) : key(key){}",
      "",
      "        template < class Value > std::string operator()(Value&& x) const",
      "            { return format(x); }",
      "};",
      "template <class Key> auto fmt(Key key)",
      "    { return fmt_t<Key>(std::forward<Key>(key)); }"
    ],
    "prefix": "fmt"
  },
  "../include/ford_fulkerson.hpp": {
    "body": [
      "template <typename T>",
      "class ford_fulkerson {",
      "    struct edge {",
      "        int to; T cap;",
      "        weak_ptr<edge> rev;",
      "        edge(int to, T cap) : to(to), cap(cap) {}",
      "    };",
      "    const int n, source, sink;",
      "    std::vector<bool> ckd;",
      "    std::vector<std::vector<shared_ptr<edge>>> grh;",
      "    static constexpr T inf = numeric_limits<T>::max();",
      "    T dfs () {",
      "        return fix ([&](auto dfs, int crr, int f = inf) -> T {",
      "            if (crr == sink) return f;",
      "            ckd[crr] = true;",
      "            for (auto& e : grh[crr]) {",
      "                if (ckd[e->to] || !e->cap) continue;",
      "                T d = dfs(e->to, min(f, e->cap));",
      "                if (d) {",
      "                    e->cap -= d;",
      "                    e->rev.lock()->cap += d;",
      "                    return d;",
      "                }",
      "            }",
      "            return 0;",
      "        })(source);",
      "    }",
      "    public:",
      "        ford_fulkerson (int n, int source, int sink) :",
      "            n(n), source(source), sink(sink), grh(n)",
      "            {}",
      "        void insert(int u, int v, T c) {",
      "            auto e = make_shared<edge>(v, c);",
      "            auto r = make_shared<edge>(u, 0);",
      "            e->rev = r;",
      "            r->rev = e;",
      "            grh[u].push_back(e);",
      "            grh[v].push_back(r);",
      "        }",
      "        T cal() {",
      "            T ret = 0;",
      "            while (true) {",
      "                ckd.assign(n, false);",
      "                T f = dfs();",
      "                if (!f) return ret;",
      "                ret += f;",
      "            }",
      "        }",
      "};"
    ],
    "prefix": "ford_fulkerson"
  },
  "../include/fully_indexable_dictionary.hpp": {
    "body": [
      "class fully_indexable_dictionary {",
      "        using value_t = uint32_t;",
      "        using count_t = unsigned;",
      "        static constexpr size_t sz = 8 * sizeof(uint32_t);",
      "        bool built;",
      "        size_t full_length, n;",
      "        std::vector<value_t> row_data;",
      "        std::vector<count_t> rank_table;",
      "",
      "    public:",
      "        fully_indexable_dictionary(size_t full_length) :",
      "            built(false),",
      "            full_length(full_length),",
      "            n((full_length + sz - 1) / sz),",
      "            row_data(n), rank_table(n) {",
      "                debug(sz, n);",
      "            }",
      "",
      "        // Set the i-th bit.",
      "        void set(size_t i) {",
      "            assert(!built);",
      "            row_data.at(i / sz) |= (1u << i);",
      "        }",
      "",
      "        // Initialize the rank-table.",
      "        void build() {",
      "            assert(!built);",
      "            rank_table = [&]{",
      "                std::vector<count_t> pop_counts(n), rank_table(n);",
      "                std::transform(row_data.begin(), row_data.end(), pop_counts.begin(),",
      "                    [](auto x){return __builtin_popcountl(x);});",
      "                std::partial_sum(pop_counts.begin(), pop_counts.end(), rank_table.begin());",
      "                rank_table.insert(rank_table.begin(), 0u);",
      "                return rank_table; ",
      "            }();",
      "            built = true;",
      "            debug(row_data, rank_table);",
      "        }",
      "",
      "        // Access the i-th bit.",
      "        auto access(size_t i) const -> bool {",
      "            return row_data.at(i / sz) >> (i % sz) & 1u;",
      "        }",
      "        // An alias of access",
      "        auto at(size_t i) const -> bool {return access(i);}",
      "        ",
      "        // Count the 1.",
      "        auto rank(size_t i) const -> count_t {",
      "            return rank_table.at(i / sz)",
      "                + __builtin_popcountl(row_data.at(i / sz) & ((1 << (i % sz)) - 1));",
      "        }",
      "",
      "        // Find the k-th 1. (That is the maximal i such that rank(i) <= k.)",
      "        // When not found, returns the full-size of the sequence.",
      "        auto select(size_t k) const -> size_t {",
      "            size_t left = 0, right = full_length + 1, mid;",
      "            while (right - left > 1) {",
      "                mid = (left + right) / 2;",
      "                (rank(mid) <= k ? left : right) = mid;",
      "            }",
      "            return left;",
      "        }",
      "};"
    ],
    "prefix": "fully_indexable_dictionary"
  },
  "../include/gauss_jordan_int.hpp": {
    "body": [
      "class gauss_jordan {",
      "    const int h, w;",
      "    int rk;",
      "    std::vector<bool> ckd;",
      "    std::vector<int> p, a;",
      "    void init () {",
      "        for (int j = 0; j < w; j++) {",
      "            for (int pvt = 0; pvt < h; pvt++) {",
      "                if (ckd[pvt]) continue;",
      "                if (a[j] >> pvt & 1) {",
      "                    ckd[pvt] = true; rk++;",
      "                    int comb = a[j] ^ 1 << pvt;",
      "                    for (int i = 0; i < h; i++) if (p[i] >> pvt & 1) p[i] ^= comb;",
      "                    for (int k = j; k < w; k++) if (a[k] >> pvt & 1) a[k] ^= comb;",
      "                    break;",
      "                }",
      "            }",
      "        }",
      "    }",
      "    int transform (int y) const {",
      "        int z = 0;",
      "        for (int i = 0; i < h; i++) {",
      "            if (y >> i & 1) z |= p[i];",
      "        }",
      "        return z;",
      "    }",
      "    public:",
      "        gauss_jordan (",
      "                std::vector<int> a,",
      "                int h",
      "            ) :",
      "            h(h), w(a.size()), rk(0),",
      "            ckd(h, false),",
      "            p([&]{",
      "                std::vector<int> p(h); ",
      "                for (int i = 0, x = 1; i < h; i++, x *= 2) p[i] = x;",
      "                return p;",
      "            }()),",
      "            a(a)",
      "            {",
      "                init();",
      "            }",
      "        int rank () const {return rk;}",
      "        int kernel () const {return w - rk;}",
      "        int image () const {return h - rk;}",
      "        bool solvable (int y) const {",
      "            assert (!(y >> h));",
      "            int acm = accumulate(a.begin(), a.end(), 0, [](int x, int y){return x | y;});",
      "            int z = transform(y);",
      "            return !(~acm & z);",
      "        }",
      "};"
    ],
    "prefix": "gauss_jordan_int"
  },
  "../include/guess.hpp": {
    "body": [
      "struct rational {int n, d;};",
      "auto to_string(rational r) -> std::string {",
      "    return r.d == 1",
      "        ? std::to_string(r.n)",
      "        : std::to_string(r.n) + \"/\" + std::to_string(r.d);",
      "}",
      "std::ostream& operator << (std::ostream& os, rational r)",
      "    { return os << to_string(r); }",
      "auto guess (mint k) -> rational {",
      "    auto const dmax = 1000;",
      "    auto const nmax = 1000;",
      "    for (auto d = 1; d < dmax; d++) {",
      "        auto n = int(k * mint(d));",
      "        if (n < nmax) return {n, d};",
      "        n = mod - n;",
      "        if (n < nmax) return {-n, d};",
      "    }",
      "    return {-1, 0};",
      "}"
    ],
    "prefix": "guess"
  },
  "../include/heavy_light_decomposition.hpp": {
    "body": [
      "class heavy_light_decomposition {",
      "        int n;",
      "        std::vector<std::vector<int>>graph;",
      "        std::vector<int>prt,sz,vid,ord,head;",
      "",
      "    public:",
      "        heavy_light_decomposition()=default;",
      "        heavy_light_decomposition(int n) :",
      "            n(n),",
      "            graph(n),",
      "            prt(n),",
      "            sz(n, 1),",
      "            vid(n),",
      "            ord(n),",
      "            head(n)",
      "            {}",
      "",
      "        // Accessers.",
      "        auto id(int x) const {return vid.at(x);}",
      "",
      "        void build (int root = 0) {",
      "            auto const dfs = [&](auto&& f , auto crr) -> void {",
      "                for (auto& nxt : graph.at(crr)) {",
      "                    if (nxt == prt.at(crr)) continue;",
      "                    prt.at(nxt) = crr;",
      "                    f(f, nxt);",
      "                    sz.at(crr) += sz.at(nxt);",
      "                    auto& h = graph.at(crr).front();",
      "                    if (sz.at(h) < sz.at(nxt))",
      "                        { std::swap(h, nxt); }",
      "                }",
      "            };",
      "            dfs(dfs, root);",
      "",
      "            auto vm = 0;",
      "            auto const efs = [&](auto&& f, auto crr) -> void {",
      "                ord.at(vid.at(crr) = vm++) = crr;",
      "                for (auto nxt : graph.at(crr)) {",
      "                    if (nxt == prt.at(crr)) continue;",
      "                    head.at(nxt) = nxt == graph.at(crr).front() ? head.at(crr) : nxt;",
      "                    f(f, nxt);",
      "                }",
      "            };",
      "            efs(efs, root);",
      "        }",
      "",
      "        void insert (int x, int y) {",
      "            graph.at(x).push_back(y);",
      "            graph.at(y).push_back(x);",
      "        }",
      "",
      "        template < class RangeOp >",
      "        void for_each (",
      "            int x,",
      "            int y,",
      "            RangeOp const& op, // range-operation f([vid(x), vid(y)[)",
      "            bool skip // skip the top vertex",
      "        )",
      "        {",
      "            while (true) {",
      "                if (id(x) > id(y)) std::swap(x, y);",
      "                if (head.at(x) == head.at(y)) {",
      "                    op(id(x) + skip, id(y) + 1);",
      "                    return;",
      "                }",
      "                op(id(head.at(y)), id(y) + 1);",
      "                y = prt.at(head.at(y));",
      "            }",
      "        }",
      "};"
    ],
    "prefix": "heavy_light_decomposition"
  },
  "../include/insert_bit.hpp": {
    "body": [
      "template < class Value >",
      "Value insert_bit(Value x, int j, bool bit) {",
      "    Value low = x & (Value(1) << j) - 1;",
      "    return (x >> j << j + 1) + (Value(bit) << j) + low;",
      "}"
    ],
    "prefix": "insert_bit"
  },
  "../include/kmp_algorithm.hpp": {
    "body": [
      "auto make_failure_table (std::string w) -> std::vector<int>",
      "{",
      "    int n = w.length();",
      "    std::vector<int> ret(n + 1, -1);",
      "    int len = 0, pos = 1;",
      "    while (pos < n) {",
      "        if (w.at(pos) == w.at(len)) {",
      "            ret.at(pos) = ret.at(len);",
      "        } else {",
      "            ret.at(pos) = len;",
      "            len = ret.at(len);",
      "            while (len >= 0 && w.at(len) != w.at(pos)) len = ret.at(len);",
      "        }",
      "        len++, pos++;",
      "    }",
      "    ret.at(pos) = len;",
      "    return ret;",
      "}",
      "",
      "class kmp_algorithm",
      "{",
      "        std::string w;",
      "        std::vector<int> failure_table;",
      "",
      "    public:",
      "        kmp_algorithm()=default;",
      "",
      "        kmp_algorithm(const std::string& w) :",
      "            w(w),",
      "            failure_table(std::move(make_failure_table(this->w)))",
      "            {}",
      "",
      "        // Returns the starting positions of all the matches.",
      "        auto search(std::string s) -> std::vector<int>",
      "        {",
      "            std::vector<int> ret;",
      "            int pos_w = 0, pos_s = 0;",
      "            while (pos_s < (int)s.length()) {",
      "                if (s.at(pos_s) == w.at(pos_w)) {",
      "                    pos_s++, pos_w++;",
      "                    if (pos_w == (int)w.length()) {",
      "                        ret.push_back(pos_s - pos_w);",
      "                        pos_w = failure_table.at(pos_w);",
      "                    }",
      "                } else {",
      "                    pos_w = failure_table.at(pos_w);",
      "                    if (pos_w < 0) {",
      "                        pos_s++, pos_w++;",
      "                    }",
      "                }",
      "            }",
      "            return ret;",
      "        }",
      "};"
    ],
    "prefix": "kmp_algorithm"
  },
  "../include/lazy_segment_tree.hpp": {
    "body": [
      "",
      "template<",
      "    typename Value1,        typename Value2,",
      "    typename BinaryOp1, typename BinaryOp2, typename BinaryOp3,",
      "    typename UnaryOp1,    typename UnaryOp2",
      "    >",
      "class lazy_segment_tree {",
      "        struct node {",
      "            int id, l, r;",
      "            node(int id, int l, int r): id(id), l(l), r(r) {};",
      "            auto size() const { return r - l; }",
      "            auto left_child () const { assert(size() > 1); return node(id * 2,         l, (l + r) / 2); }",
      "            auto right_child() const { assert(size() > 1); return node(id * 2 + 1, (l + r) / 2, r); }",
      "        };",
      "",
      "        int                                     size;",
      "        int                                     n;",
      "        int                                     N;",
      "        BinaryOp1                         op1;",
      "        BinaryOp2                         op2;",
      "        BinaryOp3                         op3;",
      "        Value1                                id1;",
      "        Value2                                id2;",
      "        UnaryOp1                            expand;",
      "        UnaryOp2                            shrink;",
      "        std::vector< Value1 > table;",
      "        std::vector< Value2 > lazy;",
      "        node                                    initial_node;",
      "",
      "        auto& op1_eq(Value1& x, Value1 y) {return x = op1(x, y);}",
      "        auto& op2_eq(Value1& x, Value2 y) {return x = op2(x, y);}",
      "        auto& op3_eq(Value2& x, Value2 y) {return x = op3(x, y);}",
      "",
      "        void cal(int u)",
      "            { table.at(u) = op1(table.at(2 * u), table.at(2 * u + 1)); }",
      "",
      "        auto chain(int u) const {",
      "            auto ret = std::vector<int>{};",
      "            for (auto i = u; i > 0; i /= 2)",
      "                { ret.emplace_back(i); }",
      "            std::reverse(ret.begin(), ret.end());",
      "            return ret;",
      "        }",
      "",
      "        auto prop(int u) {",
      "            op2_eq(table.at(u), lazy.at(u));",
      "            if (u < n) {",
      "                op3_eq(lazy.at(2 * u),         shrink(lazy.at(u)));",
      "                op3_eq(lazy.at(2 * u + 1), shrink(lazy.at(u)));",
      "            }",
      "            lazy.at(u)         = id2;",
      "            return table.at(u);",
      "        }",
      "",
      "        auto query_base(int l, int r, Value2 val, const node& now) {",
      "            prop(now.id);",
      "            if (now.r <= l || r <= now.l) return id1;",
      "            else if (l <= now.l && now.r <= r) {",
      "                op3_eq(lazy.at(now.id), val);",
      "                return prop(now.id);",
      "            }",
      "            else {",
      "                auto ret =op1(",
      "                    query_base(l, r, shrink(val), now.left_child()),",
      "                    query_base(l, r, shrink(val), now.right_child())",
      "                );",
      "                cal(now.id);",
      "                return ret;",
      "            }",
      "        }",
      "",
      "    public:",
      "        lazy_segment_tree(",
      "            int                size,",
      "            BinaryOp1    op1,",
      "            BinaryOp2    op2,",
      "            BinaryOp3    op3,",
      "            Value1         id1,",
      "            Value2         id2,",
      "            UnaryOp1     expand,",
      "            UnaryOp2     shrink",
      "        ):",
      "            size                 (size),",
      "            n                        (std::pow(2, int(std::log2(size)) + 1)),",
      "            N                        (n * 2),",
      "            op1                    (op1),",
      "            op2                    (op2),",
      "            op3                    (op3),",
      "            id1                    (id1),",
      "            id2                    (id2),",
      "            expand             (expand),",
      "            shrink             (shrink),",
      "            table                (N, id1),",
      "            lazy                 (N, id2),",
      "            initial_node(1, 0, n)",
      "            {",
      "                std::mt19937 mt(std::random_device{}());",
      "                std::uniform_int_distribution< int > dist(-1'000'000, 1'000'000);",
      "                for (auto i = 0; i < 20; i++) {",
      "                    Value1 ex1 = dist(mt), ex1_ = dist(mt);",
      "                    Value2 ex2 = dist(mt);",
      "                    assert(op1(ex1, id1)             == ex1);",
      "                    assert(op2(ex1, id2)             == ex1);",
      "                    assert(op3(ex2, id2)             == ex2);",
      "                    assert(shrink(expand(ex2)) == ex2);",
      "                    assert(op2(op1(ex1, ex1_), expand(ex2)) == op1(op2(ex1, ex2), op2(ex1_, ex2)));",
      "                }",
      "            }",
      "",
      "        void build(const Value1 x)",
      "            { std::fill(table.begin(), table.end(), x); }",
      "",
      "        void build(const std::vector< Value1 >& v) {",
      "            assert(int(v.size()) <= n);",
      "            std::copy(v.begin(), v.end(), table.begin() + n);",
      "            for (int i = n - 1; i >= 0; i--)",
      "                { cal(i); }",
      "        }",
      "",
      "        void act(int l, int r, Value2 val) {",
      "            for (int i = 1; i < n; i *= 2)",
      "                { val = expand(val); }",
      "            query_base(l, r, val, initial_node);",
      "        }",
      "",
      "        auto query(int l, int r)",
      "            { return query_base(l, r, id2, initial_node); }",
      "",
      "        auto quiet_at(int i) const {",
      "            i += n;",
      "            auto actor = id2;",
      "            for (auto j : chain(i)) {",
      "                actor = shrink(actor);",
      "                actor = op3(actor, lazy.at(j));",
      "            }",
      "            return op2(table.at(i), actor);",
      "        }",
      "",
      "        auto quiet_collect() const {",
      "            auto ret = std::vector< Value1 >(size);",
      "            for (auto i = 0; i < size; i++)",
      "                { ret.at(i) = quiet_at(i); }",
      "            return ret;",
      "        }",
      "",
      "        auto at(int i) {",
      "            i += n;",
      "            for (auto j : chain(i))",
      "                { prop(j); }",
      "            return table.at(i);",
      "        }",
      "",
      "        auto collect() {",
      "            for (int i = 0; i < N; i++)",
      "                { prop(i); }",
      "            auto ret = std::vector< Value1 >(size);",
      "            for (auto i = 0; i < size; i++)",
      "                { ret.at(i) = table.at(i + n); }",
      "            return ret;",
      "        }",
      "};",
      "",
      "template< class Value1, class Value2, class BinaryOp1, class BinaryOp2, class BinaryOp3, class UnaryOp1, class UnaryOp2 >",
      "auto make_lazy_segment_tree(",
      "    int                size,",
      "    BinaryOp1    op1,",
      "    BinaryOp2    op2,",
      "    BinaryOp3    op3,",
      "    Value1         id1,",
      "    Value2         id2,",
      "    UnaryOp1     expand,",
      "    UnaryOp2     shrink",
      ") {",
      "    return lazy_segment_tree<Value1, Value2, BinaryOp1, BinaryOp2, BinaryOp3, UnaryOp1, UnaryOp2 >(",
      "        size, op1, op2, op3, id1, id2, std::move(expand), std::move(shrink));",
      "}",
      "",
      "template< class Value1, class Value2, class BinaryOp1, class BinaryOp2, class BinaryOp3 >",
      "auto make_lazy_segment_tree(",
      "    int                size,",
      "    BinaryOp1    op1,",
      "    BinaryOp2    op2,",
      "    BinaryOp3    op3,",
      "    Value1         id1,",
      "    Value2         id2",
      ") {",
      "    auto f = [](auto x){return x;};",
      "    return make_lazy_segment_tree(size, op1, op2, op3, id1, id2, f, f);",
      "}",
      "",
      "template < class Value >",
      "struct vending_machine {",
      "    Value i;",
      "    vending_machine(Value i) : i(i) {}",
      "    auto issue() { return i++; }",
      "};"
    ],
    "prefix": "lazy_segment_tree"
  },
  "../include/lcp_array.hpp": {
    "body": [
      "auto lcp_array(std::string const& s) {",
      "    int n = s.size();",
      "    std::vector< int > suf(n, 0), rank(n, 0);",
      "    std::iota(suf.begin(), suf.end(), 0);",
      "    for (auto i = 0; i < n; i++)",
      "        { rank.at(i) = s.at(i); }",
      "    auto comb = 1;",
      "    auto cmp = [&](auto i, auto j) {",
      "        if (rank.at(i) < rank.at(j)) return true;",
      "        if (rank.at(i) > rank.at(j)) return false;",
      "        if (n <= i + comb) return true;",
      "        if (n <= j + comb) return false;",
      "        return rank.at(i + comb) < rank.at(j + comb);",
      "    };",
      "    std::vector< int > buff(n);",
      "    for (; comb < n; comb *= 2) {",
      "        std::sort(suf.begin(), suf.end(), cmp);",
      "        buff.at(suf.front()) = 0;",
      "        for (auto i = 1; i < n; i++) {",
      "            buff.at(suf.at(i)) = buff.at(suf.at(i - 1)) + cmp(suf.at(i - 1), suf.at(i));",
      "        }",
      "        buff.swap(rank);",
      "    }",
      "    for (auto i = 0; i < n; i++)",
      "        { rank.at(suf.at(i)) = i; }",
      "",
      "    std::vector< int > ret(n);",
      "    auto now = 0;",
      "    for (auto i = 0; i < n; i++) {",
      "        auto x = rank.at(i);",
      "        if (x == n - 1) continue;",
      "        auto y = x + 1;",
      "        auto j = suf.at(y);",
      "        if (0 < now) now--;",
      "        for (; now + std::max(i, j) < n; now++) {",
      "            if (s.at(i + now) != s.at(j + now))",
      "                { break; }",
      "        }",
      "        ret.at(x) = now;",
      "    }",
      "    return ret;",
      "}",
      ""
    ],
    "prefix": "lcp_array"
  },
  "../include/link_cut_tree.hpp": {
    "body": [
      "struct link_cut_node {",
      "    link_cut_node * left, * right, *parent;",
      "    int size, value, minimum;",
      "",
      "    link_cut_node() {",
      "        left = nullptr;",
      "        right = nullptr;",
      "        parent = nullptr;",
      "        size = 1;",
      "    }",
      "",
      "    void rotate() {",
      "        link_cut_node *pp, *p, *c;",
      "        p = this->parent;",
      "        pp = p->parent;",
      "",
      "        if (p->left==this) {",
      "            c = this->right;",
      "            this->right = p;",
      "            p->left = c;",
      "        }",
      "        else {",
      "            c = this->left;",
      "            this->left = p;",
      "            p->right = c;",
      "        }",
      "",
      "        if (pp && pp->left==p) pp->left = this;",
      "        if (pp && pp->right==p) pp->right = this;",
      "        this->parent = pp;",
      "        p->parent = this;",
      "        if (c) c->parent = p;",
      "",
      "        p->update();",
      "        this->update();",
      "    }",
      "    int state() {",
      "        if (!parent) return 0;",
      "        if (parent->left==this) return 1;",
      "        if (parent->right==this) return -1;",
      "        return {};",
      "    }",
      "    void splay() {",
      "        while (this->state() != 0) {",
      "            if (this->parent->state()==0) {",
      "                this->rotate();",
      "            }",
      "            else if (this->state() == this->parent->state()) {",
      "                this->parent->rotate();",
      "                this->rotate();",
      "            } else {",
      "                this->rotate();",
      "                this->rotate();",
      "            }",
      "        }",
      "    }",
      "    void update() {",
      "        this->size = 1;",
      "        this->minimum = this->value;",
      "        if (this->left) {",
      "            this->size += this->left->size;",
      "            this->minimum = std::min(this->minimum, this->left->minimum);",
      "        }",
      "        if (this->right) {",
      "            this->size += this->right->size;",
      "            this->minimum = std::min(this->minimum, this->right->minimum);",
      "        }",
      "    }",
      "};",
      "",
      "link_cut_node * get(int ind, link_cut_node * root) {",
      "    link_cut_node * now = root;",
      "    while (true) {",
      "        int lsize = now->left ? now->left->size : 0;",
      "        if (ind < lsize) {",
      "            now = now->left;",
      "        }",
      "        if (ind == lsize) {",
      "            now->splay();",
      "            return now;",
      "        }",
      "        if (lsize < ind) {",
      "            now = now->right;",
      "            ind = ind - lsize - 1;",
      "        }",
      "    }",
      "}",
      "",
      "typedef link_cut_node lcn;",
      "",
      "lcn * merge(lcn *lroot, lcn* rroot) {",
      "    if (!lroot) return rroot;",
      "    if (!rroot) return lroot;",
      "    lroot = get(lroot->size - 1, lroot);",
      "    lroot->right = rroot;",
      "    rroot->parent = lroot;",
      "    lroot->update();",
      "    return lroot;",
      "}",
      "",
      "std::pair<lcn*, lcn*> split(int left_cnt, lcn* root) {",
      "    if (left_cnt == 0) return {nullptr, root};",
      "    if (left_cnt == root->size) return {root, nullptr};",
      "    root = get(left_cnt, root);",
      "    lcn * lroot, * rroot;",
      "    lroot = root->left;",
      "    rroot = root;",
      "    rroot->left = nullptr;",
      "    lroot->parent = nullptr;",
      "    rroot->update();",
      "    return {lroot, rroot};",
      "}",
      "",
      "lcn * insert(int ind, lcn * node, lcn * root) {",
      "    auto trees = split(ind, root);",
      "    lcn * lroot = trees.first;",
      "    lcn * rroot = trees.second;",
      "    return merge( merge(lroot, node), rroot);",
      "}",
      "",
      "std::pair<lcn*, lcn*> remove(int ind, lcn * root) {",
      "    root = get(ind, root);",
      "    lcn * lroot = root->left;",
      "    lcn * rroot = root->right;",
      "    if (lroot) lroot->parent = nullptr;",
      "    if (rroot) rroot->parent = nullptr;",
      "    root->left = nullptr;",
      "    root->right = nullptr;",
      "    root->update();",
      "    return {merge(lroot, rroot), root};",
      "}",
      "",
      "void access(lcn *v) {",
      "    while (true) {",
      "        v->splay();",
      "        v->right = nullptr;",
      "        v->update();",
      "        if (!v->parent) break;",
      "        v->parent->splay();",
      "        v->parent->right = v;",
      "        v->parent->update();",
      "    }",
      "}",
      "",
      "void link(lcn *c, lcn *p) {",
      "    c->parent = p;",
      "}",
      "",
      "void cut(lcn *c) {",
      "    assert(c);",
      "    access(c);",
      "    assert(c->left);",
      "    c->left->parent = nullptr;",
      "    c->left = nullptr;",
      "    c->update();",
      "}",
      "",
      "lcn *root(lcn *v) {",
      "    access(v);",
      "    lcn *now = v;",
      "    while (now->left) {",
      "        now = now->left;",
      "    }",
      "    return now;",
      "}"
    ],
    "prefix": "link_cut_tree"
  },
  "../include/lowest_common_ancestor.hpp": {
    "body": [
      "template < class Value >",
      "class lowest_common_ancestor {",
      "        struct edge {",
      "            int to; Value cost;",
      "            edge(int to, Value cost) : to(to), cost(cost){}",
      "        };",
      "        int n, lg, powlg;",
      "        std::vector< std::vector< edge > > graph;",
      "        std::vector< int >                                 depth;",
      "        std::vector< Value >                             w_depth;",
      "        std::vector< std::vector< int > >    table;",
      "        std::vector< int > &                             tail;",
      "",
      "    public:",
      "        using cost_type = Value;",
      "        lowest_common_ancestor(int n) :",
      "            n(n),",
      "            lg(std::log2(n)),",
      "            powlg(std::pow(2, lg)),",
      "            graph(n),",
      "            depth(n, 0),",
      "            w_depth(n, 0),",
      "            table(lg + 1, std::vector< int >(n)),",
      "            tail(table.back())",
      "            {}",
      "",
      "        void insert (int u, int v, Value cost = 1) {",
      "            graph.at(u).emplace_back(v, cost);",
      "            graph.at(v).emplace_back(u, cost);",
      "        }",
      "",
      "        void build (int root = 0) {",
      "            auto dfs = [&](auto f, int crr, int p) -> void {",
      "                tail.at(crr) = p;",
      "                for (auto const& e : graph.at(crr)) {",
      "                    if (e.to == p) continue;",
      "                    depth.at(e.to) = depth.at(crr) + 1;",
      "                    w_depth.at(e.to) = w_depth.at(crr) + e.cost;",
      "                    f(f, e.to, crr);",
      "                }",
      "            };",
      "            dfs(dfs, root, root);",
      "            for (int p = lg; p >= 1; p--) {",
      "                auto & crr = table.at(p);",
      "                auto & nxt = table.at(p - 1);",
      "                for (int i = 0; i < n; i++) {",
      "                    nxt.at(i) = crr.at(crr.at(i));",
      "                }",
      "            }",
      "        }",
      "",
      "        auto query(int u, int v) const -> int {",
      "            if (depth.at(u) < depth.at(v)) std::swap(u, v);",
      "            auto diff = depth.at(u) - depth.at(v);",
      "            if (diff > 0) {",
      "                int coeff = powlg;",
      "                for (auto const & row : table) {",
      "                    if (coeff < diff) {",
      "                        u = row.at(u);",
      "                        diff -= coeff;",
      "                    }",
      "                    coeff /= 2;",
      "                }",
      "                u = tail.at(u);",
      "                diff--;",
      "            }",
      "            assert(diff == 0);",
      "            assert(depth.at(u) == depth.at(v));",
      "            if (u == v) return u;",
      "            for (auto const & row : table) {",
      "                auto next_u = row.at(u);",
      "                auto next_v = row.at(v);",
      "                if (next_u != next_v) {",
      "                    u = next_u;",
      "                    v = next_v;",
      "                }",
      "            }",
      "            assert(u != v);",
      "            u = tail.at(u), v = tail.at(v), assert(u == v);",
      "            return u;",
      "        }",
      "",
      "        auto row_distance (int u, int v) const -> int {",
      "            return depth.at(u) + depth.at(v) - 2 * depth.at(query(u, v));",
      "        }",
      "",
      "        auto weighted_distance (int u, int v) const -> Value {",
      "            return w_depth.at(u) + w_depth.at(v) - 2 * w_depth.at(query(u, v));",
      "        }",
      "};"
    ],
    "prefix": "lowest_common_ancestor"
  },
  "../include/make_vector.hpp": {
    "body": [
      "template <typename T>",
      "auto make_vector_impl(size_t sz, T t) {return std::vector<T>(sz, t);}",
      "",
      "template <size_t N, typename T, typename U, std::enable_if_t<N == 1, std::nullptr_t> = nullptr>",
      "auto make_vector(size_t sz, U u) {return make_vector_impl(sz, T(u));}",
      "",
      "template <size_t N, typename T, std::enable_if_t<N == 1, std::nullptr_t> = nullptr>",
      "auto make_vector(size_t sz) {return std::vector<T>(sz);}",
      "",
      "template <size_t N, typename T, typename... Args, std::enable_if_t<N != 1, std::nullptr_t> = nullptr>",
      "auto make_vector(size_t a, Args... args) {return make_vector_impl(a, make_vector<N - 1, T>(args...));}",
      "",
      "template <typename T, typename Size_t>",
      "auto& at(T& t, Size_t i) {return t.at(i);}",
      "",
      "template <typename T, typename Size_t, typename... Args>",
      "auto& at(T& t, Size_t i, Args... args) {return at(t.at(i), args...);}"
    ],
    "prefix": "make_vector"
  },
  "../include/matrix.hpp": {
    "body": [
      "template < class Add, class Mul, class Value, class Sub, class Div >",
      "class matrix {",
      "        using vec_t = std::vector< Value >;",
      "        using mat_t = std::vector< vec_t >;",
      "        Mul mul_fn;",
      "        Add add_fn;",
      "        Value zero;",
      "        Div div_fn;",
      "        Sub sub_fn;",
      "        auto add_eq_fn(Value & x, Value y) const { x = add_fn(x, y); }",
      "        auto sub_eq_fn(Value & x, Value y) const { x = sub_fn(x, y); }",
      "        auto zero_matrix(std::size_t l, std::size_t m) const",
      "            { return mat_t(l, vec_t(m, zero)); }",
      "     auto& at(mat_t const& a, std::size_t i, std::size_t j) const",
      "         { return a.at(i).at(j); }",
      "     auto& at(mat_t & a, std::size_t i, std::size_t j) const",
      "         { return a.at(i).at(j); }",
      "",
      "    public:",
      "        matrix()=default;",
      "        matrix(",
      "            Add const& add_fn,",
      "            Mul const& mul_fn,",
      "            Value zero,",
      "            Sub const& sub_fn,",
      "            Div const& div_fn",
      "        ) :",
      "            add_fn(add_fn), mul_fn(mul_fn),",
      "            zero(zero),",
      "            sub_fn(sub_fn), div_fn(div_fn)",
      "            {}",
      "",
      "        auto apply(mat_t const & a, vec_t const & v) const {",
      "            std::size_t l = a.size(), m = a.front().size();",
      "            assert (m == v.size());",
      "            auto ret = vec_t(l, zero);",
      "            for (std::size_t i = 0; i < l; i++) {",
      "                assert(a.at(i).size() == m);",
      "                for (std::size_t j = 0; j < m; j++) {",
      "                    add_eq_fn(ret.at(i), mul_fn(at(a, i, j), v.at(j)));",
      "                }",
      "            }",
      "            return ret;",
      "        }",
      "",
      "        auto& add_eq(mat_t& a, mat_t const& b) const {",
      "            std::size_t l = a.size(), m = a.front().size();",
      "            assert(b.size() == l);",
      "            for (std::size_t i = 0; i < l; i++) {",
      "                assert(a.at(i).size() == m);",
      "                assert(b.at(i).size() == m);",
      "                for (std::size_t j = 0; j < m; j++) {",
      "                    add_eq_fn(at(a, i, j), at(b, i, j));",
      "                }",
      "            }",
      "            return a;",
      "        }",
      "",
      "        auto add(mat_t const& a, mat_t const& b) const {",
      "            auto c = a;",
      "            add_eq(c, b);",
      "            return c;",
      "        }",
      "",
      "        auto mul(mat_t const& a, mat_t const& b) const {",
      "            std::size_t l = a.size(), m = b.size(), n = b.front().size();",
      "            auto c = zero_matrix(l, n);",
      "            for (std::size_t i = 0; i < l; i++) {",
      "                assert(a.at(i).size() == m);",
      "                for (std::size_t j = 0; j < m; j++) {",
      "                    assert(b.at(j).size() == n);",
      "                    for (std::size_t k = 0; k < n; k++) {",
      "                        add_eq_fn(at(c, i, k), mul_fn(at(a, i, j), at(b, j, k)));",
      "                    }",
      "                }",
      "            }",
      "            return c;",
      "        }",
      "};",
      "constexpr auto not_implemented = [](auto const x, auto const) {",
      "    static_assert([]{ return false; }(), \"Call of a not-implemented function.\" );",
      "    return x;",
      "};",
      "using not_implemented_t = std::decay_t< decltype(not_implemented) >;",
      "template < class Mul, class Add, class Value, class Sub = not_implemented_t, class Div = not_implemented_t >",
      "auto make_matrix(",
      "    Add const& add_fn,",
      "    Mul const& mul_fn,",
      "    Value zero,",
      "    Sub const& sub_fn = not_implemented,",
      "    Div const& div_fn = not_implemented) {",
      "    return matrix< Add, Mul, Value, Sub, Div >(add_fn, mul_fn, zero, sub_fn, div_fn);",
      "}"
    ],
    "prefix": "matrix"
  },
  "../include/minimum_cost_flow.hpp": {
    "body": [
      "template <typename Flow, typename Cost>",
      "class minimum_cost_flow {",
      "        struct edge {",
      "            int to; Flow cap; Cost cost; int rev;",
      "            edge(int to, Flow cap, Cost cost, int rev): to(to), cap(cap), cost(cost), rev(rev){}",
      "        };",
      "",
      "        const int                                            n, source, sink;",
      "        std::vector<Cost>                            distance;",
      "        std::vector<std::vector<edge>> graph;",
      "        std::vector<int>                             ckd;",
      "",
      "        const Flow max_flow = std::numeric_limits<Flow>::max();",
      "        const Cost max_dist = std::numeric_limits<Cost>::max();",
      "",
      "        template <typename T, typename U>",
      "        auto cmn(T& a, U b) {if (a > b) {a = b; return true;} return false;}",
      "",
      "        void bellman_ford() {",
      "            distance.assign(n, max_dist);",
      "            distance.at(source) = 0;",
      "            for (int t = 0; t < n; t++) {",
      "                bool renewed = false;",
      "                for (int i = 0; i < n; i++) {",
      "                    for (auto const& e : graph.at(i)) {",
      "                        if (e.cap == 0) continue;",
      "                        auto crr = distance.at(i);",
      "                        if (crr == max_dist) continue;",
      "                        if (cmn(distance.at(e.to), crr + e.cost)) {",
      "                            renewed = true;",
      "                        }",
      "                    }",
      "                }",
      "                if (!renewed) break;",
      "            }",
      "        }",
      "",
      "        void dijkstra() {",
      "            distance.assign(n, max_dist);",
      "            auto que = std::priority_queue<",
      "                std::pair        < Cost, int >,",
      "                std::vector    < std::pair < Cost, int > >,",
      "                std::greater < std::pair < Cost, int >> >{};",
      "            que.emplace(0, source);",
      "            while (!que.empty()) {",
      "                auto pair = que.top(); que.pop();",
      "                auto crd = pair.first;",
      "                auto crr = pair.second;",
      "                if (!cmn(distance.at(crr), crd)) continue;",
      "                for (auto e : graph.at(crr)) {",
      "                    if (e.cap == 0) continue;",
      "                    auto nxd = crd + e.cost;",
      "                    if (distance.at(e.to) <= nxd) continue;",
      "                    que.emplace(nxd, e.to);",
      "                }",
      "            }",
      "        }",
      "",
      "        auto flush_impl(int crr, Flow f) {",
      "            if (ckd.at(crr)) return Flow(0);",
      "            ckd.at(crr) = true;",
      "            if (crr == sink) return f;",
      "            for (auto & e : graph.at(crr)) {",
      "                if (e.cap == 0) continue;",
      "                if (distance.at(crr) + e.cost != distance.at(e.to)) continue;",
      "                auto d = flush_impl(e.to, std::min(f, e.cap));",
      "                if (d > 0) {",
      "                    e.cap -= d;",
      "                    graph.at(e.to).at(e.rev).cap += d;",
      "                    return d;",
      "                }",
      "            }",
      "            return Flow(0);",
      "        }",
      "",
      "        auto flush() {",
      "            ckd.assign(n, false);",
      "            return flush_impl(source, max_flow);",
      "        }",
      "",
      "    public:",
      "        minimum_cost_flow(int n, int source, int sink) :",
      "            n(n), source(source), sink(sink), graph(n) {}",
      "",
      "        void insert(int u, int v, Flow cap, Cost cost) {",
      "            graph.at(u).emplace_back(v, cap, cost, graph.at(v).size());",
      "            graph.at(v).emplace_back(u, 0, -cost,    graph.at(u).size() - 1);",
      "        }",
      "",
      "        auto build(Flow required_flow) {",
      "            Cost ret = 0;",
      "            while (true) {",
      "                bellman_ford();",
      "                auto d = distance.at(sink);",
      "                if (distance.at(sink) == max_dist) break;",
      "                auto f = flush();",
      "                if (f >= required_flow) {",
      "                    ret += d * required_flow;",
      "                    return ret;",
      "                } else {",
      "                    ret += d * f;",
      "                    required_flow -= f;",
      "                }",
      "            }",
      "            return -1;",
      "        }",
      "};"
    ],
    "prefix": "minimum_cost_flow"
  },
  "../include/mint.hpp": {
    "body": [
      "template <typename T>",
      "T inverse(T a, T m) {",
      "    T u = 0, v = 1;",
      "    while (a != 0) {",
      "        T t = m / a;",
      "        m -= t * a; std::swap(a, m);",
      "        u -= t * v; std::swap(u, v);",
      "    }",
      "    assert(m == 1);",
      "    return u;",
      "}",
      "template <typename T>",
      "class modular {",
      "    private:",
      "        int value;",
      "    public:",
      "        constexpr modular() = default;",
      "        constexpr modular(const modular&) = default;",
      "        constexpr modular(modular&&) = default;",
      "        modular& operator=(const modular&) = default;",
      "        modular& operator=(modular&&) = default;",
      "",
      "        template <typename U>",
      "        modular (const U& x) {value = normalize(x);}",
      "",
      "        template <typename U>",
      "        static auto normalize(const U& x) {",
      "            int v = static_cast<int>(-mod() <= x && x < mod() ? x : x % mod());",
      "            if (v < 0) v += mod();",
      "            return v;",
      "        }",
      "",
      "        auto const& operator()() const { return value; }",
      "        template <typename U>",
      "        explicit operator U() const { return static_cast<U>(value); }",
      "        constexpr static auto mod() { return T::value; }",
      "",
      "        auto& operator+=(const modular& other) {",
      "            if ((value += other.value) >= mod()) value -= mod();",
      "            return *this;",
      "        }",
      "        auto& operator-=(const modular& other) {",
      "            if ((value -= other.value) < 0) value += mod();",
      "            return *this;",
      "        }",
      "        template <typename U>",
      "        auto& operator+=(const U& other) {return *this += modular(other); }",
      "        template <typename U>",
      "        auto& operator-=(const U& other) {return *this -= modular(other); }",
      "        auto operator-() const { return modular(-value); }",
      "        auto& operator++() {return *this += 1;}",
      "        auto& operator--() {return *this -= 1;}",
      "        auto    operator++(int) {modular result(*this); operator++(); return result;}",
      "        auto    operator--(int) {modular result(*this); operator--(); return result;}",
      "",
      "        template <typename U = T>",
      "        auto& operator*=(const modular& rhs) {",
      "            value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));",
      "            return *this;",
      "        }",
      "        auto& operator/=(const modular& other) {",
      "            return *this *= modular(inverse(other.value, mod()));",
      "        }",
      "};",
      "template <typename T> struct is_modular : std::false_type {};",
      "template <typename T> struct is_modular <modular<T>> : std::true_type{};",
      "template <typename T> constexpr bool is_modular_v = is_modular<T>::value;",
      "",
      "template <typename T> bool operator==(const modular<T>& lhs, const modular<T>& rhs) { return lhs() == rhs(); }",
      "template <typename T, typename U> bool operator==(const modular<T>& lhs, U rhs) { return lhs == modular<T>(rhs); }",
      "template <typename T, typename U> bool operator==(U lhs, const modular<T>& rhs) { return modular<T>(lhs) == rhs; }",
      "",
      "template <typename T> bool operator!=(const modular<T>& lhs, const modular<T>& rhs) { return !(lhs == rhs); }",
      "template <typename T, typename U> bool operator!=(const modular<T>& lhs, U rhs) { return !(lhs == rhs); }",
      "template <typename T, typename U> bool operator!=(U lhs, const modular<T>& rhs) { return !(lhs == rhs); }",
      "",
      "template <typename T> modular<T> operator+(const modular<T>& lhs, const modular<T>& rhs) { return modular<T>(lhs) += rhs; }",
      "template <typename T, typename U> modular<T> operator+(const modular<T>& lhs, U rhs) { return modular<T>(lhs) += rhs; }",
      "template <typename T, typename U> modular<T> operator+(U lhs, const modular<T>& rhs) { return modular<T>(lhs) += rhs; }",
      "",
      "template <typename T> modular<T> operator-(const modular<T>& lhs, const modular<T>& rhs) { return modular<T>(lhs) -= rhs; }",
      "template <typename T, typename U> modular<T> operator-(const modular<T>& lhs, U rhs) { return modular<T>(lhs) -= rhs; }",
      "template <typename T, typename U> modular<T> operator-(U lhs, const modular<T>& rhs) { return modular<T>(lhs) -= rhs; }",
      "",
      "template <typename T> modular<T> operator*(const modular<T>& lhs, const modular<T>& rhs) { return modular<T>(lhs) *= rhs; }",
      "template <typename T, typename U> modular<T> operator*(const modular<T>& lhs, U rhs) { return modular<T>(lhs) *= rhs; }",
      "template <typename T, typename U> modular<T> operator*(U lhs, const modular<T>& rhs) { return modular<T>(lhs) *= rhs; }",
      "",
      "template <typename T> modular<T> operator/(const modular<T>& lhs, const modular<T>& rhs) { return modular<T>(lhs) /= rhs; }",
      "template <typename T, typename U> modular<T> operator/(const modular<T>& lhs, U rhs) { return modular<T>(lhs) /= rhs; }",
      "template <typename T, typename U> modular<T> operator/(U lhs, const modular<T>& rhs) { return modular<T>(lhs) /= rhs; }",
      "",
      "template<typename T, typename U>",
      "modular<T> power (const modular<T>& a, U b) {",
      "    assert(b >= 0);",
      "    modular<T> x = a, ret = 1;",
      "    for (; b > 0; b /= 2) {",
      "        if (b % 2 == 1) ret *= x;",
      "        x *= x;",
      "    }",
      "    return ret;",
      "}",
      "",
      "template <typename T>",
      "std::string to_string(const modular<T>& a) {",
      "    return std::to_string(a());",
      "}",
      "template <typename T>",
      "auto operator<<(std::ostream& os, const T& a)",
      "    -> std::enable_if_t<is_modular_v<T>, std::ostream&>{",
      "        return os << a();",
      "    }",
      "template <typename T>",
      "auto operator>>(std::istream& is, T& a)",
      "    -> std::enable_if_t<is_modular_v<T>, std::istream&> {",
      "    long long x; is >> x;",
      "    a = T(x);",
      "    return is;",
      "}",
      "",
      "// using mod_type = int;",
      "",
      "// struct variable_mod { static mod_type value; };",
      "// mod_type variable_mod::value;",
      "// mod_type& mod = variable_mod::value;",
      "// using mint = modular< variable_mod >;",
      "",
      "// constexpr int mod = 1'000'000'007;",
      "// using mint = modular<std::integral_constant<std::decay_t<decltype(mod)>, mod>>;"
    ],
    "prefix": "mint"
  },
  "../include/mo.hpp": {
    "body": [
      "class mo_algorithm {",
      "        int n, q, block;",
      "        std::vector< std::tuple< int, int, int > > queries;",
      "",
      "    public:",
      "        mo_algorithm(int n, int q, int block) :",
      "            n(n),",
      "            q(q),",
      "            block(block),",
      "            queries(q)",
      "            {}",
      "",
      "        void set(int i, int l, int r)",
      "            { queries.at(i) = std::make_tuple(i, l, r); }",
      "",
      "        void build() {",
      "            std::sort(queries.begin(), queries.end(), [this](auto const& a, auto const& b){",
      "                int la, ra, lb, rb;",
      "                std::tie(std::ignore, la, ra) = a;",
      "                std::tie(std::ignore, lb, rb) = b;",
      "                auto qa = la / block, qb = lb / block;",
      "                return qa != qb",
      "                    ? qa < qb",
      "                    : qa % 2 == 1",
      "                    ? ra < rb",
      "                    : ra > rb;",
      "            });",
      "        }",
      "",
      "        template < class Append, class Remove, class Write >",
      "        void run(Append const & append, Remove const & remove, Write const & write) {",
      "            auto i = 0, j = 0;",
      "            for(auto const tuple : queries) {",
      "                int id, l, r; std::tie(id, l, r) = tuple;",
      "                while (l < i) append(--i);",
      "                while (j < r) append(j++);",
      "                while (i < l) remove(i++);",
      "                while (r < j) remove(--j);",
      "                write(id);",
      "            }",
      "        }",
      "};"
    ],
    "prefix": "mo"
  },
  "../include/polynominal.hpp": {
    "body": [
      "",
      "template < class Add, class Mul, class Value, class Sub, class Div >",
      "class polynominal {",
      "        using poly_type = std::vector< Value >;",
      "        Add add_fn;",
      "        Mul mul_fn;",
      "        Value zero;",
      "        Sub sub_fn;",
      "        Div div_fn;",
      "        auto& add_eq(Value & x, Value y) const { return x = add_fn(x, y); }",
      "        auto& sub_eq(Value & x, Value y) const { return x = sub_fn(x, y); }",
      "        auto& mul_eq(Value & x, Value y) const { return x = mul_fn(x, y); }",
      "",
      "    public:",
      "        polynominal()=default;",
      "        polynominal(",
      "            Add const& add_fn,",
      "            Mul const& mul_fn,",
      "            Value zero,",
      "            Sub const& sub_fn,",
      "            Div const& div_fn",
      "        ) :",
      "            add_fn(add_fn), mul_fn(mul_fn),",
      "            zero(zero),",
      "            sub_fn(sub_fn), div_fn(div_fn)",
      "            {}",
      "",
      "        auto& normalize(poly_type & a) const {",
      "            while (!a.empty() && a.back() == zero)",
      "                { a.pop_back(); }",
      "            return a;",
      "        }",
      "",
      "        auto normalized(poly_type a) const {",
      "            return normalize(a);",
      "        }",
      "",
      "        auto coeff(poly_type const & a, std::size_t i) const {",
      "            return i < a.size() ? a.at(i) : zero;",
      "        }",
      "",
      "        auto eval(poly_type const & a, Value x) const {",
      "            if (a.empty()) return zero;",
      "            auto ret = a.front();",
      "            auto p = x;",
      "            for (auto i = 1; i < (int)a.size(); i++) {",
      "                add_eq(ret, mul_fn(a.at(i), p));",
      "                mul_eq(p, x);",
      "            }",
      "            return ret;",
      "        }",
      "",
      "        auto add(poly_type const & a , poly_type const & b) const {",
      "            int l = a.size(), m = b.size();",
      "            int n = std::max(a.size(), b.size());",
      "            poly_type c(n, zero);",
      "            for (auto i = 0; i < n; i++) {",
      "                if (i < l) add_eq(c.at(i), a.at(i));",
      "                if (i < m) add_eq(c.at(i), b.at(i));",
      "            }",
      "            return normalize(c);",
      "        }",
      "        auto mul(poly_type a, poly_type b) const {",
      "            normalize(a), normalize(b);",
      "            int l = a.size(), m = b.size();",
      "            int n = l + m - 1;",
      "            if (n <= 0) return poly_type{};",
      "            poly_type c(n, zero);",
      "            for (auto i = 0; i < l; i++) {",
      "                for (auto j = 0; j < m; j++) {",
      "                    add_eq(c.at(i + j), mul_fn(a.at(i), b.at(j)));",
      "                }",
      "            }",
      "            return normalize(c);",
      "        }",
      "        auto sub(poly_type const & a , poly_type const & b) const {",
      "            int l = a.size(), m = b.size();",
      "            int n = std::max(a.size(), b.size());",
      "            poly_type c(n, zero);",
      "            for (auto i = 0; i < n; i++) {",
      "                if (i < l) add_eq(c.at(i), a.at(i));",
      "                if (i < m) sub_eq(c.at(i), b.at(i));",
      "            }",
      "            return normalize(c);",
      "        }",
      "        auto div(poly_type a, poly_type b) const {",
      "            normalize(a), normalize(b);",
      "            assert(!b.empty());",
      "            int l = a.size(), m = b.size();",
      "            if (l < m)",
      "                { return std::make_pair(poly_type{}, a); }",
      "            poly_type q(l - m + 1, zero);",
      "            while (m <= l) {",
      "                auto d = l - m;",
      "                auto x = div_fn(a.back(), b.back());",
      "                q.at(d) = x;",
      "                for (auto i = 0; i < m; i++)",
      "                    { sub_eq(a.at(i + d), x * b.at(i)); }",
      "                normalize(a);",
      "                assert((int)a.size() < l);",
      "                l = a.size();",
      "            }",
      "            assert(a.size() < b.size());",
      "            return std::make_pair(q, normalize(a));",
      "        }",
      "};",
      "auto not_implemented = [](auto const x, auto const) {",
      "    static_assert([]{ return false; }(), \"Call to a not-implemented function.\" );",
      "    return x;",
      "};",
      "using not_implemented_t = std::decay_t< decltype(not_implemented) >;",
      "template < class Mul, class Add, class Value, class Sub = not_implemented_t, class Div = not_implemented_t >",
      "auto make_polynominal(",
      "    Add const& add_fn,",
      "    Mul const& mul_fn,",
      "    Value zero,",
      "    Sub const& sub_fn = not_implemented,",
      "    Div const& div_fn = not_implemented) {",
      "    return polynominal< Add, Mul, Value, Sub, Div >(add_fn, mul_fn, zero, sub_fn, div_fn);",
      "}"
    ],
    "prefix": "polynominal"
  },
  "../include/print_grid.hpp": {
    "body": [
      "template < typename Grid >",
      "auto print_grid(Grid const& grid) {",
      "    int h = grid.size();",
      "    int w = grid.front().size();",
      "    for (auto i = 0; i < h; i++) {",
      "        for(auto j = 0; j < w; j++) {",
      "            std::cout << (grid.at(i).at(j) ? '#' : '.');",
      "        }",
      "        std::cout << std::endl;",
      "    }",
      "}"
    ],
    "prefix": "print_grid"
  },
  "../include/project.hpp": {
    "body": [
      "template < std::size_t I, typename Container,",
      "    typename Value = typename std::tuple_element_t< I, typename Container::value_type >>",
      "inline auto project(Container const& v) {",
      "    std::vector< Value > ret(v.size());",
      "    std::transform(v.begin(), v.end(), ret.begin(), [](auto&& t){ return std::get< I >(t); });",
      "    return ret;",
      "}"
    ],
    "prefix": "project"
  },
  "../include/quick_find.hpp": {
    "body": [
      "class quick_find",
      "{",
      "    int                                                     n;",
      "    std::vector<int>                            prt;",
      "    std::vector<std::vector<int>> child;",
      "",
      "public:",
      "    quick_find (int n) : n(n), prt(n), child(n)",
      "    {",
      "        std::iota(prt.begin(), prt.end(), 0);",
      "        for (int i = 0; i < n; i++) {",
      "            child.at(i) = {i};",
      "        }",
      "    }",
      "",
      "    auto collect ()                         const {return prt;}",
      "    bool is_root (int x)                const {return find(x) == x;}",
      "    int    size        (int x)                const {return child.at(prt.at(x)).size();}",
      "    bool same        (int x, int y) const {return find(x) == find(y);}",
      "    int    find        (int x)                const {return prt.at(x);}",
      "",
      "    // Returns `true` if x and y are newly connected.",
      "    bool unite     (int x, int y)",
      "    {",
      "        if ((x = find(x)) == (y = find(y))) return false;",
      "        if (size(x) > size(y)) std::swap(x, y);",
      "        for (auto z : child.at(x))",
      "        {",
      "            prt.at(z) = y;",
      "            child.at(y).push_back(z);",
      "        }",
      "        decltype(child)::value_type{}.swap(child.at(x));",
      "        return true;",
      "    }",
      "};"
    ],
    "prefix": "quick_find"
  },
  "../include/remove_bit.hpp": {
    "body": [
      "template < class Value >",
      "Value remove_bit(Value x, int j) {",
      "    Value low = x & (Value(1) << j) - 1;",
      "    return (x >> j + 1 << j) + low;",
      "}"
    ],
    "prefix": "remove_bit"
  },
  "../include/remove_common_header.hpp": {
    "body": [
      "template < class Value >",
      "auto remove_common_header(Value x, Value y) {",
      "    auto mask = std::numeric_limits< Value >::max() >> (__builtin_clzll(x ^ y) - 1);",
      "    return std::make_tuple(x & mask, y & mask, mask);",
      "}"
    ],
    "prefix": "remove_common_header"
  },
  "../include/rolling_hash.hpp": {
    "body": [
      "class rolling_hash {",
      "    public:",
      "        using value_type         = long long;",
      "        using container_type = std::vector<value_type>;",
      "",
      "    private:",
      "        static constexpr size_t    mod_num = 2;",
      "        static constexpr std::array<value_type, mod_num> mods = {",
      "                1'000'000'007,",
      "                1'000'000'009",
      "            };",
      "        static constexpr value_type base        = 9973;",
      "",
      "        size_t                                             n;",
      "        std::vector<container_type>    hash_table;",
      "        std::vector<container_type>    pow_table;",
      "",
      "        auto inverse(value_type a, value_type m) const -> value_type {",
      "            value_type u = 0, v = 1;",
      "            while (a != 0) {",
      "                value_type t = m / a;",
      "                m -= t * a; std::swap(a, m);",
      "                u -= t * v; std::swap(u, v);",
      "            }",
      "            assert(m == 1);",
      "            return u;",
      "        }",
      "",
      "    public:",
      "        // ctor, dtor",
      "        explicit rolling_hash() = default;",
      "        explicit rolling_hash(const rolling_hash&) = default;",
      "        explicit rolling_hash(rolling_hash&&) = default;",
      "        rolling_hash& operator=(const rolling_hash&) = default;",
      "        rolling_hash& operator=(rolling_hash&&) = default;",
      "        ~rolling_hash() = default;",
      "",
      "        rolling_hash(const std::string s) :",
      "            n(s.length()),",
      "            hash_table(mod_num, container_type(n + 1, 0)),",
      "            pow_table (mod_num, container_type(n + 1, 1))",
      "            {",
      "                for (size_t i = 0; i < mod_num; i++) {",
      "                    auto    mod = mods.at(i);",
      "                    auto& tab = hash_table.at(i);",
      "                    auto& pab = pow_table.at(i);",
      "                    for (size_t j = 0; j < n; j++) {",
      "                        tab.at(j + 1) = (tab.at(j) * base + s.at(j)) % mod;",
      "                        pab.at(j + 1) = (pab.at(j) * base) % mod;",
      "                    }",
      "                }",
      "            }",
      "",
      "        // observers",
      "        auto hash(size_t l, size_t r) const {",
      "            auto ret = std::vector<value_type>{};",
      "            for (size_t i = 0; i < mod_num; i++) {",
      "                const auto    mod = mods.at(i);",
      "                const auto& tab = hash_table.at(i);",
      "                const auto& pab = pow_table.at(i);",
      "                auto &            buf = ret.at(i);",
      "                buf = (tab.at(r) - tab.at(l)) * inverse(pab.at(l), mod) % mod;",
      "            }",
      "            return ret;",
      "        }",
      "};"
    ],
    "prefix": "rolling_hash"
  },
  "../include/run_length.hpp": {
    "body": [
      "template < class Container, class Value = typename Container::value_type >",
      "auto run_length(Container const& v) {",
      "    auto n = (int)v.size();",
      "    if (n == 0)",
      "        { return std::vector< std::pair< Value, int > >{}; }",
      "    auto pos = std::vector< int >{};",
      "    for (auto i = 1; i < n; i++) {",
      "        if (v.at(i - 1) != v.at(i))",
      "            { pos.emplace_back(i); }",
      "    }",
      "    pos.emplace_back(n);",
      "    auto m = (int)pos.size();",
      "    auto len = std::vector< int >(m);",
      "    std::adjacent_difference(pos.begin(), pos.end(), len.begin());",
      "    auto ret = std::vector< std::pair< Value, int > >(m);",
      "    for (auto i = 0; i != m; i++)",
      "        { ret.at(i) = {v.at(pos.at(i) - 1), len.at(i)}; }",
      "    return ret;",
      "}"
    ],
    "prefix": "run_length"
  },
  "../include/segment_tree.hpp": {
    "body": [
      "template <class Seg, class SegPtr>",
      "struct segment_tree_entry;",
      "",
      "template <class Seg, class SegPtr, class Pointer, class Reference>",
      "struct segment_tree_iterator;",
      "",
      "template <typename Value, typename BinaryOp>",
      "class segment_tree {",
      "public:",
      "    using value_type = Value;",
      "    using this_type = segment_tree<Value, BinaryOp>;",
      "    using entry_type = segment_tree_entry<this_type, this_type*>;",
      "    using const_entry_type = segment_tree_entry<this_type, this_type const*>;",
      "    using iterator = segment_tree_iterator<this_type, this_type*, value_type*, value_type&>;",
      "    using const_iterator = segment_tree_iterator<this_type, this_type const*, value_type const*, value_type const&>;",
      "",
      "friend class segment_tree_entry<this_type, this_type*>;",
      "friend class segment_tree_entry<this_type, this_type const*>;",
      "",
      "private:",
      "    int                                    sz, n, N;",
      "    BinaryOp                         op;",
      "    Value                                id;",
      "    std::vector< Value > table;",
      "",
      "    auto& op_assign(Value& x, Value y) const",
      "        { return x = op(x, y); }",
      "    void merge(int u)",
      "        { table.at(u) = op(table.at(2 * u), table.at(2 * u + 1)); }",
      "",
      "public:",
      "    segment_tree(int sz, BinaryOp op, Value id):",
      "        sz(sz), n(std::pow(2, int(std::log2(2*sz-1)))), N(n * 2), op(op), id(id), table (N, id) {}",
      "",
      "    iterator begin()",
      "        { return iterator(this, 0); }",
      "",
      "    iterator end()",
      "        { return iterator(this, sz); }",
      "",
      "    const_iterator begin() const",
      "        { return const_iterator(this, 0); }",
      "",
      "    const_iterator end() const",
      "        { return const_iterator(this, sz); }",
      "",
      "    auto at(std::size_t i)",
      "        { return entry_type(this, i); }",
      "",
      "    auto at(std::size_t i) const",
      "        { return table.at(n + i); }",
      "",
      "    auto& lazy_at(std::size_t i)",
      "        { return table.at(n + i); }",
      "",
      "    auto& lazy_at(std::size_t i) const",
      "        { return table.at(n + i); }",
      "",
      "    auto collect() const {",
      "        auto ret = std::vector<Value>(sz);",
      "        for (auto i = 0; i < sz; i++)",
      "            { ret.at(i) = at(i); }",
      "        return ret;",
      "    }",
      "",
      "    auto query(int l, int r) const {",
      "        auto const dfs = [&](auto&& f, int l, int r, int k, int L, int R) -> Value {",
      "            return l <= L && R <= r ? table.at(k)",
      "                : R <= l || r <= L ? id",
      "                : op(f(f, l, r, 2*k, L, (L+R)/2), f(f, l, r, 2*k+1, (L+R)/2, R));",
      "        };",
      "        return dfs(dfs, l, r, 1, 0, n);",
      "    }",
      "",
      "    void build()",
      "        { for (auto i = n - 1; i > 0; i--) merge(i); }",
      "};",
      "",
      "template <class Seg, class SegPtr>",
      "class segment_tree_entry {",
      "    using value_type = typename Seg::value_type;",
      "    SegPtr seg;",
      "    std::size_t i;",
      "",
      "    auto& get() {",
      "        return seg->table.at(seg->n+i);",
      "    }",
      "",
      "    void build_oneline() {",
      "        for (int j=(i+seg->n)/2; j>0; j/=2) {",
      "            seg->merge(j);",
      "        }",
      "    }",
      "",
      "public:",
      "    segment_tree_entry(SegPtr seg, std::size_t i) : seg(seg), i(i) {}",
      "",
      "    operator value_type() {",
      "        return seg->table.at(seg->n + i);",
      "    }",
      "    void operator=(value_type x) {",
      "        get() = x;",
      "        build_oneline();",
      "    }",
      "    void operator++() {",
      "        get()++;",
      "        build_oneline();",
      "    }",
      "    void operator--() {",
      "        get()--;",
      "        build_oneline();",
      "    }",
      "    void operator+=(value_type x) {",
      "        get() += x;",
      "        build_oneline();",
      "    }",
      "    void operator-=(value_type x) {",
      "        get() -= x;",
      "        build_oneline();",
      "    }",
      "    void operator*=(value_type x) {",
      "        get() *= x;",
      "        build_oneline();",
      "    }",
      "    void operator/=(value_type x) {",
      "        get() /= x;",
      "        build_oneline();",
      "    }",
      "};",
      "",
      "template <class Seg, class SegPtr, class Pointer, class Reference>",
      "class segment_tree_iterator {",
      "    using this_type = segment_tree_iterator<Seg, SegPtr, Pointer, Reference>;",
      "    using value_type = typename Seg::value_type;",
      "    using pointer = Pointer;",
      "    using reference = Reference;",
      "",
      "    template <class Seg_, class SegPtr_, class Pointer_, class Reference_>",
      "    friend bool operator!=(segment_tree_iterator<Seg_, SegPtr_, Pointer_, Reference_>, segment_tree_iterator<Seg_, SegPtr_, Pointer_, Reference_>);",
      "",
      "    SegPtr seg;",
      "    std::size_t i;",
      "",
      "public:",
      "    segment_tree_iterator(SegPtr seg, std::size_t i) : seg(seg), i(i) {}",
      "",
      "    this_type& operator++(){ i++; return *this; }",
      "    this_type    operator++(int){ auto old = *this; ++i; return old; }",
      "    pointer operator->(){ return &seg->at(i); }",
      "    value_type operator*(){ return seg->at(i); }",
      "};",
      "",
      "template <class Seg, class SegPtr, class Pointer, class Reference>",
      "bool operator!=(segment_tree_iterator<Seg, SegPtr, Pointer, Reference> a, segment_tree_iterator<Seg, SegPtr, Pointer, Reference> b) {",
      "    return a.i != b.i;",
      "}",
      "",
      "template<typename Value, typename BinaryOp>",
      "auto make_segment_tree(int sz, BinaryOp const& op, Value id)",
      "    { return segment_tree<Value, BinaryOp>(sz, op, id); }"
    ],
    "prefix": "segment_tree"
  },
  "../include/sliding_minimum.hpp": {
    "body": [
      "template < typename Value, typename Cmp = std::less< Value > >",
      "class sliding_minimum {",
      "        std::deque< Value > que;",
      "        void pop_to(int target) {",
      "            assert(target <= right);",
      "            while (left < target)",
      "                { shrink(); }",
      "        }",
      "        void push_to(int target) {",
      "            assert(target <= n);",
      "            while (right < target)",
      "                { extend(); }",
      "        }",
      "    public:",
      "        int n, left, right;",
      "        std::vector< Value > v;",
      "        Cmp                                    cmp;",
      "        sliding_minimum(std::vector< Value > const& v, Cmp const & cmp) :",
      "            n(v.size()), left(0), right(0), v(v), cmp(cmp)",
      "            {}",
      "        auto get_left_index()    const { return left; }",
      "        auto get_right_index() const { return right; }",
      "        auto query_index() const",
      "            { assert(!que.empty()); return que.front(); }",
      "        auto query() const",
      "            { return v.at(query_index()); }",
      "        void shrink() {",
      "            if (que.front() == left++)",
      "                { que.pop_front(); }",
      "            assert(left <= right);",
      "        }",
      "        void extend() {",
      "            while (!que.empty() && !cmp(v.at(que.back()), v.at(right)))",
      "                { que.pop_back(); }",
      "            que.push_back(right++);",
      "            assert(right <= n);",
      "        }",
      "        void slide()",
      "            { shrink(); extend(); }",
      "        void advance_to(int l, int r)",
      "            { push_to(r); pop_to(l); }",
      "};",
      "template < typename Value, typename Cmp = std::less< Value > >",
      "auto make_sliding_minimum(std::vector< Value > const& v, Cmp const & cmp)",
      "    { return sliding_minimum< Value, Cmp >(v, cmp); }"
    ],
    "prefix": "sliding_minimum"
  },
  "../include/sparse_table.hpp": {
    "body": [
      "template < class Value, class Op >",
      "class sparse_table {",
      "        int n, ht;",
      "        Op op;",
      "        std::vector< std::vector< Value > > table;",
      "",
      "    public:",
      "        sparse_table()=default;",
      "        sparse_table(std::vector< Value > const & a, Op const & op) :",
      "            n(a.size()),",
      "            ht(std::log2(n) + 1),",
      "            op(op),",
      "            table([this, &a, &op]{",
      "                std::vector< std::vector< Value > > table(ht, a);",
      "                auto block = 1;",
      "                for (auto & v : table) {",
      "                    auto forward = false;",
      "                    auto l = 0, r = block;",
      "                    for (; forward || r <= n; l += block, r += block, forward ^= 1) {",
      "                        if (forward)",
      "                            { std::partial_sum(v.begin() + l, v.begin() + std::min(r, n), v.begin() + l, op);}",
      "                        else",
      "                            { std::partial_sum(v.rbegin() + n - r, v.rbegin() + n - l, v.rbegin() + n - r, op); }",
      "                    }",
      "                    block *= 2;",
      "                }",
      "                return table;",
      "            }())",
      "            {}",
      "",
      "        auto query(int l, int r) const {",
      "            r--;",
      "            if (l == r) return table.front().at(l);",
      "            auto const & v = table.at(std::log2(l ^ r));",
      "            return op(v.at(l), v.at(r));",
      "        }",
      "};",
      "template < class Value, class Op >",
      "auto make_sparse_table(std::vector< Value > const & a, Op const & op)",
      "    { return sparse_table< Value, Op>(a, op); }"
    ],
    "prefix": "sparse_table"
  },
  "../include/splay.hpp": {
    "body": [
      "struct splay_op {",
      "    static int invoke(int x, int y) { return x + y; }",
      "};",
      "",
      "struct splay_node {",
      "    splay_node * left, * right, *parent;",
      "    int size, value, cum;",
      "",
      "    splay_node() {",
      "        left = nullptr;",
      "        right = nullptr;",
      "        parent = nullptr;",
      "        size = 1;",
      "    }",
      "",
      "    void rotate() {",
      "        splay_node *pp, *p, *c;",
      "        p = this->parent;",
      "        pp = p->parent;",
      "",
      "        if (p->left==this) {",
      "            c = this->right;",
      "            this->right = p;",
      "            p->left = c;",
      "        }",
      "        else {",
      "            c = this->left;",
      "            this->left = p;",
      "            p->right = c;",
      "        }",
      "",
      "        if (pp && pp->left==p) pp->left = this;",
      "        if (pp && pp->right==p) pp->right = this;",
      "        this->parent = pp;",
      "        p->parent = this;",
      "        if (c) c->parent = p;",
      "",
      "        p->update();",
      "        this->update();",
      "    }",
      "    int state() {",
      "        if (!parent) return 0;",
      "        if (parent->left==this) return 1;",
      "        if (parent->right==this) return -1;",
      "        return {};",
      "    }",
      "    void splay() {",
      "        while (this->state() != 0) {",
      "            if (this->parent->state()==0) {",
      "                this->rotate();",
      "            }",
      "            else if (this->state() == this->parent->state()) {",
      "                this->parent->rotate();",
      "                this->rotate();",
      "            } else {",
      "                this->rotate();",
      "                this->rotate();",
      "            }",
      "        }",
      "    }",
      "    void update() {",
      "        this->size = 1;",
      "        this->cum = this->value;",
      "        if (this->left) {",
      "            this->size += this->left->size;",
      "            this->cum = splay_op::invoke(this->cum, this->left->cum);",
      "        }",
      "        if (this->right) {",
      "            this->size += this->right->size;",
      "            this->cum = splay_op::invoke(this->cum, this->right->cum);",
      "        }",
      "    }",
      "};",
      "",
      "splay_node * get(int ind, splay_node * root) {",
      "    splay_node * now = root;",
      "    while (true) {",
      "        int lsize = now->left ? now->left->size : 0;",
      "        if (ind < lsize) {",
      "            now = now->left;",
      "        }",
      "        if (ind == lsize) {",
      "            now->splay();",
      "            return now;",
      "        }",
      "        if (lsize < ind) {",
      "            now = now->right;",
      "            ind = ind - lsize - 1;",
      "        }",
      "    }",
      "}",
      "",
      "typedef splay_node sn;",
      "",
      "sn * merge(sn *lroot, sn* rroot) {",
      "    if (!lroot) return rroot;",
      "    if (!rroot) return lroot;",
      "    lroot = get(lroot->size - 1, lroot);",
      "    lroot->right = rroot;",
      "    rroot->parent = lroot;",
      "    lroot->update();",
      "    return lroot;",
      "}",
      "",
      "std::pair<sn*, sn*> split(int left_cnt, sn* root) {",
      "    if (left_cnt == 0) return {nullptr, root};",
      "    if (left_cnt == root->size) return {root, nullptr};",
      "    root = get(left_cnt, root);",
      "    sn * lroot, * rroot;",
      "    lroot = root->left;",
      "    rroot = root;",
      "    rroot->left = nullptr;",
      "    lroot->parent = nullptr;",
      "    rroot->update();",
      "    return {lroot, rroot};",
      "}",
      "",
      "sn * insert(int ind, sn * node, sn * root) {",
      "    auto trees = split(ind, root);",
      "    sn * lroot = trees.first;",
      "    sn * rroot = trees.second;",
      "    return merge( merge(lroot, node), rroot);",
      "}",
      "",
      "std::pair<sn*, sn*> remove(int ind, sn * root) {",
      "    root = get(ind, root);",
      "    sn * lroot = root->left;",
      "    sn * rroot = root->right;",
      "    if (lroot) lroot->parent = nullptr;",
      "    if (rroot) rroot->parent = nullptr;",
      "    root->left = nullptr;",
      "    root->right = nullptr;",
      "    root->update();",
      "    return {merge(lroot, rroot), root};",
      "}"
    ],
    "prefix": "splay"
  },
  "../include/sqrt_decomposition.hpp": {
    "body": [
      "class sqrt_decomposition {",
      "    public:",
      "        int n, block_size, block_number;",
      "",
      "        sqrt_decomposition(int n, int block_size) :",
      "            n(n),",
      "            block_size(block_size),",
      "            block_number((n + block_size - 1) / block_size)",
      "            {}",
      "",
      "        auto get_block_size()     const { return block_size;     }",
      "        auto get_block_number() const { return block_number; }",
      "",
      "        template < class Append, class Stamp >",
      "        void query(int l, int r, Append const & append, Stamp const & stamp) {",
      "            while (l % block_size && l < r) {",
      "                append(l, l / block_size);",
      "                l++;",
      "            }",
      "            while (r % block_size && l < r) {",
      "                r--;",
      "                append(r, r / block_size);",
      "            }",
      "            for (auto j = l / block_size; j < r / block_size; j++) {",
      "                stamp(j);",
      "            }",
      "        }",
      "};"
    ],
    "prefix": "sqrt_decomposition"
  },
  "../include/square_matrix.hpp": {
    "body": [
      "template <int N, typename Semiring>",
      "class square_matrix",
      "{",
      "<tab>template <int N_, typename Semiring_>",
      "<tab>friend bool operator==(const square_matrix<N_, Semiring_>&, const square_matrix<N_, Semiring_>&);",
      "",
      "<tab>public:",
      "<tab><tab>using this_type<tab> = square_matrix<N, Semiring>;",
      "<tab><tab>using value_type<tab>= typename Semiring::type;",
      "<tab><tab>using matrix_type = std::array<std::array<value_type, N>,<tab>N>;",
      "",
      "<tab>private:",
      "<tab><tab>matrix_type storage;",
      "",
      "<tab>public:",
      "<tab><tab>constexpr square_matrix() = default;",
      "<tab><tab>constexpr square_matrix(const square_matrix&) = default;",
      "<tab><tab>constexpr square_matrix(square_matrix&&) = default;",
      "<tab><tab>square_matrix& operator=(const square_matrix&) = default;",
      "<tab><tab>square_matrix& operator=(square_matrix&&) = default;",
      "",
      "<tab><tab>constexpr square_matrix(const matrix_type& x) : storage(x){}",
      "<tab><tab>constexpr square_matrix",
      "<tab><tab>(",
      "<tab><tab><tab>std::initializer_list<std::initializer_list<value_type>> list",
      "<tab><tab>)",
      "<tab><tab>{",
      "<tab><tab><tab>int i = 0;",
      "<tab><tab><tab>for (auto &row: list)",
      "<tab><tab><tab>{",
      "<tab><tab><tab><tab>int j = 0;",
      "<tab><tab><tab><tab>for (auto val : row)",
      "<tab><tab><tab><tab>{",
      "<tab><tab><tab><tab><tab>storage.at(i).at(j) = val;",
      "<tab><tab><tab><tab><tab>j++;",
      "<tab><tab><tab><tab>}",
      "<tab><tab><tab><tab>i++;",
      "<tab><tab><tab>}",
      "<tab><tab>}",
      "",
      "<tab><tab>// Special Elements.",
      "<tab><tab>static auto zero_matrix()",
      "<tab><tab>{",
      "<tab><tab><tab>auto ret = this_type{};",
      "<tab><tab><tab>for (int i = 0; i < N; i++)",
      "<tab><tab><tab>{",
      "<tab><tab><tab><tab>for (int j = 0; j < N; j++)",
      "<tab><tab><tab><tab>{",
      "<tab><tab><tab><tab><tab>ret.at(i, j) = Semiring::add_id();",
      "<tab><tab><tab><tab>}",
      "<tab><tab><tab>}",
      "<tab><tab><tab>return ret;",
      "<tab><tab>}",
      "",
      "<tab><tab>static auto identity_matrix()",
      "<tab><tab>{",
      "<tab><tab><tab>auto ret = this_type{};",
      "<tab><tab><tab>for (int i = 0; i < N; i++)",
      "<tab><tab><tab>{",
      "<tab><tab><tab><tab>for (int j = 0; j < N; j++)",
      "<tab><tab><tab><tab>{",
      "<tab><tab><tab><tab><tab>ret.at(i, j) = i == j",
      "<tab><tab><tab><tab><tab><tab>? Semiring::mul_id()",
      "<tab><tab><tab><tab><tab><tab>: Semiring::add_id();",
      "<tab><tab><tab><tab>}",
      "<tab><tab><tab>}",
      "<tab><tab><tab>return ret;",
      "<tab><tab>}",
      "",
      "<tab><tab>// Accessors.",
      "<tab><tab>auto& at(int i, int j)<tab><tab><tab> {return storage.at(i).at(j);}",
      "<tab><tab>auto& at(int i, int j) const {return storage.at(i).at(j);}",
      "",
      "<tab><tab>// Operaters.",
      "<tab><tab>auto& operator+=(const square_matrix& other)",
      "<tab><tab>{",
      "<tab><tab><tab>auto ret = zero_matrix();",
      "<tab><tab><tab>for (int i = 0; i < N; i++)",
      "<tab><tab><tab>{",
      "<tab><tab><tab><tab>for (int j = 0; j < N; j++)",
      "<tab><tab><tab><tab>{",
      "<tab><tab><tab><tab><tab>Semiring::add_eq(at(i,j), other.at(i, j));",
      "<tab><tab><tab><tab>}",
      "<tab><tab><tab>}",
      "<tab><tab><tab>return *this;",
      "<tab><tab>}",
      "",
      "<tab><tab>auto& operator*=(const square_matrix& other)",
      "<tab><tab>{",
      "<tab><tab><tab>auto ret = zero_matrix();",
      "<tab><tab><tab>for (int i = 0; i < N; i++)",
      "<tab><tab><tab>{",
      "<tab><tab><tab><tab>for (int j = 0; j < N; j++)",
      "<tab><tab><tab><tab>{",
      "<tab><tab><tab><tab><tab>for (int k = 0; k < N; k++)",
      "<tab><tab><tab><tab><tab>{",
      "<tab><tab><tab><tab><tab><tab>Semiring::add_eq(ret.at(i, k), Semiring::mul(at(i, j), other.at(j, k)));",
      "<tab><tab><tab><tab><tab>}",
      "<tab><tab><tab><tab>}",
      "<tab><tab><tab>}",
      "<tab><tab><tab>return *this = ret;",
      "<tab><tab>}",
      "};",
      "",
      "template <typename T>",
      "struct is_square_matrix : std::false_type{};",
      "",
      "template <int N, typename Semiring>",
      "struct is_square_matrix<square_matrix<N, Semiring>> : std::true_type{};",
      "",
      "template <typename T>",
      "bool operator==(const T& lhs, const T& rhs) { return lhs.value == rhs.value; }",
      "",
      "template <typename T>",
      "bool operator!=(const T& lhs, const T& rhs) { return !(lhs == rhs); }",
      "",
      "template <typename T>",
      "T operator+(T lhs, const T& rhs) { return lhs += rhs; }",
      "",
      "template <typename T>",
      "T operator*(T lhs, const T& rhs) { return lhs *= rhs; }",
      "",
      "",
      "template <int N, typename Semiring>",
      "std::string to_string(const square_matrix<N, Semiring>& a)",
      "{",
      "<tab>using std::literals::string_literals::operator\"\"s;",
      "<tab>auto ret = \"square_matrix{ \"s;",
      "<tab>for (int i = 0; i < N; i++)",
      "<tab>{",
      "<tab><tab>if (i > 0) ret += \", \";",
      "<tab><tab>ret += \"{ \";",
      "<tab><tab>for (int j = 0; j < N; j++)",
      "<tab><tab>{",
      "<tab><tab><tab>if (j > 0) ret += \", \";",
      "<tab><tab><tab>ret += std::to_string(a.at(i, j));",
      "<tab><tab>}",
      "<tab><tab>ret += \" }\";",
      "<tab>}",
      "<tab>ret += \" }\";",
      "<tab>return ret;",
      "}",
      "",
      "template <typename T>",
      "struct min_tolopical",
      "{",
      "<tab>using type = T;",
      "<tab>static auto add_id()<tab>{return std::numeric_limits<T>::max();}",
      "<tab>static auto mul_id()<tab>{return 0;}",
      "<tab>static auto add(T x, T y) {return std::min(x, y);}",
      "<tab>static auto mul(T x, T y)",
      "<tab>{",
      "<tab><tab>if (x == add_id() || y == add_id()) return add_id();",
      "<tab><tab>return x + y;",
      "<tab>}",
      "<tab>static auto add_eq(T& x, T y) {return x = add(x, y);}",
      "};",
      "",
      "template <typename T>",
      "struct min_tolopical",
      "{",
      "<tab>using type = T;",
      "<tab>static auto add_id()<tab>{return std::numeric_limits<T>::min();}",
      "<tab>static auto mul_id()<tab>{return 0;}",
      "<tab>static auto add(T x, T y) {return std::max(x, y);}",
      "<tab>static auto mul(T x, T y)",
      "<tab>{",
      "<tab><tab>if (x == add_id() || y == add_id()) return add_id();",
      "<tab><tab>return x + y;",
      "<tab>}",
      "<tab>static auto add_eq(T& x, T y) {return x = add(x, y);}",
      "};",
      "",
      "template <int N, typename T>",
      "using min_tolopical_matrix = square_matrix<N, min_tolopical<T>>;",
      "",
      "template <int N, typename T>",
      "using max_tolopical_matrix = square_matrix<N, min_tolopical<T>>;"
    ],
    "prefix": "square_matrix"
  },
  "../include/stemp.hpp": {
    "body": [
      "#include <bits/stdc++.h>",
      "using longlong=long long;",
      "",
      "int main(){",
      "    std::cin.tie(nullptr);std::cin.sync_with_stdio(false);",
      "    $0",
      "}"
    ],
    "prefix": "stemp"
  },
  "../include/strongly_connected_component_decomposition.hpp": {
    "body": [
      "auto strongly_connected_component_decomposition(",
      "    std::vector< std::vector< int > > const & graph )",
      "{",
      "    int const n = graph.size();",
      "    std::vector< int > ckd(n, false);",
      "    std::vector< int > ord;",
      "",
      "    auto const dfs = [&graph, &ckd, &ord](auto&& f, auto crr) -> void {",
      "        ckd.at(crr) = true;",
      "        for (auto const nxt : graph.at(crr)) {",
      "            if (ckd.at(nxt)) continue;",
      "            f(f, nxt);",
      "        }",
      "        ord.emplace_back(crr);",
      "    };",
      "    for (auto i = 0; i < n; i++) {",
      "        if (ckd.at(i)) continue;",
      "        dfs(dfs, i);",
      "    }",
      "    std::reverse(ord.begin(), ord.end());",
      "",
      "    std::vector< std::vector< int > > rgraph(n);",
      "    for (auto i = 0; i < n; i++) {",
      "        for (auto j : graph.at(i)) {",
      "            rgraph.at(j).emplace_back(i);",
      "        }",
      "    }",
      "",
      "    auto now = 0;",
      "    std::vector< int > cmp(n, -1);",
      "    auto const rdfs = [&rgraph, &cmp, &now](auto&& f, auto crr) -> void {",
      "        cmp.at(crr) = now;",
      "        for (auto const nxt : rgraph.at(crr)) {",
      "            if (cmp.at(nxt) != -1) continue;",
      "            f(f, nxt);",
      "        }",
      "    };",
      "    for (auto i : ord) {",
      "        if (cmp.at(i) != -1) continue;",
      "        rdfs(rdfs, i);",
      "        now++;",
      "    }",
      "    return cmp;",
      "}"
    ],
    "prefix": "strongly_connected_component_decomposition"
  },
  "../include/suffix_array.hpp": {
    "body": [
      "auto suffix_array( std::string const& s) {",
      "    int n = s.size();",
      "    std::vector< int > ret(n, 0), rank(n, 0);",
      "    std::iota(ret.begin(), ret.end(), 0);",
      "    for (auto i = 0; i < n; i++)",
      "        { rank.at(i) = s.at(i); }",
      "    auto comb = 1;",
      "    auto cmp = [&](auto i, auto j) {",
      "        if (rank.at(i) < rank.at(j)) return true;",
      "        if (rank.at(i) > rank.at(j)) return false;",
      "        if (n <= i + comb) return true;",
      "        if (n <= j + comb) return false;",
      "        return rank.at(i + comb) < rank.at(j + comb);",
      "    };",
      "    std::vector< int > buff(n);",
      "    for (; comb < n; comb *= 2) {",
      "        std::sort(ret.begin(), ret.end(), cmp);",
      "        buff.at(ret.front()) = 0;",
      "        for (auto i = 1; i < n; i++) {",
      "            buff.at(ret.at(i)) = buff.at(ret.at(i - 1)) + cmp(ret.at(i - 1), ret.at(i));",
      "        }",
      "        buff.swap(rank);",
      "    }",
      "    for (auto i = 0; i < n; i++)",
      "        { rank.at(ret.at(i)) = i; }",
      "    return ret;",
      "}"
    ],
    "prefix": "suffix_array"
  },
  "../include/treap.hpp": {
    "body": [
      "template <class T>",
      "struct treap_set_node {",
      "    using key_type = T;",
      "    using value_type = T;",
      "    T key;",
      "    int priority;",
      "    treap_set_node *l, *r;",
      "    treap_set_node(T key, int priority)",
      "        : key(key), priority(priority), l(nullptr), r(nullptr) {}",
      "};",
      "",
      "",
      "template <class T, class U>",
      "struct treap_map_node {",
      "    using key_type = T;",
      "    using mapped_type = U;",
      "    using value_type = std::pair<T,U>;",
      "    T key;",
      "    U mapped;",
      "    int priority;",
      "    treap_map_node *l, *r;",
      "    treap_map_node(T key, U mapped, int priority)",
      "        : key(key), mapped(mapped), priority(priority), l(nullptr), r(nullptr) {}",
      "};",
      "",
      "template <class Node> struct extract_key;",
      "",
      "template <class T>",
      "struct extract_key<treap_set_node<T>> {",
      "    T operator()(treap_set_node<T>* t){ return t->key; }",
      "};",
      "",
      "template <class T, class U>",
      "struct extract_key<treap_map_node<T,U>> {",
      "    T operator()(treap_map_node<T,U>* t){ return t->key; }",
      "};",
      "",
      "template <class Node> struct extract_value;",
      "template <class T>",
      "struct extract_value<treap_set_node<T>> {",
      "    T operator()(treap_set_node<T>* t){ return t->key; }",
      "};",
      "template <class T, class U>",
      "struct extract_value<treap_map_node<T,U>> {",
      "    std::pair<T,U> operator()(treap_map_node<T,U>* t){ return std::make_pair(t->key, t->mapped); }",
      "};",
      "",
      "template <class Node, bool HasUniqueKey>",
      "class treap {",
      "        std::size_t size_ = 0;",
      "",
      "        using Tree = Node *;",
      "",
      "        using key_type = typename Node::key_type;",
      "        using value_type = typename Node::value_type;",
      "        // using mapped_type = typename Node::mapped_type;",
      "",
      "        extract_key<Node> key_fn{};",
      "        extract_value<Node> value_fn{};",
      "",
      "        Tree root = nullptr;",
      "",
      "        void split(Tree t, key_type key, Tree& l, Tree& r, bool by_upper_bound) {",
      "                if (!t) {",
      "                        l = r = nullptr;",
      "                } else if (key < key_fn(t) || (key == key_fn(t) && !by_upper_bound)) {",
      "                        split(t->l, key, l, t->l, by_upper_bound), r = t;",
      "                } else {",
      "                        split(t->r, key, t->r, r, by_upper_bound), l = t;",
      "                }",
      "        }",
      "",
      "        void split_by_lower_bound(Tree t, key_type key, Tree& l, Tree& r) {",
      "            split(t,key,l,r,false);",
      "        }",
      "        void split_by_upper_bound(Tree t, key_type key, Tree& l, Tree& r) {",
      "            split(t,key,l,r,true);",
      "        }",
      "        void split_into_tree_parts(Tree t, key_type key, Tree& l, Tree& c, Tree& r) {",
      "            Tree tmp;",
      "            split_by_lower_bound(t, key, l, tmp);",
      "            split_by_upper_bound(tmp, key, c, r);",
      "        }",
      "",
      "        void merge(Tree& t, Tree l, Tree r) {",
      "            if (!l || !r) {",
      "                t = l ? l : r;",
      "            } else if (l->priority > r->priority) {",
      "                merge(l->r, l->r, r), t = l;",
      "            } else {",
      "                merge(r->l, l, r->l), t = r;",
      "            }",
      "        }",
      "        void merge_three_trees(Tree& t, Tree l, Tree c, Tree r) {",
      "            Tree tmp;",
      "            merge(tmp, c, r);",
      "            merge(t, l, tmp);",
      "        }",
      "",
      "        void insert(Tree& t, Tree item) {",
      "            if (!t) {",
      "                t = item;",
      "            } else if (item->priority > t->priority) {",
      "                split_by_lower_bound(t, item->key, item->l, item->r), t = item;",
      "            } else {",
      "                insert(item->key < key_fn(t) ? t->l : t->r, item);",
      "            }",
      "        }",
      "",
      "        void erase(Tree& t, key_type key) {",
      "            Tree l,r,c;",
      "            split_into_tree_parts(t, key, l, c, r);",
      "            merge(t, l, r);",
      "            size_ -= nuke(c);",
      "        }",
      "",
      "        std::size_t find(Tree& t, key_type key) {",
      "            Tree l,r,c;",
      "            split_into_tree_parts(t, key, l, c, r);",
      "            std::size_t ans = count(c);",
      "            merge_three_trees(t, l, c, r);",
      "            return ans;",
      "        }",
      "",
      "        std::size_t nuke(Tree t) {",
      "            if (!t) return 0;",
      "            std::size_t ret = 1;",
      "            ret += nuke(t->l);",
      "            ret += nuke(t->r);",
      "            delete t;",
      "            return ret;",
      "        }",
      "",
      "        std::size_t count(Tree t) {",
      "            if (!t) return 0;",
      "            std::size_t ret = 1;",
      "            ret += count(t->l);",
      "            ret += count(t->r);",
      "            return ret;",
      "        }",
      "",
      "        void collect_(std::vector<value_type>& v, Tree t) {",
      "            if (!t) return;",
      "            collect_(v, t->l);",
      "            v.push_back(value_fn(t));",
      "            collect_(v, t->r);",
      "        }",
      "",
      "    public:",
      "        std::size_t size() const { return size_; }",
      "",
      "        // set",
      "        void insert(key_type key) {",
      "            if (HasUniqueKey && find(key)) return;",
      "            size_++;",
      "            insert(root, new Node(key, xor128()));",
      "        }",
      "",
      "     // void insert(key_type key, mapped_type value) {",
      "        //     if (HasUniqueKey && find(key)) return;",
      "        //     size_++;",
      "        //     insert(root, new Node(key, value, xor128()));",
      "        // }",
      "",
      "        // void insert_or_replace(key_type key, mapped_type value) {",
      "        //     erase(key);",
      "        //     size_++;",
      "        //     insert(root, new Node(key, value, xor128()));",
      "        // }",
      "",
      "        void erase(key_type key) {",
      "            erase(root, key);",
      "        }",
      "",
      "        std::size_t find(key_type key) {",
      "            return find(root, key);",
      "        }",
      "",
      "        std::vector<value_type> collect(key_type x, key_type y) {",
      "            std::vector<value_type> v;",
      "            Tree l,r,c,tmp;",
      "            split_by_lower_bound(root, x, l, tmp);",
      "            split_by_upper_bound(tmp, y, c, r);",
      "            collect_(v, c);",
      "            merge(tmp, c, r);",
      "            merge(root, l, tmp);",
      "            return v;",
      "        }",
      "        std::vector<value_type> collect() {",
      "            std::vector<value_type> v;",
      "            collect_(v, root);",
      "            return v;",
      "        }",
      "};",
      "",
      "template <class T>",
      "class set : public treap<treap_set_node<T>,true> {};",
      "template <class T>",
      "class multiset : public treap<treap_set_node<T>,false>{};",
      "",
      "template <class T, class U>",
      "class map : public treap<treap_map_node<T,U>,true> {};",
      "template <class T, class U>",
      "class multimap : public treap<treap_map_node<T,U>,false>{};"
    ],
    "prefix": "treap"
  },
  "../include/trie.hpp": {
    "body": [
      "class trie_node {",
      "        int                                 d;     // Root -> 0, One letter -> 1",
      "        std::vector< int >    ids;",
      "        std::vector< int >    nexts;",
      "",
      "    public:",
      "        trie_node(int n, int d): d(d), ids(), nexts(n, -1) {}",
      "",
      "        auto get_ids()     const { return ids;     }",
      "        auto get_nexts() const { return nexts; }",
      "        auto depth()         const { return d;         }",
      "",
      "        decltype(auto) emplace_back(int x) { return ids.emplace_back(x); }",
      "        decltype(auto) at                    (int i) { return nexts.at(i);     }",
      "};",
      "",
      "std::ostream& operator<< (std::ostream& os, trie_node const& v) {",
      "    auto const & a = v.get_ids();",
      "    auto const & b = v.get_nexts();",
      "    os << \"({\";",
      "    for (auto it = a.begin(); it != a.end(); it++)",
      "        { os << (it == a.begin() ? \"\" : \" \" ) << *it; }",
      "    os << \"},{\";",
      "    for (auto it = b.begin(); it != b.end(); it++)",
      "        { os << (it == b.begin() ? \"\" : \" \" ) << *it; }",
      "    return os << \"})\";",
      "}",
      "",
      "template < typename Fn >",
      "class trie {",
      "    int                                 n;             // The number of the kinds of chars",
      "    int                                 cnt;         // The number of the strings",
      "    std::vector< trie_node > storage; // The seq of nodes",
      "    Fn                                    encoder; // char -> int",
      "",
      "public:",
      "    trie()=default;",
      "    trie(int n, const Fn& encoder):",
      "        n(n),",
      "        cnt(0),",
      "        storage(1, trie_node(n, 0)),",
      "        encoder(encoder)",
      "        {}",
      "",
      "    auto get() const { return storage; }",
      "",
      "    // Automatically issue a string id.",
      "    void insert(const std::string& s) {",
      "        std::vector< int > seq(s.length());",
      "        std::transform(s.begin(), s.end(), seq.begin(), encoder);",
      "        auto pos = 0, d = 0;",
      "        for (auto x : seq) {",
      "            d++;",
      "            auto& now            = storage.at(pos);",
      "            auto& next_pos = now.at(x);",
      "            if (next_pos == -1) {",
      "                next_pos = storage.size();",
      "                storage.emplace_back(n, d);",
      "            }",
      "            pos = next_pos;",
      "        }",
      "        storage.at(pos).emplace_back(cnt++);",
      "    }",
      "",
      "    // Return the string ids.",
      "    auto find(const std::string& s) {",
      "        std::vector<int> seq(s.length());",
      "        std::transform(s.begin(), s.end(), seq.begin(), encoder);",
      "        auto vid = 0;",
      "        for (auto x : seq) {",
      "            vid = storage.at(vid).at(x);",
      "            if (vid == -1) return std::vector< int >{};",
      "        }",
      "        return storage.at(vid).get_ids();",
      "    }",
      "",
      "    auto count(const std::string& s)",
      "        { return find(s).size(); }",
      "",
      "    // Return the pairs of length & id",
      "    auto find_prefices(const std::string& s) {",
      "        int    n     = s.length();",
      "        auto ret = std::vector< std::pair< int, int > >{};",
      "        auto vid = 0;",
      "        for (int i = 0; i < n; i++) {",
      "            vid = storage.at(vid).at(encoder(s.at(i)));",
      "            if (vid == -1) return ret;",
      "            for (auto id : storage.at(vid).get_ids())",
      "                { ret.emplace_back(i + 1, id); }",
      "        }",
      "        return ret;",
      "    }",
      "};",
      "",
      "template < typename Fn >",
      "auto make_trie(int n, const Fn& encoder)",
      "    { return trie< Fn >(n, encoder); }"
    ],
    "prefix": "trie"
  },
  "../include/tuple_io.hpp": {
    "body": [
      "template < template < typename ... > class Tuple,    typename... Args, std::size_t ... Inds, std::size_t = std::tuple_size< Tuple < Args ... > >::value >",
      "std::istream& tuple_input_impl(std::istream& os, Tuple<Args...>& tuple, std::integer_sequence<std::size_t, Inds...>)",
      "    { (void)std::initializer_list<int>{((void)(os >> std::get< Inds >(tuple)), 0)...}; return os; }",
      "template < template < typename ... > class Tuple,    typename... Args, std::size_t = std::tuple_size< Tuple < Args ... > >::value >",
      "std::istream& operator>> (std::istream& os, Tuple<Args...>& tuple)",
      "    { return tuple_input_impl(os, tuple, std::index_sequence_for<Args...>()); }",
      "",
      "template < template < typename ... > class Tuple,    typename... Args, std::size_t ... Inds, std::size_t = std::tuple_size< Tuple < Args ... > >::value >",
      "std::ostream& tuple_output_impl(std::ostream& os, const Tuple<Args...>& tuple, std::integer_sequence<std::size_t, Inds...>)",
      "    { os << \"(\"; (void)std::initializer_list<int>{((void)(os << (Inds > 0 ? \",\" : \"\") << std::get< Inds >(tuple)), 0)...}; return os << \")\"; }",
      "template < template < typename ... > class Tuple,    typename... Args, std::size_t = std::tuple_size< Tuple < Args ... > >::value >",
      "std::ostream& operator<< (std::ostream& os, const Tuple<Args...>& tuple)",
      " { return tuple_output_impl(os, tuple, std::index_sequence_for<Args...>()); }"
    ],
    "prefix": "tuple_io"
  },
  "../include/two_edge_decmoposition.hpp": {
    "body": [
      "class two_edge_decomposition {",
      "        int n, m;",
      "        std::vector< std::vector< std::pair< int, int > > > graph;",
      "        std::vector< std::pair< int, int > > edges;",
      "        std::vector< int > ord, low, is_bridge;",
      "",
      "        void build_low_link_impl(int root = 0) {",
      "            is_bridge.resize(m, false);",
      "            int ord_ = 0;",
      "            auto dfs = [&](auto&& dfs, int crr, int prv) -> void {",
      "                ord.at(crr) = low.at(crr) = ord_++;",
      "                for (auto edge : graph.at(crr)) {",
      "                    int nxt, id; std::tie(nxt, id) = edge;",
      "                    if (nxt == prv) continue;",
      "                    if (ord.at(nxt) != -1) {",
      "                        low.at(crr) = std::min(low.at(crr), ord.at(nxt));",
      "                        continue;",
      "                    }",
      "                    dfs(dfs, nxt, crr);",
      "                    low.at(crr) = std::min(low.at(crr), low.at(nxt));",
      "                    is_bridge.at(id) = ord.at(crr) < low.at(nxt);",
      "                }",
      "            };",
      "            dfs(dfs, root, root);",
      "        }",
      "",
      "        void build_cmp_impl() {",
      "            auto efs = [&](auto&& efs, int crr, int prv) -> void {",
      "                cmp.at(crr) = sz;",
      "                for (auto edge : graph.at(crr)) {",
      "                    int nxt, id; std::tie(nxt, id) = edge;",
      "                    if (nxt == prv",
      "                        || is_bridge.at(id)",
      "                        || cmp.at(nxt) != -1) continue;",
      "                    efs(efs, nxt, crr);",
      "                }",
      "            };",
      "            for (int i = 0; i < n; i++) {",
      "                if (cmp.at(i) != -1) continue;",
      "                efs(efs, i, i);",
      "                sz++;",
      "            }",
      "        }",
      "",
      "        void build_qgraph_impl() {",
      "            qgraph.resize(sz);",
      "            for (int i = 0; i < n; i++) {",
      "                for (auto edge : graph.at(i)) {",
      "                    int j, id; std::tie(j, id) = edge;",
      "                    if (!is_bridge.at(id)) continue;",
      "                    int x = cmp.at(i), y = cmp.at(j);",
      "                    qgraph.at(x).emplace_back(y);",
      "                    bridges.emplace_back(i, j);",
      "                }",
      "            }",
      "        }",
      "",
      "    public:",
      "        int sz;",
      "        std::vector< int > cmp;",
      "        std::vector< std::pair< int, int > > bridges;",
      "        std::vector< std::vector< int > > qgraph;",
      "",
      "        two_edge_decomposition(int n) :",
      "            n(n), m(0), graph(n), edges(), ord(n, -1), low(n),",
      "            sz(0), cmp(n, -1), bridges(), qgraph(){}",
      "",
      "        void insert(int i, int j) {",
      "            graph.at(i).emplace_back(j, m);",
      "            graph.at(j).emplace_back(i, m);",
      "            edges.emplace_back(i, j);",
      "            m++;",
      "        }",
      "",
      "        void build(int root = 0) {",
      "            build_low_link_impl(root);",
      "            build_cmp_impl();",
      "            build_qgraph_impl();",
      "        }",
      "};",
      ""
    ],
    "prefix": "two_edge_decmoposition"
  },
  "../include/union_find.hpp": {
    "body": [
      "class union_find {",
      "        int n;",
      "        std::vector<int> prt;",
      "",
      "    public:",
      "        union_find (int n) : n(n), prt(n, -1){}",
      "",
      "        bool is_root (int x)                const {return prt.at(x) < 0;}",
      "        int    size        (int x)                const {return -prt.at(find(x));}",
      "        bool same(int x, int y)         const {return find(x) == find(y);}",
      "        int    find        (int x)                const {",
      "            while (!is_root(x)) x = prt.at(x);",
      "            return x;",
      "        }",
      "        // Returns `true` if x and y are newly connected.",
      "        // The smaller one x becomes a child of the larger one y.",
      "        bool unite     (int x, int y) {",
      "            if ((x = find(x)) == (y = find(y))) return false;",
      "            if (size(x) > size(y)) std::swap(x, y);",
      "            prt.at(y) += prt.at(x);",
      "            prt.at(x) = y;",
      "            return true;",
      "        }",
      "};"
    ],
    "prefix": "union_find"
  },
  "../include/unique.hpp": {
    "body": [
      "template <class T>",
      "void unique(std::vector<T> & v) {",
      "    std::sort(v.begin(), v.end());",
      "    v.resize(std::unique(v.begin(), v.end()) - v.begin());",
      "}"
    ],
    "prefix": "unique"
  },
  "../include/valued_quick_find.hpp": {
    "body": [
      "template <typename Value, typename BinaryOp>",
      "class valued_quick_find",
      "{",
      "    int                                                     n;",
      "    std::vector<int>                            prt;",
      "    std::vector<std::vector<int>> child;",
      "    std::vector<Value>                        table;",
      "    BinaryOp                                            op;",
      "    Value                                                 id;",
      "",
      "    auto& op_eq (Value& x, Value y) const {return x = op(x, y);}",
      "",
      "public:",
      "    valued_quick_find (int n, BinaryOp op, Value id, Value init) :",
      "        n(n), prt(n), child(n), table(n, init), op(op), id(id)",
      "    {",
      "        std::iota(prt.begin(), prt.end(), 0);",
      "        for (int i = 0; i < n; i++) {",
      "            child.at(i) = {i};",
      "        }",
      "    }",
      "",
      "    auto collect ()                         const {return prt;}",
      "    bool is_root (int x)                const {return find(x) == x;}",
      "    int    size        (int x)                const {return child.at(prt.at(x)).size();}",
      "    bool same        (int x, int y) const {return find(x) == find(y);}",
      "    int    find        (int x)                const {return prt.at(x);}",
      "    auto get         (int x)                const {return table.at(find(x));}",
      "    void set         (int x, Value val)     {table.at(find(x)) = val;}",
      "    void add         (int x, Value val)     {set(x, get(x) + val);}",
      "    auto collect_vals()                 const",
      "    {",
      "        auto ret = std::vector<Value>(n);",
      "        for (auto i = 0; i < n; i++)",
      "        {",
      "            ret.at(i) = get(i);",
      "        }",
      "        return ret;",
      "    }",
      "",
      "    // Returns `true` if x and y are newly connected.",
      "    bool unite     (int x, int y)",
      "    {",
      "        if ((x = find(x)) == (y = find(y))) return false;",
      "        if (size(x) < size(y)) std::swap(x, y);",
      "        for (auto z : child.at(y))",
      "        {",
      "            prt.at(z) = x;",
      "            child.at(x).push_back(z);",
      "        }",
      "        op_eq(table.at(x), table.at(y));",
      "        table.at(y) = id;",
      "        typename decltype(child)::value_type{}.swap(child.at(y));",
      "        return true;",
      "    }",
      "};",
      "",
      "template <typename Value, typename BinaryOp, typename BinaryOp2>",
      "auto make_valued_quick_find(int n, BinaryOp op, Value id) {",
      "    return valued_quick_find<Value, BinaryOp>(n, op, id);",
      "}"
    ],
    "prefix": "valued_quick_find"
  },
  "../include/valued_union_find.hpp": {
    "body": [
      "",
      "template <typename Value, typename BinaryOp>",
      "class valued_union_find",
      "{",
      "    int                                n;",
      "    std::vector<Value> table;",
      "    std::vector<int>     prt;",
      "    BinaryOp                     op;",
      "    Value                            id;",
      "",
      "public:",
      "    valued_union_find (int n, BinaryOp op, Value id, Value init) :",
      "        n(n), table(n, init), prt(n, -1), op(op), id(id)",
      "        {}",
      "",
      "    bool is_root (int x)                const {return prt.at(x) < 0;}",
      "    int    size        (int x)                const {return -prt.at(find(x));}",
      "    bool same        (int x, int y) const {return find(x) == find(y);}",
      "    int    find        (int x)                const",
      "    {",
      "        while (!is_root(x)) x = prt.at(x);",
      "        return x;",
      "    }",
      "    auto collect ()                         const {return prt;}",
      "",
      "    // Returns `true` if x and y are newly connected.",
      "    // y becomes the partent.",
      "    bool unite     (int x, int y)",
      "    {",
      "        if ((x = find(x)) == (y = find(y))) return false;",
      "        if (size(x) > size(y)) std::swap(x, y);",
      "        prt.at(y) += prt.at(x);",
      "        prt.at(x) = y;",
      "        table.at(y) = op(table.at(y), table.at(x));",
      "        table.at(x) = id;",
      "        return true;",
      "    }",
      "",
      "    auto get         (int x)                const {return table.at(find(x));}",
      "    auto collect_vals ()                const",
      "    {",
      "        std::vector<Value> ret(n);",
      "        for (auto i = 0; i < n; i++)",
      "        {",
      "            ret.at(i) = get(i);",
      "        }",
      "        return ret;",
      "    }",
      "    void set         (int x, Value val)        {table.at(find(x)) = val;}",
      "    void add         (int x, Value val)        {set(x, get(x) + val);}",
      "};",
      "",
      "template <typename Value, typename BinaryOp>",
      "auto make_valued_union_find(int n, BinaryOp op, Value id, Value init)",
      "{",
      "    return valued_union_find<Value, BinaryOp>(n, op, id, init);",
      "}"
    ],
    "prefix": "valued_union_find"
  },
  "../include/wavelet_matrix.hpp": {
    "body": [
      "class fully_indexable_dictionary {",
      "        int                                     n, blk;",
      "        std::vector<unsigned> data;",
      "        std::vector<int>            cum;",
      "",
      "        auto quat(int i) const { return i / 32; }",
      "        auto res (int i) const { return i % 32; }",
      "        bool bat    (unsigned    x, int i) const { return (x >> i) & 1u; }",
      "        auto bit_set (unsigned& x, int i) const { return x |= (1u << i); }",
      "",
      "    public:",
      "        fully_indexable_dictionary()=default;",
      "        fully_indexable_dictionary(int n):",
      "            n         (n),",
      "            blk     (n / 32 + 1),",
      "            data    (blk, 0),",
      "            cum     (blk)",
      "            {}",
      "",
      "        auto size()            const { return n; }",
      "        bool at    (int i) const { return bat (data.at(quat(i)), res(i)); }",
      "        void set (int i)             {                bit_set(data.at(quat(i)), res(i)); }",
      "",
      "        void build() {",
      "            cum.at(0) = 0;",
      "            for (auto i = 0; i < blk - 1; i++)",
      "                { cum.at(i + 1) = cum.at(i) + __builtin_popcount(data.at(i)); }",
      "        }",
      "",
      "        auto rank(int k) const {",
      "            return cum.at(quat(k))",
      "                + __builtin_popcount(data.at(quat(k)) & ((1u << res(k)) - 1));",
      "        }",
      "        auto rank(int k, bool x) const",
      "            { return x ? rank(k) : k - rank(k); }",
      "",
      "        auto select(int k, bool x) const {",
      "            assert(0 <= k);",
      "            auto lwr = 0, upr = n + 1;",
      "            while (lwr + 1 < upr) {",
      "                auto mid = (lwr + upr) / 2;",
      "                (rank(mid, x) <= k ? lwr : upr) = mid;",
      "            }",
      "            return lwr;",
      "        }",
      "        auto select(int k, bool x, int offset) const",
      "            { return select(x, k + rank(x, offset)); }",
      "};",
      "",
      "std::ostream& operator<<(std::ostream& os, fully_indexable_dictionary const& v) {",
      "    auto n = v.size();",
      "    os << \"{\";",
      "    for (auto i = 0; i < n; i++)",
      "        { os << (i > 0 ? \",\" : \"\") << std::noboolalpha << v.at(i); }",
      "    return os << \"}\";",
      "}",
      "",
      "template < typename Value    >",
      "class wavelet_matrix    {",
      "        using dict = fully_indexable_dictionary;",
      "",
      "        int                                 h;",
      "        int                                 w;",
      "        std::vector< dict > tab;",
      "        std::vector< int    > zs;",
      "        std::vector< int    > buf0;",
      "        std::vector< int    > buf1;",
      "",
      "        auto bat (int x, int j) -> bool {return (x >> j) & 1;}",
      "",
      "        auto rangefreq_impl(int i, int l, int r, Value min, Value max, Value lwr, Value upr) {",
      "            if (l == r) { return 0;}",
      "            if (i == h) { return (lwr <= min && min < upr) ? r - l : 0;}",
      "            auto mid = min + (max - min) / 2;",
      "            if (max < lwr || upr <= min) return 0;",
      "            if (lwr <= min && max < upr) return r - l;",
      "            auto lc = tab.at(i).rank(l, 1);",
      "            auto rc = tab.at(i).rank(r, 1);",
      "            return",
      "                    rangefreq_impl(i + 1,                l - lc,                r - rc, min, mid, lwr, upr)",
      "                + rangefreq_impl(i + 1, lc + zs.at(i), rc + zs.at(i), mid, max, lwr, upr);",
      "        }",
      "",
      "    public:",
      "        wavelet_matrix()=default;",
      "        wavelet_matrix(std::vector< Value > v, int const h):",
      "            h     (h),",
      "            w     (v.size()),",
      "            tab (h, dict(w)),",
      "            zs    (h),",
      "            buf0(h),",
      "            buf1(h)",
      "        {",
      "            std::vector< Value > l(w), r(w);",
      "            for (auto i = 0; i < h; i++) {",
      "                auto& row = tab.at(i);",
      "                int p = 0, q = 0;",
      "                for (auto j = 0; j < w; j++) {",
      "                    auto crr = v.at(j);",
      "                    if (bat(crr, h - 1 - i)) {",
      "                        r.at(q++) = crr;",
      "                        row.set(j);",
      "                    } else {",
      "                        l.at(p++) = crr;",
      "                    }",
      "                }",
      "                row.build();",
      "                zs.at(i) = p;",
      "                std::copy(r.begin(), r.begin() + q, l.begin() + p);",
      "                std::swap(l, v);",
      "            }",
      "        }",
      "",
      "        auto access(int k) const {",
      "            Value ret = 0;",
      "            for (auto i = 0; i < h; i++) {",
      "                auto& row = tab.at(i);",
      "                auto const upr = row.at(k);",
      "                ret = (ret << 1) | upr;",
      "                k = row.rank(k, upr) + zs.at(i) * upr;",
      "            }",
      "            return ret;",
      "        }",
      "        auto at(int k) const { return access(k); }",
      "",
      "        auto rank(int l, int r, Value x) {",
      "            for (auto i = 0; i < h; i++) {",
      "                auto upr = bat(x, h - i - 1);",
      "                l = tab.at(i).rank(l, upr) + zs.at(i) * upr;",
      "                r = tab.at(i).rank(r, upr) + zs.at(i) * upr;",
      "            }",
      "            return r - l;",
      "        }",
      "",
      "        auto select(int k, Value x) {",
      "            rank(0, w, x);",
      "            for (auto i = h - 1; i >= 0; i--) {",
      "                auto upr = bat(x, h - 1 - i);",
      "                k = tab.at(i).select(k, upr, buf0.at(i));",
      "                if (k < 0 || buf1.at(i) <= k) return w;",
      "                k -= buf0.at(i);",
      "            }",
      "            return k;",
      "        }",
      "        auto select(int k, Value x, int offset)",
      "            { return select(k + rank(0, offset, x), x); }",
      "",
      "        auto quantile(int l, int r, int k) {",
      "            assert(0 <= k && k <= r - l);",
      "            Value ret = 0;",
      "            for (auto i = 0; i < h; i++) {",
      "                auto p = tab.at(i).rank(l, true);",
      "                auto q = tab.at(i).rank(r, true);",
      "                if (k < q - p) {",
      "                    l = p + zs.at(i);",
      "                    r = q + zs.at(i);",
      "                    ret |= Value(1) << (h - 1 - i);",
      "                } else {",
      "                    k -= (q - p);",
      "                    l -= p;",
      "                    r -= q;",
      "                }",
      "            }",
      "            return ret;",
      "        }",
      "        auto rquantile(int l, int r, int k)",
      "            { return quantile(l, r, r - l - 1 - k); }",
      "",
      "        auto rangefreq(int l, int r, Value lwr, Value upr)",
      "            { return rangefreq_impl(0, l, r, 0, Value(1) << h, lwr, upr); }",
      "};"
    ],
    "prefix": "wavelet_matrix"
  },
  "../include/weighted_quick_find.hpp": {
    "body": [
      "template <typename Value, typename BinaryOp1, typename BinaryOp2>",
      "class weighted_quick_find",
      "{",
      "    int                                                     n;",
      "    std::vector<int>                            prt;",
      "    std::vector<std::vector<int>> child;",
      "    std::vector<Value>                        table;",
      "    BinaryOp1                                         op1;",
      "    BinaryOp2                                         op2;",
      "    Value                                                 id;",
      "",
      "    auto& op1_eq (Value& x, Value y) const {return x = op1(x, y);}",
      "    auto& op2_eq (Value& x, Value y) const {return x = op2(x, y);}",
      "    auto& inv_eq (Value& x)                    const {return x = op2(id, x);}",
      "",
      "public:",
      "    weighted_quick_find (int n, BinaryOp1 op1, BinaryOp2 op2, Value id) :",
      "        n(n), prt(n), child(n), table(n, id), op1(op1), op2(op2), id(id)",
      "    {",
      "        std::iota(prt.begin(), prt.end(), 0);",
      "        for (int i = 0; i < n; i++) {",
      "            child.at(i) = {i};",
      "        }",
      "    }",
      "",
      "    auto collect ()                         const {return prt;}",
      "    bool is_root (int x)                const {return find(x) == x;}",
      "    int    size        (int x)                const {return child.at(prt.at(x)).size();}",
      "    bool same        (int x, int y) const {return find(x) == find(y);}",
      "    int    find        (int x)                const {return prt.at(x);}",
      "",
      "    // x - y",
      "    auto diff        (int x, int y) const",
      "    {",
      "        assert(same(x, y));",
      "        return op2(table.at(x), table.at(y));",
      "    }",
      "",
      "    // Returns `true` if x and y are newly connected.",
      "    // x - y = d",
      "    bool unite     (int x, int y, Value d)",
      "    {",
      "        inv_eq(d);",
      "        op1_eq(d, table.at(x));",
      "        op2_eq(d, table.at(y));",
      "        if ((x = find(x)) == (y = find(y))) return false;",
      "        if (size(x) < size(y))",
      "        {",
      "            std::swap(x, y);",
      "            inv_eq(d);",
      "        }",
      "        for (auto z : child.at(y))",
      "        {",
      "            prt.at(z) = x;",
      "            op1_eq(table.at(z), d);",
      "            child.at(x).push_back(z);",
      "        }",
      "        typename decltype(child)::value_type{}.swap(child.at(y));",
      "        return true;",
      "    }",
      "};",
      "",
      "template <typename Value, typename BinaryOp1, typename BinaryOp2>",
      "auto make_weighted_quick_find(int n, BinaryOp1 op1, BinaryOp2 op2, Value id) {",
      "    return weighted_quick_find<Value, BinaryOp1, BinaryOp2>(n, op1, op2, id);",
      "}"
    ],
    "prefix": "weighted_quick_find"
  },
  "../include/weighted_union_find.hpp": {
    "body": [
      "template <typename Value, typename BinaryOp1, typename BinaryOp2>",
      "class weighted_union_find",
      "{",
      "    int                                n;",
      "    std::vector<int>     prt;",
      "    std::vector<Value> wt;",
      "    BinaryOp1                    op1;",
      "    BinaryOp2                    op2;",
      "    Value                            id;",
      "",
      "    auto op1_eq (Value& x, Value y) const {return x = op1(x, y);}",
      "    auto op2_eq (Value& x, Value y) const {return x = op2(x, y);}",
      "    auto inv_eq (Value& x)                    const {return x = op2(id, x);}",
      "    auto inv        (Value& x)                    const {return inv_eq(x);}",
      "",
      "public:",
      "    weighted_union_find",
      "        (int n, BinaryOp1 op1, BinaryOp2 op2, Value id) :",
      "        n(n), prt(n, -1), wt(n, id), op1(op1), op2(op2), id(id)",
      "        {}",
      "",
      "    bool is_root     (int x)                const {return prt.at(x) < 0;}",
      "    int    size            (int x)                            {return -prt.at(find(x));}",
      "    bool same            (int x, int y)             {return find(x) == find(y);}",
      "    auto collect     ()                         const {return prt;}",
      "",
      "    auto get             (int x)",
      "    {",
      "        find(x);",
      "        return wt.at(x);",
      "    }",
      "    auto quiet_get (int x) const",
      "    {",
      "        auto ret = id;",
      "        while(!is_root(x))",
      "        {",
      "            op1_eq(ret, wt.at(x));",
      "            x = prt.at(x);",
      "        }",
      "        return ret;",
      "    }",
      "",
      "    // x - y",
      "    auto diff            (int x, int y)",
      "    {",
      "        assert(same(x, y));",
      "        return op2(get(x), get(y));",
      "    }",
      "    auto collect_wts ()",
      "    {",
      "        auto ret = std::vector<Value>(n);",
      "        for (auto i = 0; i < n; i++)",
      "        {",
      "            ret.at(i) = get(i);",
      "        }",
      "        return ret;",
      "    }",
      "    auto quiet_collect_wts() const",
      "    {",
      "        auto ret = std::vector<Value>(n);",
      "        for (auto i = 0; i < n; i++)",
      "        {",
      "            ret.at(i) = quiet_get(i);",
      "        }",
      "        return ret;",
      "    }",
      "",
      "    // Path compression.",
      "    int    find        (int x)",
      "    {",
      "        if (is_root(x)) return x;",
      "        else",
      "        {",
      "            auto root = find(prt.at(x));",
      "            op1_eq(wt.at(x), wt.at(prt.at(x)));",
      "            return prt.at(x) = root;",
      "        }",
      "    }",
      "",
      "    // Returns `true` if x and y are newly connected.",
      "    // x is the parent.",
      "    // x - y = d",
      "    bool unite     (int x, int y, Value d)",
      "    {",
      "        inv_eq(d);",
      "        op1_eq(d, get(x));",
      "        op2_eq(d, get(y));",
      "        if ((x = find(x)) == (y = find(y)))",
      "        {",
      "            assert(op2(get(x), get(y)) == d);",
      "            return false;",
      "        }",
      "        if (size(x) < size(y))",
      "        {",
      "            std::swap(x, y);",
      "            inv_eq(d);",
      "        }",
      "        prt.at(x) += prt.at(y);",
      "        prt.at(y) = x;",
      "        wt.at(y) = d;",
      "        return true;",
      "    }",
      "};",
      "",
      "template <typename Value, typename BinaryOp1, typename BinaryOp2>",
      "auto make_weighted_union_find(int n, BinaryOp1 op1, BinaryOp2 op2, Value id)",
      "{",
      "    return weighted_union_find<Value, BinaryOp1, BinaryOp2>(n, op1, op2, id);",
      "}"
    ],
    "prefix": "weighted_union_find"
  },
  "../include/xor128.hpp": {
    "body": [
      "unsigned long xor128() {",
      "    static unsigned long x=123456789, y=362436069, z=521288629, w=88675123;",
      "    unsigned long t=(x^(x<<11));",
      "    x=y; y=z; z=w;",
      "    return ( w=(w^(w>>19))^(t^(t>>8)) );",
      "}"
    ],
    "prefix": "xor128"
  },
  "../include/z_algorithm.hpp": {
    "body": [
      "template < template < typename ... > class Container, typename Value >",
      "auto make_z_array(Container< Value > const & s) -> std::vector< int > {",
      "    if (s.empty()) return {};",
      "    auto n = (int)s.size();",
      "    std::vector< int > ret(n);",
      "    ret.at(0) = n;",
      "    auto i = 1, j = 0;",
      "    while (i < n) {",
      "        while (i + j < n && s.at(j) == s.at(i + j))",
      "            { j++; }",
      "        ret.at(i) = j;",
      "        if (j == 0)",
      "            { i++; }",
      "        else {",
      "            auto k = 1;",
      "            while (i + k < n && k + ret.at(k) < j) {",
      "                ret.at(i + k) = ret.at(k);",
      "                k++;",
      "            }",
      "            i += k, j -= k;",
      "        }",
      "    }",
      "    return ret;",
      "}",
      "",
      "// Returns turns all the occurence of w in s.",
      "template < template < typename ... > class Container, typename Value >",
      "auto z_search(Container< Value > const & w, Container< Value > const & s, Value dammy) -> std::vector<int> {",
      "    if (s.empty()) return {};",
      "    assert(!w.empty());",
      "    assert(std::find(w.begin(), w.end(), dammy) == w.end());",
      "    assert(std::find(s.begin(), s.end(), dammy) == s.end());",
      "    auto long_string = w;",
      "    long_string.push_back(dammy);",
      "    long_string.insert(long_string.end(), s.begin(), s.end());",
      "    auto z_array = make_z_array(std::move(long_string));",
      "    int m = w.size(), n = s.size();",
      "    std::vector<int> ret;",
      "    for (int i = 0; i < n; i++) {",
      "        if (z_array.at(m + 1 + i) == m)",
      "            { ret.push_back(i); }",
      "    }",
      "    return ret;",
      "}"
    ],
    "prefix": "z_algorithm"
  },
  "../snippets/1sin.hpp": {
    "body": [
      "${1:int} $2; std::cin >> $2;"
    ],
    "prefix": "1sin"
  },
  "../snippets/2sin.hpp": {
    "body": [
      "${1:int} $2, $3; std::cin >> $2 >> $3;"
    ],
    "prefix": "2sin"
  },
  "../snippets/3sin.hpp": {
    "body": [
      "${1:int} $2, $3, $4;",
      "std::cin >> $2 >> $3 >> $4;"
    ],
    "prefix": "3sin"
  },
  "../snippets/4sin.hpp": {
    "body": [
      "${1:int} $2, $3, $4, $5;",
      "std::cin >> $2 >> $3 >> $4 >> $5;"
    ],
    "prefix": "4sin"
  },
  "../snippets/5sin.hpp": {
    "body": [
      "${1:int} $2, $3, $4, $5, $6;",
      "std::cin >> $2 >> $3 >> $4 >> $5 >> $6;"
    ],
    "prefix": "5sin"
  },
  "../snippets/lambda.hpp": {
    "body": [
      "auto ${1:name}=[&]($2){",
      "    $0",
      "};"
    ],
    "prefix": "lambda"
  },
  "../snippets/sout.hpp": {
    "body": [
      "std::cout << $0 << std::endl;"
    ],
    "prefix": "sout"
  },
  "../snippets/tin.hpp": {
    "body": [
      "${1:int} ${2:tmp};",
      "std::cin >> $2;",
      "$0;"
    ],
    "prefix": "tin"
  }
}