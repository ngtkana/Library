{
  "../src/lib/datasets_and_queries/binary_indexed_tree.cpp": {
    "body": [
      "template <typename T>",
      "class binary_indexed_tree {",
      "    size_t sz;",
      "    std::vector<T> tr;",
      "    std::function<T(T, T)> sum;",
      "    std::function<T(T, T)> dif;",
      "    T id;",
      "  public:",
      "    binary_indexed_tree (",
      "        size_t n,",
      "        std::function<T(T, T)> sum,",
      "        std::function<T(T, T)> dif,",
      "        T id",
      "      ) :",
      "      sz(n), tr(n, id),",
      "      sum(sum), dif(dif), id(id)",
      "      {}",
      "    auto cum (size_t r) const -> T {",
      "      assert(0 <= r && r <= sz);",
      "      int k = (int)r;",
      "      k--;",
      "      T ret = 0;",
      "      for (; k >= 0; k &= k + 1, k--) ret = sum(ret, tr[k]);",
      "      return ret;",
      "    }",
      "    auto query (size_t l, size_t r) const -> T {",
      "      assert(0 <= l && l <= r && r <= sz);",
      "      return dif(query(0, r), query(0, l));",
      "    }",
      "    auto operator[] (size_t i) const -> T {",
      "      assert(0 <= i && i < sz);",
      "      return query(i, i + 1);",
      "    }",
      "    auto at (size_t i) const -> T {",
      "      return operator[](i);",
      "    }",
      "    void add (size_t i, T x) {",
      "      for (; i < sz; i |= i + 1) tr[i] = sum(tr[i], x);",
      "    }",
      "    void print(std::string name = \"bit\") {",
      "      std::cout << name << \": \";",
      "      for (size_t i = 0; i < sz; i++) {",
      "        if (i) std::cout << \" \";",
      "        std::cout << operator[](i);",
      "      }",
      "      std::cout << std::endl;",
      "    }",
      "}"
    ],
    "prefix": "binary_indexed_tree"
  },
  "../src/lib/datasets_and_queries/compressed_segment_tree.cpp": {
    "body": [
      "template<typename T, typename U>",
      "class compressed_segment_tree {",
      "  const std::vector<T> a;",
      "  const size_t sz, Sz;",
      "  std::vector<U> seg;",
      "  const std::function<U(U, U)> o;",
      "  const U id;",
      "  inline auto find (T k) const {",
      "    auto it = std::lower_bound(a.begin(), a.end(), k);",
      "    assert(it != a.end() && *it == k);",
      "    return it - a.begin() + sz;",
      "  }",
      "  public:",
      "    compressed_segment_tree (",
      "        const std::vector<T> a,",
      "        const std::function<U(U, U)> o,",
      "        const U id",
      "      ) :",
      "      a(a),",
      "      sz([&](){",
      "          size_t ret = 1;",
      "          for (; ret < a.size(); ret <<= 1) {}",
      "          return ret;",
      "        }()),",
      "      Sz(sz << 1),",
      "      seg(Sz, id),",
      "      o(o),",
      "      id(id)",
      "      {",
      "      }",
      "    void update (T x, const U& y) {",
      "      auto k = find(x);",
      "      seg[k] = y;",
      "      while(k >>= 1) {",
      "        seg[k] = o(seg[2 * k], seg[2 * k + 1]);",
      "      }",
      "    }",
      "    void add (T x, const U& y) {",
      "      update(x, at(x) + y);",
      "    }",
      "    U query (T l, T r) {",
      "      l = std::lower_bound(a.begin(), a.end(), l) - a.begin();",
      "      r = std::lower_bound(a.begin(), a.end(), r) - a.begin();",
      "      U L = id, R = id;",
      "      for(l += sz, r += sz; l < r; l >>= 1, r >>= 1) {",
      "        if(l & 1) L = o(L, seg[l++]);",
      "        if(r & 1) R = o(seg[--r], R);",
      "      }",
      "      return o(L, R);",
      "    }",
      "    U at (T x) const {",
      "      return seg[find(x)];",
      "    }",
      "    void print () const {",
      "      int n = a.size();",
      "      std::cout << std::setw(4) << \"----\"; for (int i = 0; i < n; i++) std::cout << std::setw(4) << \"----\" ; std::cout << std::endl;",
      "      std::cout << std::setw(4) << \"\"; for (auto const& e : a) std::cout << std::setw(4) << e; std::cout << std::endl;",
      "      std::cout << std::setw(4) << \"----\"; for (int i = 0; i < n; i++) std::cout << std::setw(4) << \"----\" ; std::cout << std::endl;",
      "      std::cout << std::setw(4) << \"val\"; for (auto const& e : a) std::cout << std::setw(4) << at(e); std::cout << std::endl;",
      "      std::cout << std::setw(4) << \"----\"; for (int i = 0; i < n; i++) std::cout << std::setw(4) << \"----\" ; std::cout << std::endl;",
      "    }",
      "};"
    ],
    "prefix": "compressed_segment_tree"
  },
  "../src/lib/datasets_and_queries/disjoint_sparse_table.cpp": {
    "body": [
      "template <typename T>",
      "class disjoint_sparse_table {",
      "  const int n, ht;",
      "  const std::vector<int> msb;",
      "  const std::function<T(T, T)> o;",
      "  const std::vector<std::vector<T>> tab;",
      "  public:",
      "    disjoint_sparse_table (",
      "        const std::vector<T> a,",
      "        const std::function<T(T, T)> o",
      "      ) :",
      "      n(a.size()),",
      "      ht([&](){",
      "          int ret = 1;",
      "          for (int b = 2; b < n; b <<= 1) ret++;",
      "          return ret;",
      "        }()),",
      "      msb([&](){",
      "          int N = 1 << ht;",
      "          auto ret = std::vector<int>(N, 0); ret[0] = -1;",
      "          for (int i = 2; i < N; i++) ret[i] = ret[i >> 1] + 1;",
      "          return ret;",
      "        }()),",
      "      o(o),",
      "      tab([&](){",
      "          auto ret = std::vector<std::vector<T>>(ht, a);",
      "          for (int i = 1; i < ht; i++) {",
      "            int p = 1 << i; int P = p << 1;",
      "            for (int s = 0; s < n; s += P) {",
      "              int t = min(s + p, n);",
      "              for (int j = t - 2; j >= s; j--) ret[i][j] = o(a[j], ret[i][j + 1]);",
      "              for (int j = t + 1; j < min(s + P, n); j++) ret[i][j] = o(ret[i][j - 1], a[j]);",
      "            }",
      "          }",
      "          return ret;",
      "        }())",
      "      {",
      "      }",
      "    auto query (",
      "        int l,",
      "        int r",
      "      ) -> T",
      "      {",
      "        assert(l <= --r);",
      "        int m = msb[l ^ r];",
      "        return m == -1 ? tab[0][l] : o(tab[m][l], tab[m][r]);",
      "      }",
      "};"
    ],
    "prefix": "disjoint_sparse_table"
  },
  "../src/lib/datasets_and_queries/lazy_segment_tree.cpp": {
    "body": [
      "template<typename T, typename U>",
      "struct range_minimum_query {",
      "  const T id;",
      "  const std::function<T(T, T)> merge_function;",
      "  const std::function<void(U&)> twice;",
      "  const std::function<U(U)> half;",
      "  range_minimum_query(T id):",
      "    id(id),",
      "    merge_function ([](T a, T b) {return min(a, b);}),",
      "    twice ([](U& a) {}),",
      "    half ([](U a) {return a;})",
      "    {",
      "    }",
      "};",
      "template<typename T, typename U>",
      "struct range_maximum_query {",
      "  const T id;",
      "  const std::function<T(T, T)> merge_function;",
      "  const std::function<void(U&)> twice;",
      "  const std::function<U(U)> half;",
      "  range_maximum_query(T id):",
      "    id(id),",
      "    merge_function ([](T a, T b) {return max(a, b);}),",
      "    twice ([](U& a) {}),",
      "    half ([](U a) {return a;})",
      "    {",
      "    }",
      "};",
      "template<typename T, typename U>",
      "struct range_sum_query {",
      "  const T id;",
      "  const std::function<T(T, T)> merge_function;",
      "  const std::function<void(U&)> twice;",
      "  const std::function<U(U)> half;",
      "  range_sum_query(T id = 0):",
      "    id(id),",
      "    merge_function ([](T a, T b) {return a + b;}),",
      "    twice ([](U& a) {a *= 2;}),",
      "    half ([](U a) {return a / 2;})",
      "    {",
      "    }",
      "};",
      "template<typename T, typename U>",
      "struct range_update_query {",
      "    const U id;",
      "    const std::function<void(T&, U)> action;",
      "    const std::function<void(U&, U)> composition;",
      "  public:",
      "    range_update_query(U id = 0):",
      "      id(id),",
      "      action ([](T& a, U b) {a = b;}),",
      "      composition ([](U& a, U b) {a = b;})",
      "      {",
      "      }",
      "};",
      "template<typename T, typename U>",
      "struct range_add_query {",
      "    const U id;",
      "    const std::function<void(T&, U)> action;",
      "    const std::function<void(U&, U)> composition;",
      "  public:",
      "    range_add_query(U id = 0):",
      "      id(id),",
      "      action ([](T& a, U b) {a += b;}),",
      "      composition ([](U& a, U b) {a += b;})",
      "      {",
      "      }",
      "};",
      "template<typename T, typename U>",
      "class lazy_segment_tree {",
      "  int sz;",
      "  int Sz;",
      "  int ht;",
      "  std::vector<T> seg;",
      "  std::vector<U> act;",
      "  std::vector<bool> has_act;",
      "  const std::function<T(T, T)> o;",
      "  const std::function<void(T&, U)> oo;",
      "  const std::function<void(U&, U)> ooo;",
      "  const std::function<void(U&)> twice;",
      "  const std::function<U(U)> half;",
      "  const T tid;",
      "  const U uid;",
      "  ",
      "  public:",
      "    lazy_segment_tree(",
      "        int n,",
      "        const std::function<T(T, T)> merge_function,",
      "        const std::function<void(T&, U)> action,",
      "        const std::function<void(U&, U)> composition,",
      "        const std::function<void(U&)> twice,",
      "        const std::function<U(U)> half,",
      "        const T seg_id,",
      "        const U act_id",
      "      )",
      "        : o(merge_function)",
      "        , oo(action)",
      "        , ooo(composition)",
      "        , twice(twice)",
      "        , half(half)",
      "        , tid(seg_id)",
      "        , uid(act_id)",
      "      {",
      "        ht = 1, sz = 1;",
      "        while(sz < n) ht++, sz <<= 1;",
      "        Sz = sz << 1;",
      "        seg.assign(Sz, tid);",
      "        act.resize(Sz, act_id);",
      "        has_act.assign(Sz, false);",
      "      }",
      "    ",
      "    lazy_segment_tree(",
      "        const std::vector<T>& data,",
      "        const std::function<T(T, T)> merge_function,",
      "        const std::function<void(T&, U)> action,",
      "        const std::function<void(U&, U)> composition,",
      "        const std::function<void(U&)> twice,",
      "        const std::function<U(U)> half,",
      "        const T seg_id,",
      "        const U act_id",
      "      )",
      "        : lazy_segment_tree(",
      "            data.size(),",
      "            merge_function,",
      "            action,",
      "            composition,",
      "            twice,",
      "            half,",
      "            seg_id,",
      "            act_id",
      "          )",
      "      {",
      "        copy(data.begin(), data.end(), seg.begin() + sz);",
      "        for (int i = sz - 1; i >= 1; i--) seg[i] = o(seg[i << 1], seg[(i << 1) + 1]);",
      "      }",
      "    ",
      "    template<typename V, typename M, typename A>",
      "    lazy_segment_tree(",
      "        const V n_or_v,",
      "        const M& merge_instance,",
      "        const A& action_instance",
      "      )",
      "        : lazy_segment_tree(",
      "          n_or_v,",
      "          merge_instance.merge_function,",
      "          action_instance.action,",
      "          action_instance.composition,",
      "          merge_instance.twice,",
      "          merge_instance.half,",
      "          merge_instance.id,",
      "          action_instance.id",
      "        )",
      "      {",
      "      }",
      "    ",
      "    inline int lft (int i) {return i << 1;}",
      "    inline int rgt (int i) {return (i << 1) + 1;}",
      "    inline int upp (int i) {return i >> 1;}",
      "",
      "    inline void propagate (",
      "        int k,",
      "        int L,",
      "        int R",
      "      )",
      "      {",
      "        if (has_act[k]) {",
      "          oo(seg[k], act[k]);",
      "          if (k < sz) {",
      "            ooo(act[lft(k)], half(act[k]));",
      "            ooo(act[rgt(k)], half(act[k]));",
      "            has_act[lft(k)] = has_act[rgt(k)] = true;",
      "          }",
      "          act[k] = uid, has_act[k] = false;",
      "        }",
      "      }",
      "",
      "    void update (",
      "        int l,",
      "        int r,",
      "        T x,",
      "        int k = 1,",
      "        int L = 0,",
      "        int R = -1",
      "      )",
      "      {",
      "        if (R == -1) R = sz;",
      "        if (k == 1) for (int i = 0; i < ht - 1; i++) twice(x);",
      "        propagate(k, L, R);",
      "        if (R <= l || r <= L) return;",
      "        if (l <= L && R <= r) {",
      "          ooo(act[k], x), has_act[k] = true;",
      "          propagate(k, L, R);",
      "        } else {",
      "          int C = (L + R) >> 1;",
      "          update(l, r, half(x), lft(k), L, C);",
      "          update(l, r, half(x), rgt(k), C, R);",
      "          seg[k] = o(seg[lft(k)], seg[rgt(k)]);",
      "        }",
      "      }",
      "    ",
      "    T query (",
      "        int l,",
      "        int r,",
      "        int k = 1,",
      "        int L = 0,",
      "        int R = -1",
      "      )",
      "      {",
      "        if (R == -1) R = sz;",
      "        propagate(k, L, R);",
      "        if (R <= l || r <= L) return tid;",
      "        if (l <= L && R <= r) {",
      "          propagate(k, L, R);",
      "          return seg[k];",
      "        } else {",
      "          int C = (L + R) >> 1;",
      "          T lv = query(l, r, lft(k), L, C);",
      "          T rv = query(l, r, rgt(k), C, R);",
      "          seg[k] = o(seg[lft(k)], seg[rgt(k)]);",
      "          return o(lv, rv);",
      "        }",
      "      }",
      "",
      "    void print(int w = 4) {",
      "      for (int i(1), last(2), output_size(w << ht); last <= Sz; last <<= 1, output_size >>= 1) {",
      "        for (; i < last; i++) {",
      "          std::cout << std::right << std::setw(w);",
      "          std::cout << (seg[i] != tid ? to_string(seg[i]) : \"\");",
      "          std::cout << std::setw(2) <<  \"<\";",
      "          std::cout << left << std::setw(output_size - w - 2);",
      "          std::cout << (has_act[i] ? to_string(act[i]) : \"\");",
      "        }",
      "        std::cout << std::endl;",
      "      }",
      "    }",
      "};"
    ],
    "prefix": "lazy_segment_tree"
  },
  "../src/lib/datasets_and_queries/potential_disjoint_set.cpp": {
    "body": [
      "class potential_disjoint_set {",
      "  public:",
      "  std::vector<int> rank, prt, ptl;",
      "  potential_disjoint_set (int size) {",
      "    rank.resize(size);",
      "    prt.resize(size);",
      "    ptl.resize(size);",
      "    for (int i = 0; i < size; i++) {",
      "      prt[i] = i;",
      "      rank[i] = 0;",
      "      ptl[i] = 0;",
      "    }",
      "  }",
      "  int find (int x) {",
      "    if (x == prt[x]){",
      "      return x;",
      "    } else {",
      "      int r = find(prt[x]);",
      "      ptl[x] += ptl[prt[x]];",
      "      return prt[x] = r;",
      "    }",
      "  }",
      "  bool is_equiv (int x, int y) {",
      "    return find(x) == find(y);",
      "  }",
      "  bool unite (int x, int y, int w) {",
      "    if (find(x) == find(y)) {",
      "      return false;",
      "    }",
      "    w += ptl[x];",
      "    w -= ptl[y];",
      "    x = find(x);",
      "    y = find(y);",
      "    if (rank[x] < rank[y]) {",
      "      std::swap(x, y);",
      "      w *= -1;",
      "    }",
      "    prt[y] = x;",
      "    ptl[y] = w;",
      "    if (rank[x] == rank[y]) {",
      "      rank[x]++;",
      "    }",
      "    return true;",
      "  }",
      "  int diff (int x, int y) {",
      "    find(x);",
      "    find(y);",
      "    return ptl[y] - ptl[x];",
      "  }",
      "};"
    ],
    "prefix": "potential_disjoint_set"
  },
  "../src/lib/datasets_and_queries/segment_tree.cpp": {
    "body": [
      "template<typename T, typename F, std::enable_if_t<",
      "  std::is_same<std::result_of_t<F(T, T)>, T>::value,",
      "  std::nullptr_t",
      "> = nullptr>",
      "class segment_tree {",
      "    using vec = std::vector<T>;",
      "    size_t ht, n, N;",
      "    F o; T id; vec tab;",
      "    void cal (size_t u) {tab.at(u) = o(tab.at(2 * u), tab.at(2 * u + 1));}",
      "",
      "  public:",
      "    using value_type    = T;",
      "    using function_type = F;",
      "    segment_tree(",
      "        size_t size,",
      "        F      merge_function,",
      "        T      id,",
      "        vec    v",
      "      ) :",
      "      ht(std::log2(size) + 2), n(std::pow(2, ht - 1)), N(n * 2),",
      "      o(merge_function), id (id), tab(N)",
      "      {",
      "        assert(n > 0);",
      "        v.resize(n, id);",
      "        std::copy(v.begin(), v.end(), tab.begin() + n);",
      "        for (size_t i = n - 1; i != 0; i--) cal(i);",
      "      }",
      "    segment_tree(",
      "        size_t size,",
      "        F      merge_function,",
      "        T      id",
      "      ) :",
      "      segment_tree(size, std::move(merge_function), id, vec(size, id)){}",
      "",
      "    // Change a value at the leaf.",
      "    void update (size_t u, T val) {",
      "      tab.at(u += n) = val;",
      "      for (u /= 2; u != 0; u /= 2) cal(u);",
      "    }",
      "    // Range-something query at [l, r[.",
      "    auto query (size_t l, size_t r) const -> T {",
      "      struct state {size_t top, left, right;};",
      "      auto ret = id;",
      "      std::stack<state> stk; stk.push({1, 0, n});",
      "      while (!stk.empty()) {",
      "        auto now = stk.top(); stk.pop();",
      "        if (l <= now.left && now.right <= r) {",
      "          ret = o(ret, tab.at(now.top));",
      "          continue;",
      "        }",
      "        size_t mid = (now.left + now.right) / 2;",
      "        if (l < mid) stk.push({2 * now.top,     now.left,  mid});",
      "        if (mid < r) stk.push({2 * now.top + 1, mid, now.right});",
      "      }",
      "      return ret;",
      "    }",
      "};",
      "template<typename T, typename F, typename... Args>",
      "auto make_segment_tree (",
      "    size_t  size,",
      "    F       merge_function,",
      "    Args... args",
      "  )",
      "  {",
      "    return segment_tree<T, F>(",
      "      size, std::move(merge_function), std::forward<Args>(args)...);",
      "  }"
    ],
    "prefix": "segment_tree"
  },
  "../src/lib/datasets_and_queries/sparse_table.cpp": {
    "body": [
      "template <typename T>",
      "class sparse_table {",
      "  const int n, ht;",
      "  const std::vector<int> msb;",
      "  const std::function<T(T, T)> o;",
      "  const std::vector<std::vector<T>> tab;",
      "  public:",
      "    sparse_table (",
      "        std::vector<T> a,",
      "        std::function<T(T, T)> o",
      "      ) :",
      "      n(a.size()),",
      "      ht([&](){",
      "          int ret = 1;",
      "          for (int b = 2; b < n; b <<= 1) ret++;",
      "          return ret;",
      "        }()),",
      "      msb([&](){",
      "          int N = 1 << ht;",
      "          auto ret = std::vector<int>(N, 0); ret[0] = -1;",
      "          for (int i = 2; i < N; i++) ret[i] = ret[i >> 1] + 1;",
      "          return ret;",
      "        }()),",
      "      o(o),",
      "      tab([&](){",
      "          auto ret = std::vector<std::vector<T>>(ht, a);",
      "          for (int i = 1, p = 1; i < ht; i++, p <<= 1) {",
      "            for (int j = 0; j < n; j++) {",
      "              ret[i][j] = o(ret[i - 1][j], ret[i - 1][min(j + p, n - 1)]);",
      "            }",
      "          }",
      "          return ret;",
      "        }())",
      "      {",
      "      }",
      "    auto query (",
      "        int l,",
      "        int r",
      "      ) -> T",
      "      {",
      "        assert(0 <= l && l < r && r <= n);",
      "        int i = msb[r - l];",
      "        return o(tab[i][l], tab[i][r - (1 << i)]);",
      "      }",
      "};"
    ],
    "prefix": "sparse_table"
  },
  "../src/lib/datasets_and_queries/union_find_tree.cpp": {
    "body": [
      "class union_find_tree {",
      "    int n;",
      "    std::vector<int> prt;",
      "",
      "  public:",
      "    template<typename T>",
      "    union_find_tree (T n) : n(n), prt(n, -1){}",
      "",
      "      inline bool is_root (int x)        const {return prt.at(x) < 0;}",
      "",
      "      inline int  size    (int x)        const {return -prt.at(find(x));}",
      "",
      "      inline bool is_equiv(int x, int y) const {return find(x) == find(y);}",
      "",
      "      inline int  find    (int x)        const {",
      "        while (!is_root(x)) x = prt.at(x);",
      "        return x;",
      "      }",
      "",
      "      // If x and y are newly connected, returns `true`.",
      "      // The smaller one x becomes a child of the larger one y.",
      "      inline bool unite   (int x, int y) {",
      "        if ((x = find(x)) == (y = find(y))) return false;",
      "        if (size(x) > size(y)) std::swap(x, y);",
      "        prt.at(y) += prt.at(x);",
      "        prt.at(x) = y;",
      "        return true;",
      "      }",
      "};"
    ],
    "prefix": "union_find_tree"
  },
  "../src/lib/graph_algorithms/bellman_ford.cpp": {
    "body": [
      "template <typename T>",
      "class bellman_ford {",
      "  using edge_t = tuple<T, int, int>;",
      "  const int n, r;",
      "  const std::vector<edge_t>& edg;",
      "  bool flg;",
      "  std::vector<long long> dst;",
      "  void cal () {",
      "      dst[r] = 0;",
      "      for (int q = n; q--;) {",
      "        flg = false;",
      "        for (auto const& e : edg) {",
      "          T d; int s, t; std::tie(d, s, t) = e;",
      "          if (dst[s] == inf) continue;",
      "          if (cmn(dst[t], dst[s] + d)) flg = true;",
      "        }",
      "      }",
      "  }",
      "  public:",
      "    const T inf;",
      "    bellman_ford (",
      "        const int n, const int r,",
      "        const std::vector<edge_t>& edg,",
      "        const T inf = numeric_limits<T>::max()",
      "      ) :",
      "      n(n), r(r), edg(edg), ",
      "      flg(false), dst(n, inf), inf(inf)",
      "      {",
      "        cal();",
      "      }",
      "    bellman_ford (",
      "        const int n, const int r,",
      "        const std::vector<edge_t>& edg",
      "      ) :",
      "      bellman_ford(n, r, edg, numeric_limits<T>::max())",
      "      {",
      "      }",
      "    bool has_negative_cycle () const {return flg;}",
      "    auto& result () {return dst;}",
      "};"
    ],
    "prefix": "bellman_ford"
  },
  "../src/lib/graph_algorithms/bipartite_matching.cpp": {
    "body": [
      "class bipartite_matching {",
      "  int x, y;",
      "  dinic<int> dnc;",
      "  public:",
      "    bipartite_matching(int x, int y) :",
      "      x(x), y(y), dnc([x, y]{",
      "        dinic<int> dnc(1 + x + y + 1, 0, 1 + x + y);",
      "        for (int i = 0; i < x; i++) dnc.insert(0, 1 + i, 1);",
      "        for (int j = 0; j < y; j++) dnc.insert(1 + x + j, 1 + x + y, 1);",
      "        return dnc;",
      "      }())",
      "      {}",
      "    void insert (int i, int j) {",
      "      dnc.insert(1 + i, 1 + x + j, 1);",
      "    }",
      "    int cal () {return dnc.cal();}",
      "};"
    ],
    "prefix": "bipartite_matching"
  },
  "../src/lib/graph_algorithms/centroid.cpp": {
    "body": [
      "class centroid_tree {",
      "  const int n;",
      "  const std::vector<std::vector<int>> grh;",
      "  std::vector<bool> ckd;",
      "  std::vector<std::vector<int>> ctr;",
      "  queue<tuple<int, int, int>> que;",
      "  int rt = -1;",
      "  void build ()",
      "    {",
      "      std::vector<int> sz(n);",
      "      que.emplace(-1, 0, n);",
      "      while (!que.empty()) {",
      "        int prv_ctr, start, bkt; std::tie(prv_ctr, start, bkt) = que.front(); que.pop();",
      "        int new_ctr = -1;",
      "        make_fixed_point ([&](auto dfs, int crr, int prt) -> void {",
      "            sz[crr] = 1;",
      "            for (auto const& nxt : grh[crr]) if (nxt != prt && !ckd[nxt]) {",
      "              dfs(nxt, crr); if (new_ctr != -1) return;",
      "              sz[crr] += sz[nxt];",
      "            }",
      "            if (sz[crr] * 2 >= bkt) {",
      "              for (auto const& nxt : grh[crr]) if (!ckd[nxt]) {",
      "                if (nxt != prt) que.emplace(crr, nxt, sz[nxt]);",
      "                else que.emplace(crr, nxt, bkt - sz[crr]);",
      "              }",
      "              ckd[crr] = true;",
      "              new_ctr = crr;",
      "            }",
      "          })(start, start);",
      "        if (prv_ctr == -1) rt = new_ctr;",
      "        else ctr[prv_ctr].push_back(new_ctr);",
      "      }",
      "    }",
      "  public:",
      "    centroid_tree (",
      "        std::vector<std::vector<int>> grh",
      "      ) :",
      "      n(grh.size()),",
      "      grh(grh), ckd(n, false),",
      "      ctr(n)",
      "      {",
      "        build();",
      "      }",
      "    auto const centroid () const {return rt;}",
      "    auto const& result () const {return ctr;}",
      "    auto const& operator [] (int i) const {return ctr[i];}",
      "    auto const size () const {return n;}",
      "};"
    ],
    "prefix": "centroid"
  },
  "../src/lib/graph_algorithms/dfs1.cpp": {
    "body": [
      "fix ([&](auto dfs, int crr, int p) -> void {",
      "  for (auto const& nxt : graph.at(crr)) {",
      "    if (nxt == p) continue;",
      "    dfs(nxt, crr);",
      "  }",
      "})(${1:root}, $1);"
    ],
    "prefix": "dfs1"
  },
  "../src/lib/graph_algorithms/dfs2.cpp": {
    "body": [
      "fix ([&](auto dfs, int crr) -> void {",
      "  ckd.at(crr) = true;",
      "  for (auto const& nxt : graph.at(crr)) {",
      "    if (ckd.at(nxt)) continue;",
      "    dfs(nxt);",
      "  }",
      "})(${1:root});"
    ],
    "prefix": "dfs2"
  },
  "../src/lib/graph_algorithms/diameter.cpp": {
    "body": [
      "template<typename T>",
      "class diameter {",
      "    struct edge {",
      "      size_t to; T cost;",
      "      edge(size_t to, T cost) : to(to), cost(cost){}",
      "    };",
      "    size_t n;",
      "    std::vector<std::vector<edge>> graph;",
      "",
      "  public:",
      "    diameter(size_t n) : n(n), graph(n){}",
      "",
      "    // Insert an edge.",
      "    void insert(size_t i, size_t j, T cost = 1) {",
      "      assert(0 <= i && i < n);",
      "      assert(0 <= j && j < n);",
      "      graph.at(i).emplace_back(j, cost);",
      "      graph.at(j).emplace_back(i, cost);",
      "    };",
      "",
      "    // Calculate the diameter.",
      "    auto operator()(size_t root = 0){",
      "      std::vector<T> depth; ",
      "      auto cal = [&] (size_t r) {",
      "        depth.assign(n, 0);",
      "        fix ([&](auto dfs, size_t crr, size_t p) -> void {",
      "          for (auto const& e : graph.at(crr)) {",
      "            if (e.to == p) continue;",
      "            depth.at(e.to) = depth.at(crr) + e.cost;",
      "            dfs(e.to, crr);",
      "          }",
      "        })(r, r);",
      "      };",
      "      cal(root);",
      "      auto ex = std::max_element(depth.begin(), depth.end()) - depth.begin();",
      "      cal(ex);",
      "      return *std::max_element(depth.begin(), depth.end());",
      "    }",
      "};"
    ],
    "prefix": "diameter"
  },
  "../src/lib/graph_algorithms/dijkstra.cpp": {
    "body": [
      "template <typename T>",
      "class dijkstra {",
      "  const int n, r;",
      "  const std::vector<std::vector<std::pair<T, int>>>& grh;",
      "  std::vector<T> dst;",
      "  void cal () {",
      "    priority_queue<",
      "      std::pair<T, int>, std::vector<std::pair<T, int>>, greater<std::pair<T, int>>",
      "      > que;",
      "    que.emplace(0, r);",
      "    while (!que.empty()) {",
      "      T crd; int crr; std::tie(crd, crr) = que.top(), que.pop();",
      "      if (!cmn(dst[crr], crd)) continue;",
      "      for (auto e : grh[crr]) {",
      "        T w; int nxt; std::tie(w, nxt) = e;",
      "        T nxd = crd + w;",
      "        if (nxd < dst[nxt]) que.emplace(nxd, nxt);",
      "      }",
      "    }",
      "  }",
      "  public:",
      "    const T inf;",
      "    dijkstra (",
      "        const int r,",
      "        const std::vector<std::vector<std::pair<T, int>>>& grh,",
      "        const T inf = numeric_limits<T>::max()",
      "      ) :",
      "      n(grh.size()), r(r),",
      "      grh(grh), dst(n, inf), inf(inf)",
      "      {",
      "        cal();",
      "      }",
      "    auto result () const {return dst;}",
      "};"
    ],
    "prefix": "dijkstra"
  },
  "../src/lib/graph_algorithms/dinic.cpp": {
    "body": [
      "template <typename T>",
      "class dinic {",
      "  struct edge {",
      "    int to; T cap;",
      "    weak_ptr<edge> rev;",
      "  };",
      "  const int n, source, sink;",
      "  std::vector<bool> ckd;",
      "  std::vector<int> dst;",
      "  std::vector<std::vector<shared_ptr<edge>>> grh;",
      "  static constexpr T inf = numeric_limits<T>::max();",
      "  void bfs () {",
      "    queue<int> que;",
      "    que.emplace(source); dst[source] = 0;",
      "    while (!que.empty()) {",
      "      int crr = que.front(); que.pop();",
      "      for (auto const& e : grh[crr]) {",
      "        if (e->cap == 0) continue;",
      "        int nxt = e->to;",
      "        if (dst[nxt] != -1) continue;",
      "        que.push(nxt); dst[nxt] = dst[crr] + 1;",
      "      }",
      "    }",
      "  }",
      "  T dfs () {",
      "    return fix ([&](auto dfs, int crr, int f = inf) -> T {",
      "      if (crr == sink) return f;",
      "      ckd[crr] = true;",
      "      for (auto& e : grh[crr]) {",
      "        int nxt = e->to;",
      "        if (ckd[nxt] || e->cap == 0 || dst[crr] >= dst[nxt]) continue;",
      "        T d = dfs(nxt, min(f, e->cap));",
      "        if (d > 0) {",
      "          e->cap -= d;",
      "          e->rev.lock()->cap += d;",
      "          return d;",
      "        }",
      "      }",
      "      dst[crr] = -1;",
      "      return 0;",
      "    })(source);",
      "  }",
      "  public:",
      "    dinic (int n, int source, int sink) :",
      "      n(n), source(source), sink(sink), grh(n)",
      "      {}",
      "    void insert(int u, int v, T c) {",
      "      auto e = make_shared<edge>(edge{v, c});",
      "      auto r = make_shared<edge>(edge{u, 0});",
      "      e->rev = r;",
      "      r->rev = e;",
      "      grh[u].push_back(e);",
      "      grh[v].push_back(r);",
      "    }",
      "    T cal() {",
      "      T ret = 0;",
      "      while (true) {",
      "        dst.assign(n, -1);",
      "        bfs();",
      "        if (dst[sink] == -1) return ret;",
      "        ckd.assign(n, false);",
      "        while (true) {",
      "          T f = dfs();",
      "          if (f == 0) break;",
      "          ret += f;",
      "        }",
      "      }",
      "    }",
      "};"
    ],
    "prefix": "dinic"
  },
  "../src/lib/graph_algorithms/floyd_warshall.cpp": {
    "body": [
      "template<typename T>",
      "struct floyd_warshall {",
      "  const int n;",
      "  const T inf;",
      "  std::vector<std::vector<T>> dst;",
      "  void cal () {",
      "    for (int k = 0; k < n; k++) {",
      "      for (int i = 0; i < n; i++) {",
      "        for (int j = 0; j < n; j++) {",
      "          if (dst[i][k] != inf && dst[k][j] != inf) {",
      "            cmn(dst[i][j], dst[i][k] + dst[k][j]);",
      "          }",
      "        }",
      "      }",
      "    }",
      "  }",
      "  floyd_warshall (",
      "      const std::vector<std::vector<T>> adj,",
      "      const T inf",
      "    ) :",
      "    n(adj.size()), inf(inf), dst(adj)",
      "    {",
      "      cal();",
      "    }",
      "  auto& result () {return dst;}",
      "  bool has_negative_cycle () {",
      "    for (int i = 0; i < n; i++) if (dst[i][i] < 0) return true;",
      "    return false;",
      "  }",
      "};"
    ],
    "prefix": "floyd_warshall"
  },
  "../src/lib/graph_algorithms/ford_fulkerson.cpp": {
    "body": [
      "template <typename T>",
      "class ford_fulkerson {",
      "  struct edge {",
      "    int to; T cap;",
      "    weak_ptr<edge> rev;",
      "    edge(int to, T cap) : to(to), cap(cap) {}",
      "  };",
      "  const int n, source, sink;",
      "  std::vector<bool> ckd;",
      "  std::vector<std::vector<shared_ptr<edge>>> grh;",
      "  static constexpr T inf = numeric_limits<T>::max();",
      "  T dfs () {",
      "    return fix ([&](auto dfs, int crr, int f = inf) -> T {",
      "      if (crr == sink) return f;",
      "      ckd[crr] = true;",
      "      for (auto& e : grh[crr]) {",
      "        if (ckd[e->to] || !e->cap) continue;",
      "        T d = dfs(e->to, min(f, e->cap));",
      "        if (d) {",
      "          e->cap -= d;",
      "          e->rev.lock()->cap += d;",
      "          return d;",
      "        }",
      "      }",
      "      return 0;",
      "    })(source);",
      "  }",
      "  public:",
      "    ford_fulkerson (int n, int source, int sink) :",
      "      n(n), source(source), sink(sink), grh(n)",
      "      {}",
      "    void insert(int u, int v, T c) {",
      "      auto e = make_shared<edge>(v, c);",
      "      auto r = make_shared<edge>(u, 0);",
      "      e->rev = r;",
      "      r->rev = e;",
      "      grh[u].push_back(e);",
      "      grh[v].push_back(r);",
      "    }",
      "    T cal() {",
      "      T ret = 0;",
      "      while (true) {",
      "        ckd.assign(n, false);",
      "        T f = dfs();",
      "        if (!f) return ret;",
      "        ret += f;",
      "      }",
      "    }",
      "};"
    ],
    "prefix": "ford_fulkerson"
  },
  "../src/lib/graph_algorithms/grid_bfs.cpp": {
    "body": [
      "std::vector<std::vector<${1:long long}>> dst(h, std::vector<$1>(w, ${4:-1}));",
      "queue<std::pair<int, int>> que;",
      "dst[${2:si}][${3:sj}] = 0, que.emplace($2, $3);",
      "while (!que.empty()) {",
      "  int cri, crj;",
      "  std::tie(cri, crj) = que.front(), que.pop();",
      "  for (int k = 0; k < 4; k++) {",
      "    int nxi = cri + di[k];",
      "    int nxj = crj + dj[k];",
      "    if (",
      "        0 <= nxi && nxi < h &&",
      "        0 <= nxj && nxj <= w &&",
      "        dst[nxi][nxj] == $4 &&",
      "        !grd[nxi][nxj]",
      "      ) dst[nxi][nxj] = dst[cri][crj] + 1, que.emplace(nxi, nxj);",
      "  }",
      "}"
    ],
    "prefix": "grid_bfs"
  },
  "../src/lib/graph_algorithms/heavy_light_decomposition.cpp": {
    "body": [
      "// Dependent libraries: Combinator.",
      "template <typename T>",
      "class heavy_light_decomposition {",
      "    struct edge {size_t to; T cost;};",
      "    bool built; size_t n;",
      "    std::vector<std::vector<edge>> graph;",
      "    std::vector<size_t>             prt, sub, vid, head;",
      "    std::vector<unsigned>           unweighted_depth;",
      "    std::vector<T>                 weighted_depth;",
      "",
      "  public:",
      "    using edge_type = edge;",
      "    using cost_type = T;",
      "    heavy_light_decomposition(size_t n) :",
      "      built(false), n(n),",
      "      graph(n), prt(n), sub(n, 1), vid(n), head(n),",
      "      unweighted_depth(n, 0), weighted_depth(n, 0) {}",
      "    ",
      "    // Get the vertex id.",
      "    auto id (size_t u) const -> size_t {",
      "      return vid.at(u);}",
      "",
      "    // Insert an edge.",
      "    void insert (size_t u, size_t v, T cost = 1) {",
      "        assert(!built);",
      "        graph.at(u).push_back({v, cost});",
      "        graph.at(v).push_back({u, cost});",
      "      }",
      "    // Deflag the built flag.",
      "    void deflag () {",
      "        assert(built);",
      "        built = false;",
      "      }",
      "    // Build an HL Decomposition.",
      "    void build (size_t root = 0) {",
      "        assert(!built); built = true;",
      "        fix ([&](auto dfs, size_t crr, size_t p) -> void {",
      "          prt.at(crr) = p;",
      "          for (auto& e : graph.at(crr)) {",
      "            if (e.to == p) continue;",
      "            unweighted_depth.at(e.to) = unweighted_depth.at(crr) + 1;",
      "            weighted_depth.at(e.to)   = weighted_depth.at(crr) + e.cost;",
      "            dfs(e.to, crr);",
      "            sub.at(crr) += sub.at(e.to);",
      "            if (sub.at(e.to) > sub.at(graph.at(crr).front().to))",
      "              std::swap(e, graph.at(crr).front());",
      "          }",
      "        })(root, root);",
      "        size_t now = 0; head.at(root) = root;",
      "        fix ([&](auto dfs, size_t crr, size_t p) -> void {",
      "          vid.at(crr) = now, now++;",
      "          for (auto const& e : graph.at(crr)) {",
      "            if (e.to == p) continue;",
      "            head.at(e.to) = (e.to == graph.at(crr).front().to",
      "              ? head.at(crr) : e.to);",
      "            dfs(e.to, crr);",
      "          }",
      "        })(root, root);",
      "      }",
      "    // Call a function f([u, v]),",
      "    // where u and v is the original vertex id,",
      "    // while the parameter of f is by the HLD-order. ",
      "    template <typename F>",
      "    auto for_each_edge (size_t u, size_t v, F f) const",
      "      -> void",
      "      {",
      "        assert(built);",
      "        while (head.at(u) != head.at(v)) {",
      "          if (vid.at(u) > vid.at(v)) std::swap(u, v);",
      "          f(vid.at(head.at(v)), vid.at(v));",
      "          v = prt.at(head.at(v));",
      "        }",
      "        if (vid.at(u) > vid.at(v)) std::swap(u, v);",
      "        if (u != v) f(vid.at(u) + 1, vid.at(v));",
      "      }",
      "    // Calculate the lowest common ancestor.",
      "    auto lca (size_t u, size_t v) const -> size_t {",
      "        assert(built);",
      "        while (head.at(u) != head.at(v)) {",
      "          if (vid.at(u) > vid.at(v)) std::swap(u, v);",
      "          v = prt.at(head.at(v));",
      "        }",
      "        return vid.at(u) < vid.at(v) ? u : v;",
      "      }",
      "    // Calculate the count-based distance between u and v.",
      "    auto unweighted_dist (size_t u, size_t v) const -> unsigned {",
      "        auto& x = unweighted_depth;",
      "        return x.at(u) + x.at(v) - 2 * x.at(lca(u, v));",
      "      }",
      "    // Calculate the cost-based distance between u and v.",
      "    auto weighted_dist (size_t u, size_t v) const -> unsigned {",
      "        auto& x = weighted_depth;",
      "        return x.at(u) + x.at(v) - 2 * x.at(lca(u, v));",
      "      }",
      "};"
    ],
    "prefix": "heavy_light_decomposition"
  },
  "../src/lib/graph_algorithms/heights.cpp": {
    "body": [
      "template<typename T>",
      "class calculate_heights {",
      "  const int n;",
      "  const std::vector<std::vector<std::pair<T, int>>>& grh;",
      "  std::vector<T> dp, ep;",
      "",
      "  void dfs (",
      "      int crr = 0,",
      "      int prt = 0",
      "    ) {",
      "      for (auto const& e : grh[crr]) {",
      "        T w; int nxt; std::tie(w, nxt) = e;",
      "        if (nxt == prt) continue;",
      "        dfs(nxt, crr);",
      "        chmax(dp[crr], dp[nxt] + w);",
      "      }",
      "    }",
      "",
      "  void efs (",
      "      int crr = 0,",
      "      int prt = 0",
      "    ) {",
      "      std::vector<T> cld = {ep[crr]};",
      "      for (auto const& e : grh[crr]) {",
      "        T w; int nxt; std::tie(w, nxt) = e;",
      "        if (nxt == prt) continue;",
      "        cld.push_back(dp[nxt] + w);",
      "      }",
      "      sort(cld.begin(), cld.end(), greater<T>());",
      "      for (auto const& e : grh[crr]) {",
      "        T w; int nxt; std::tie(w, nxt) = e;",
      "        if (nxt == prt) continue;",
      "        ep[nxt] = dp[nxt] + w == cld[0] ?",
      "            cld[1] + w : cld[0] + w;",
      "      }",
      "      for (auto const& e : grh[crr]) {",
      "        T w; int nxt; std::tie(w, nxt) = e;",
      "        if (nxt == prt) continue;",
      "        efs(nxt, crr);",
      "      }",
      "      chmax(dp[crr], ep[crr]);",
      "    }",
      "",
      "  public:",
      "    calculate_heights(",
      "        std::vector<std::vector<std::pair<T, int>>>& grh",
      "      ) :",
      "      n(grh.size()),",
      "      grh(grh),",
      "      dp(n, 0),",
      "      ep(n, 0)",
      "      {",
      "        dfs();",
      "        efs();",
      "      }",
      "    ",
      "    auto operator[] (int i) const -> const T {return dp[i];}",
      "};"
    ],
    "prefix": "heights"
  },
  "../src/lib/graph_algorithms/inner_dfs1.cpp": {
    "body": [
      "  void dfs (",
      "      int crr = 0,",
      "      int prt = 0",
      "    ) {",
      "      for (int const& nxt : grh[crr]) {",
      "        ${2:T} w; int nxt; std::tie(w, nxt) = e;",
      "        if (nxt == prt) continue;",
      "        dfs(nxt, crr);",
      "        chmax(dp[crr], dp[nxt] + w);",
      "      }",
      "    }"
    ],
    "prefix": "inner_dfs1"
  },
  "../src/lib/graph_algorithms/kruskal.cpp": {
    "body": [
      "template<typename T>",
      "struct kruskal {",
      "  using edge_type = tuple<T, int, int>;",
      "  const int n;",
      "  std::vector<edge_type> edg;",
      "  std::vector<edge_type> mst;",
      "  T weight_of_mst;",
      "  kruskal (",
      "      int n,",
      "      std::vector<edge_type> edg",
      "    ) :",
      "    n(n),",
      "    edg(edg),",
      "    mst(n - 1),",
      "    weight_of_mst(0)",
      "    {",
      "      sort(edg.begin(), edg.end());",
      "      disjoint_set djs(n);",
      "      int cnt = 0;",
      "      for (auto e : edg) {",
      "        T w; int s, t; std::tie(w, s, t) = e;",
      "        if (djs.unite(s, t)) {",
      "          weight_of_mst += w;",
      "          mst[cnt] = {w, s, t};",
      "          if (++cnt == n - 1) break;",
      "        }",
      "      }",
      "      if (cnt < n - 1) assert(false);",
      "    }    ",
      "};"
    ],
    "prefix": "kruskal"
  },
  "../src/lib/graph_algorithms/low_link_tree.cpp": {
    "body": [
      "struct low_link_tree {",
      "  const int n;",
      "  const int r = 0;",
      "  int tmr = 0;",
      "  std::vector<int> ord;",
      "  std::vector<int> low;",
      "  set<int> art;",
      "  set<std::pair<int, int>> bdg;",
      "  std::vector<std::vector<int>> grh;",
      "public:",
      "  low_link_tree (",
      "    std::vector<std::vector<int>> const& grh,",
      "    const int root",
      "  )",
      "  : n(grh.size())",
      "  , r(root)",
      "  , ord(n, -1)",
      "  , low(n, -1)",
      "  , grh(grh)",
      "  {",
      "    dfs(r, r);",
      "  }",
      "  void dfs (",
      "    int crr",
      "  ,  int prt",
      "  ) {",
      "    int cnt = 0;",
      "    ord[crr] = low[crr] = tmr++;",
      "    for (int nxt : grh[crr]) {",
      "      if (ord[nxt] == -1) {",
      "        cnt++;",
      "        dfs(nxt, crr);",
      "        chmin(low[crr], low[nxt]);",
      "        if (crr != r && ord[crr] <= low[nxt]) art.insert(crr);",
      "        if (ord[crr] < low[nxt]) bdg.emplace(min(crr, nxt), max(crr, nxt));",
      "      }",
      "      if (nxt != prt) chmin(low[crr], ord[nxt]);",
      "    }",
      "    if (crr == r && cnt > 1) art.insert(crr);",
      "  }",
      "};"
    ],
    "prefix": "low_link_tree"
  },
  "../src/lib/graph_algorithms/lowest_common_ancestor.cpp": {
    "body": [
      "// Class for calculating LCA.",
      "// Dependent libraries: Combinator.",
      "template <typename T>",
      "class lowest_common_ancestor {",
      "    struct edge {",
      "        size_t to; T cost;",
      "        edge(size_t to, T cost) : to(to), cost(cost){}",
      "      };",
      "    size_t n, lg;",
      "    std::vector<std::vector<edge>>   graph;",
      "    std::vector<unsigned>            depth;",
      "    std::vector<T>                   weighted_depth;",
      "    std::vector<std::vector<size_t>> prt;",
      "  public:",
      "    using cost_type = T;",
      "    lowest_common_ancestor(size_t n) :",
      "      n(n), lg(std::log2(n)),",
      "      graph(n), depth(n, 0), weighted_depth(n, 0),",
      "      prt(lg + 1, std::vector<size_t>(n)) {}",
      "    // Insert an edge.",
      "    void insert (size_t u, size_t v, T cost = 1) {",
      "        graph.at(u).emplace_back(v, cost);",
      "        graph.at(v).emplace_back(u, cost);",
      "      }",
      "    // Build a doubling table.",
      "    void build (size_t root = 0) {",
      "        fix ([&](auto dfs, size_t crr, size_t p) -> void {",
      "          prt.at(0).at(crr) = p;",
      "          for (auto const& e : graph.at(crr)) {",
      "            if (e.to == p) continue;",
      "            depth.at(e.to) = depth.at(crr) + 1;",
      "            weighted_depth.at(e.to) = weighted_depth.at(crr) + e.cost;",
      "            dfs(e.to, crr);",
      "          }",
      "        })(root, root);",
      "        for (size_t p = 1; p <= lg; p++) {",
      "          for (size_t i = 0; i < n; i++) {",
      "            prt.at(p).at(i) = prt.at(p - 1).at(prt.at(p - 1).at(i));",
      "          }",
      "        }",
      "      }",
      "    // Calculate the lca.",
      "    auto operator()(size_t u, size_t v) const -> size_t {",
      "        if (depth.at(u) < depth.at(v)) std::swap(u, v);",
      "        auto diff = depth.at(u) - depth.at(v);",
      "        if (diff > 0) {",
      "          for (size_t p = lg, q = std::pow(2, lg); p <= lg; p--, q /= 2) {",
      "            if (diff > q) u = prt.at(p).at(u), diff -= q;",
      "          }",
      "          u = prt.at(0).at(u), diff--;",
      "        }",
      "        assert(diff == 0), assert(depth.at(u) == depth.at(v));",
      "        if (u == v) return u;",
      "        for (size_t p = lg, q = std::pow(2, lg); p <= lg; p--, q /= 2) {",
      "          auto next_u = prt.at(p).at(u);",
      "          auto next_v = prt.at(p).at(v);",
      "          if (next_u != next_v) u = next_u, v = next_v;",
      "        }",
      "        assert(u != v);",
      "        u = prt.at(0).at(u), v = prt.at(0).at(v), assert(u == v);",
      "        return u;",
      "      }",
      "    // Calculate the count-based distance.",
      "    auto row_dist (size_t u, size_t v) const -> unsigned {",
      "      return depth.at(u) + depth.at(v) - 2 * depth.at(operator()(u, v));}",
      "    // Calculate the count-based distance.",
      "    auto weighted_dist (size_t u, size_t v) const -> T {",
      "      auto& x = weighted_depth;",
      "      return x.at(u) + x.at(v) - 2 * x.at(operator()(u, v));}",
      "};"
    ],
    "prefix": "lowest_common_ancestor"
  },
  "../src/lib/graph_algorithms/minimum_cost_flow.cpp": {
    "body": [
      "template <typename T, typename U>",
      "class minimum_cost_flow {",
      "  public:",
      "    const T max_flow = numeric_limits<T>::max();",
      "    const U max_dist  = numeric_limits<U>::max();",
      "  private:",
      "    struct edge {",
      "      int to; T cap; U cost;",
      "      weak_ptr<edge> rev;",
      "    };",
      "    const int n, source, sink;",
      "    std::vector<U> dst;",
      "    std::vector<std::vector<shared_ptr<edge>>> grh;",
      "    void bf () {",
      "      dst.assign(n, max_dist); dst[source] = 0;",
      "      for (int t = 0; t < n; t++) {",
      "        bool flg = false;",
      "        for (int i = 0; i < n; i++) {",
      "          for (auto const& e : grh[i]) {",
      "            if (e->cap == 0) continue;",
      "            int crr = i;     U crd = dst[crr];",
      "            int nxt = e->to; U nxd = crd + e->cost;",
      "            if (crd == max_dist) continue;",
      "            if (cmn(dst[nxt], nxd)) flg = true;",
      "          }",
      "        }",
      "        if (!flg) break;",
      "        if (t == n - 1 && flg) assert(false);",
      "      }",
      "    }",
      "    U flush () {",
      "      std::vector<bool> ckd(n, false);",
      "      return fix([&] (auto dfs, int crr, U f) -> U {",
      "        if (ckd[crr]) return 0;",
      "        ckd[crr] = true;",
      "        if (crr == sink) return f;",
      "        for (auto const& e : grh[crr]) {",
      "        if (e->cap == 0) continue;",
      "          U crd = dst[crr];",
      "          int nxt = e->to; U nxd = dst[nxt];",
      "          if (crd + e->cost != nxd) continue;",
      "          U d = dfs(nxt, min(f, e->cap));",
      "          if (d > 0) {",
      "            e->cap -= d;",
      "            e->rev.lock()->cap += d;",
      "            return d;",
      "          }",
      "        }",
      "        return 0;",
      "      })(source, max_flow);",
      "    }",
      "  public:",
      "    minimum_cost_flow (int n, int source, int sink) :",
      "      n(n), source(source), sink(sink), grh(n)",
      "      {}",
      "    void insert(int u, int v, T cap, U cost) {",
      "      auto e = make_shared<edge>(edge{v, cap, cost});",
      "      auto r = make_shared<edge>(edge{u, 0, -cost});",
      "      e->rev = r;",
      "      r->rev = e;",
      "      grh[u].push_back(e);",
      "      grh[v].push_back(r);",
      "    }",
      "    T cal(U required_flow) {",
      "      T ret = 0;",
      "      while (true) {",
      "        bf();",
      "        if (dst[sink] == max_dist) break;",
      "        T d = dst[sink]; U f = flush();",
      "        if (f >= required_flow) {",
      "          ret += d * required_flow;",
      "          return ret;",
      "        } else {",
      "          ret += d * f;",
      "          required_flow -= f;",
      "        }",
      "      }",
      "      return -1;",
      "    }",
      "};"
    ],
    "prefix": "minimum_cost_flow"
  },
  "../src/lib/graph_algorithms/prim.cpp": {
    "body": [
      "template <typename T>",
      "struct prim {",
      "  const int n;",
      "  std::vector<std::vector<std::pair<T, int>>> grh;",
      "  T weight_of_mst;",
      "  prim (",
      "      std::vector<std::vector<std::pair<T, int>>> grh",
      "    ) :",
      "    n(grh.size()),",
      "    grh(grh),",
      "    weight_of_mst(0)",
      "    {",
      "      std::vector<bool> ckd(n, false);",
      "      priority_queue<",
      "        std::pair<T, int>,",
      "        std::vector<std::pair<T, int>>,",
      "        greater<std::pair<T, int>>",
      "      > que;",
      "      que.emplace(0, 0);",
      "      while (!que.empty()) {",
      "        T w; int t;",
      "        std::tie(w, t) = que.top(), que.pop();",
      "        if (ckd[t]) continue;",
      "        weight_of_mst += w, ckd[t] = true;",
      "        for (auto p : grh[t]) que.push(p);",
      "      }",
      "    }",
      "};"
    ],
    "prefix": "prim"
  },
  "../src/lib/graph_algorithms/topological_sort_1.cpp": {
    "body": [
      "class topological_sort {",
      "  const int n;",
      "  const std::vector<std::vector<int>>& grh;",
      "  std::vector<int> srd;",
      "  std::vector<int> ckd;",
      "  bool flg;",
      "",
      "  bool dfs (int crr) {",
      "    if (ckd[crr] == 1) return true;",
      "    if (ckd[crr] == 2) return false;",
      "    bool ret = false;",
      "    ckd[crr] = 1;",
      "    for (int nxt : grh[crr]) {",
      "      ret |= dfs(nxt);",
      "    }",
      "    ckd[crr] = 2;",
      "    srd.insert(srd.begin(), crr);",
      "    return ret;",
      "  }",
      "",
      "  public:",
      "    topological_sort (",
      "        const std::vector<std::vector<int>>& grh",
      "      ) :",
      "      n(grh.size()),",
      "      grh(grh),",
      "      srd(),",
      "      ckd(n, 0),",
      "      flg(",
      "          [&](){",
      "            bool ret = false;",
      "            for (int i = 0; i < n; i++) {",
      "              flg |= (ckd[i] == 0 && dfs(i));",
      "            }",
      "            return ret;",
      "          }()",
      "        )",
      "      {",
      "      }",
      "    bool has_cycle () {return flg;}",
      "    auto sorted() const -> const std::vector<int>& {return srd;}",
      "    auto operator [] (int i) const -> int {return srd[i];}",
      "};"
    ],
    "prefix": "topological_sort_1"
  },
  "../src/lib/graph_algorithms/topological_sort_2.cpp": {
    "body": [
      "// none (tail)"
    ],
    "prefix": "topological_sort_2"
  },
  "../src/lib/intervals_and_strings/binary_serch.cpp": {
    "body": [
      "${1:int} ok = ${2:0}, ng = ${3:inf}, md;",
      "while (abs(ok - ng) > 1) {",
      "  md = (ok + ng) >> 1;",
      "  if (${4:ck(md)}) ok = md;",
      "  else ng = md;",
      "}"
    ],
    "prefix": "binary_serch"
  },
  "../src/lib/intervals_and_strings/lis.cpp": {
    "body": [
      "std::vector<${1:int}> lis;",
      "for (auto crr : ${2:name}) {",
      "  auto lb = std::lower_bound(lis.begin(), lis.end(), crr);",
      "  if (lb == lis.end()) lis.push_back(crr);",
      "  else *lb = crr;",
      "}"
    ],
    "prefix": "lis"
  },
  "../src/lib/intervals_and_strings/slide_minimum.cpp": {
    "body": [
      "template <typename T, class Compare = less<T>>",
      "class slide_minimum {",
      "  public:",
      "  const std::vector<T> a;",
      "  Compare cmp;",
      "  deque<int> que;",
      "  int l, r;",
      "    slide_minimum(",
      "        const std::vector<T>& a",
      "      ) :",
      "      a(a), cmp(Compare()), l(0), r(0)",
      "      {",
      "      }",
      "    inline void luc () {",
      "      if (que.front() == l++) {",
      "        que.pop_front();",
      "      }",
      "    }",
      "    inline void ruc () {",
      "      while (!que.empty() && !cmp(a[que.back()], a[r])) {",
      "        que.pop_back();",
      "      }",
      "      que.push_back(r++);",
      "    }",
      "    inline auto query () const -> T {",
      "      assert(!que.empty());",
      "      return a[que.front()];",
      "    }",
      "    inline auto query_index () const -> int {",
      "      assert(!que.empty());",
      "      return que.front();",
      "    }",
      "};"
    ],
    "prefix": "slide_minimum"
  },
  "../src/lib/intervals_and_strings/sliding_window.cpp": {
    "body": [
      "/* init crr, ret */",
      "for (int l = 0, r = 0; l < n; l++) {",
      "  if (r <= l) {",
      "    r = l;",
      "    /* re-init crr */;",
      "  }",
      "  for (; r < n; r++) {",
      "    if (/* cannot push r */) break;",
      "    /* push r */;",
      "  }",
      "  ret += r - l;",
      "  /* pop l */",
      "}"
    ],
    "prefix": "sliding_window"
  },
  "../src/lib/number_theory/factorials.cpp": {
    "body": [
      "class factorials {",
      "    std::vector<mint> fact, finv;",
      "  public:",
      "    factorials(int n) : fact(n), finv(n) {",
      "      fact.at(0) = 1;",
      "      for (int i = 1; i < n; i++) fact.at(i) = fact.at(i - 1) * mint(i);",
      "      finv.at(n - 1) = mint(1) / fact.at(n - 1);",
      "      for (int i = n - 2; i >= 0; i--) finv.at(i) = finv.at(i + 1) * mint(i + 1);",
      "    }",
      "    // Returns the factorial.",
      "    template <typename T>",
      "    auto const& operator()(T i) const {return fact.at(i);}",
      "    // Returns the inverse of the factorial.",
      "    template <typename T>",
      "    auto const& inv(T i) const {return finv.at(i);}",
      "    // Returns the binominal coefficient.",
      "    template <typename T>",
      "    auto binom(T i, T j) const {",
      "      assert(0 <= i);",
      "      if (j < 0 ||i < j) return mint(0);",
      "      return fact.at(i) * finv.at(j) * finv.at(i - j);",
      "    }",
      "};"
    ],
    "prefix": "factorials"
  },
  "../src/lib/number_theory/factorize.cpp": {
    "body": [
      "class factorize {",
      "  int x;",
      "  map<int, int> mp;",
      "  std::vector<int> pdv;",
      "  std::vector<int> pdv_m;",
      "",
      "  public:",
      "    factorize(",
      "        const int x",
      "      ) :",
      "      x(x), mp(), pdv()",
      "      {",
      "        for (int p = 2; p * p <= x; p++) {",
      "          while (!(x % p)) {",
      "            mp[p]++;",
      "            pdv.push_back(p);",
      "            x /= p;",
      "          }",
      "        }",
      "        if (x != 1) mp[x] = 1;",
      "        pdv.push_back(x);",
      "        pdv_m = pdv.resize(unique(pdv.begin(), pdv.end()) - pdv.begin());",
      "      }",
      "    ",
      "    const auto& factorize () const {return pdv;}",
      "    const auto& prime_divisors () const {return pdv_m;}",
      "    const auto& multiplicities () const {return mp;}",
      "}"
    ],
    "prefix": "factorize"
  },
  "../src/lib/number_theory/gcd.cpp": {
    "body": [
      "template<typename T>",
      "T gcd (T a, T b) {",
      "  if (a < 0) a = -a;",
      "  if (b < 0) b = -b;",
      "  if (a < b) std::swap(a, b);",
      "  while (b) {",
      "    a %= b;",
      "    std::swap(a, b);",
      "  }",
      "  return a;",
      "}"
    ],
    "prefix": "gcd"
  },
  "../src/lib/number_theory/mint.cpp": {
    "body": [
      "template <typename T>",
      "T inverse(T a, T m) {",
      "  T u = 0, v = 1;",
      "  while (a != 0) {",
      "    T t = m / a;",
      "    m -= t * a; std::swap(a, m);",
      "    u -= t * v; std::swap(u, v);",
      "  }",
      "  assert(m == 1);",
      "  return u;",
      "}",
      "template <typename T>",
      "class modular {",
      "  private:",
      "    int value;",
      "  public:",
      "    constexpr modular() = default;",
      "    constexpr modular(const modular&) = default;",
      "    constexpr modular(modular&&) = default;",
      "    modular& operator=(const modular&) = default;",
      "    modular& operator=(modular&&) = default;",
      "",
      "    template <typename U>",
      "    modular (const U& x) {value = normalize(x);}",
      "",
      "    template <typename U>",
      "    static auto normalize(const U& x) {",
      "      int v = static_cast<int>(-mod() <= x && x < mod() ? x : x % mod());",
      "      if (v < 0) v += mod();",
      "      return v;",
      "    }",
      "",
      "    auto const& operator()() const { return value; }",
      "    template <typename U>",
      "    explicit operator U() const { return static_cast<U>(value); }",
      "    constexpr static auto mod() { return T::value; }",
      "",
      "    auto& operator+=(const modular& other) {",
      "      if ((value += other.value) >= mod()) value -= mod();",
      "      return *this;",
      "    }",
      "    auto& operator-=(const modular& other) {",
      "      if ((value -= other.value) < 0) value += mod();",
      "      return *this;",
      "    }",
      "    template <typename U>",
      "    auto& operator+=(const U& other) {return *this += modular(other); }",
      "    template <typename U>",
      "    auto& operator-=(const U& other) {return *this -= modular(other); }",
      "    auto operator-() const { return modular(-value); }",
      "    auto& operator++() {return *this += 1;}",
      "    auto& operator--() {return *this -= 1;}",
      "    auto  operator++(int) {modular result(*this); operator++(); return result;}",
      "    auto  operator--(int) {modular result(*this); operator--(); return result;}",
      "  ",
      "    template <typename U = T>",
      "    auto& operator*=(const modular& rhs) {",
      "      value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));",
      "      return *this;",
      "    }",
      "    auto& operator/=(const modular& other) {",
      "      return *this *= modular(inverse(other.value, mod()));",
      "    }",
      "};",
      "template <typename T> struct is_modular : std::false_type {};",
      "template <typename T> struct is_modular <modular<T>> : std::true_type{};",
      "template <typename T> constexpr bool is_modular_v = is_modular<T>::value;",
      "",
      "template <typename T> bool operator==(const modular<T>& lhs, const modular<T>& rhs) { return lhs.value == rhs.value; }",
      "template <typename T, typename U> bool operator==(const modular<T>& lhs, U rhs) { return lhs == modular<T>(rhs); }",
      "template <typename T, typename U> bool operator==(U lhs, const modular<T>& rhs) { return modular<T>(lhs) == rhs; }",
      "",
      "template <typename T> bool operator!=(const modular<T>& lhs, const modular<T>& rhs) { return !(lhs == rhs); }",
      "template <typename T, typename U> bool operator!=(const modular<T>& lhs, U rhs) { return !(lhs == rhs); }",
      "template <typename T, typename U> bool operator!=(U lhs, const modular<T>& rhs) { return !(lhs == rhs); }",
      "",
      "template <typename T> modular<T> operator+(const modular<T>& lhs, const modular<T>& rhs) { return modular<T>(lhs) += rhs; }",
      "template <typename T, typename U> modular<T> operator+(const modular<T>& lhs, U rhs) { return modular<T>(lhs) += rhs; }",
      "template <typename T, typename U> modular<T> operator+(U lhs, const modular<T>& rhs) { return modular<T>(lhs) += rhs; }",
      "",
      "template <typename T> modular<T> operator-(const modular<T>& lhs, const modular<T>& rhs) { return modular<T>(lhs) -= rhs; }",
      "template <typename T, typename U> modular<T> operator-(const modular<T>& lhs, U rhs) { return modular<T>(lhs) -= rhs; }",
      "template <typename T, typename U> modular<T> operator-(U lhs, const modular<T>& rhs) { return modular<T>(lhs) -= rhs; }",
      "",
      "template <typename T> modular<T> operator*(const modular<T>& lhs, const modular<T>& rhs) { return modular<T>(lhs) *= rhs; }",
      "template <typename T, typename U> modular<T> operator*(const modular<T>& lhs, U rhs) { return modular<T>(lhs) *= rhs; }",
      "template <typename T, typename U> modular<T> operator*(U lhs, const modular<T>& rhs) { return modular<T>(lhs) *= rhs; }",
      "",
      "template <typename T> modular<T> operator/(const modular<T>& lhs, const modular<T>& rhs) { return modular<T>(lhs) /= rhs; }",
      "template <typename T, typename U> modular<T> operator/(const modular<T>& lhs, U rhs) { return modular<T>(lhs) /= rhs; }",
      "template <typename T, typename U> modular<T> operator/(U lhs, const modular<T>& rhs) { return modular<T>(lhs) /= rhs; }",
      "",
      "template<typename T, typename U>",
      "modular<T> pow (const modular<T>& a, U b) {",
      "  assert(b >= 0);",
      "  modular<T> x = a, ret = 1;",
      "  for (; b > 0; b /= 2) {",
      "    if (b % 2 == 1) ret *= x;",
      "    x *= x;",
      "  }",
      "  return ret;",
      "}",
      "",
      "template <typename T>",
      "std::string to_string(const modular<T>& a) {",
      "  return std::to_string(a());",
      "}",
      "template <typename T>",
      "auto operator<<(std::ostream& os, const T& a)",
      "  -> std::enable_if_t<is_modular_v<T>, std::ostream&>{",
      "    return os << a();",
      "  }",
      "template <typename T>",
      "auto operator>>(std::istream& is, T& a)",
      "  -> std::enable_if_t<is_modular_v<T>, std::istream&> {",
      "  long long x; is >> x;",
      "  a = T(x);",
      "  return is;",
      "}",
      "",
      "/*",
      "using ModType = int;",
      " ",
      "struct VarMod { static ModType value; };",
      "ModType VarMod::value;",
      "ModType& md = VarMod::value;",
      "using Mint = Modular<VarMod>;",
      "*/",
      "",
      "constexpr int md = 1'000'000'007;",
      "using mint = modular<std::integral_constant<std::decay_t<decltype(md)>, md>>;"
    ],
    "prefix": "mint"
  },
  "../src/lib/number_theory/old_mint.cpp": {
    "body": [
      "namespace mint {",
      "  int md;",
      "  inline void add (int &a, int b) {",
      "    assert(0 <= a && a < md && 0 <= b && b < md);",
      "    a += b; if (a >= md) a -= md;",
      "  }",
      "  inline void sub (int &a, int b) {",
      "    assert(0 <= a && a < md && 0 <= b && b < md);",
      "    a -= b; if (a < 0) a += md;",
      "  }",
      "  inline int sum (int a, int b) {",
      "    assert(0 <= a && a < md && 0 <= b && b < md);",
      "    add(a, b); return a;",
      "  }",
      "  inline int dif (int a, int b) {",
      "    assert(0 <= a && a < md && 0 <= b && b < md);",
      "    sub(a, b); return a;",
      "  }",
      "  template<class... A>",
      "  inline int prod (A... args) {",
      "    long long ret = 1;",
      "    for (int a :  std::initializer_list<int>{args...}) {",
      "      assert(0 <= a && a < md);",
      "      ret *= a;",
      "      ret %= md;",
      "    }",
      "    return (int)(ret % md);",
      "  }",
      "  inline void mul (int &a, int b) {",
      "    assert(0 <= a && a < md && 0 <= b && b < md);",
      "    a = prod(a, b);",
      "  }",
      "  inline int inv (int a) {",
      "    assert(0 <= a && a < md);",
      "    a %= md;",
      "    if(a < 0) a += md;",
      "    int b = md, u = 0, v = 1;",
      "    while (a) {",
      "      int t = b / a;",
      "      b -= a * t; std::swap(a, b);",
      "      u -= v * t; std::swap(u, v);",
      "    }",
      "    assert(b == 1);",
      "    if(u < 0) u += md;",
      "    return u;",
      "  }",
      "  inline int quot (int a, int b) {",
      "    assert(0 <= a && a < md && 0 <= b && b < md);",
      "    return prod(a, inv(b));",
      "  }",
      "  inline void div (int& a, int b) {",
      "    assert(0 <= a && a < md && 0 <= b && b < md);",
      "    a = quot(a, b);",
      "  }",
      "  inline int pow (int a, long long b) {",
      "    assert(0 <= a && a < md);",
      "    int res = 1;",
      "    for (; b; b >>= 1) {",
      "      if (b & 1) mul(res, a);",
      "      mul(a, a);",
      "    }",
      "    return res;",
      "  }",
      "  namespace factorials {",
      "    int sz;",
      "    std::vector<int> fact, finv;",
      "    void init (int n) {",
      "      sz = n;",
      "      fact.resize(n); finv.resize(n);",
      "      fact[0] = 1;",
      "      for (int i = 1; i < n; i++) fact[i] = prod(fact[i - 1], i);",
      "      finv[n - 1] = inv(fact[n - 1]);",
      "      for (int i = n - 2; i >= 0; i--) finv[i] = prod(finv[i + 1], i + 1);",
      "    }",
      "  }",
      "  inline int fct (int i) {",
      "    using namespace factorials;",
      "    assert(0 <= i && i < sz);",
      "    return fact[i];",
      "  }",
      "  inline int fnv (int i) {",
      "    using namespace factorials;",
      "    assert(0 <= i && i < sz);",
      "    return finv[i];",
      "  }",
      "  inline int binom (int n, int k) {",
      "    using namespace factorials;",
      "    assert(0 <= n && n < sz);",
      "    if (0 < k || n < k) return 0;",
      "    return prod(fact[n], finv[k], finv[n - k]);",
      "  }",
      "}"
    ],
    "prefix": "old_mint"
  },
  "../src/lib/number_theory/polynominal.cpp": {
    "body": [
      "template <typename T,",
      "  typename T::value_type zero, // TODO: not value_type, but T",
      "  typename T::value_type one,  // TODO: not value_type, but T",
      "  std::enable_if_t<",
      "    is_tropical_v<T>,",
      "  std::nullptr_t> = nullptr>",
      "class polynominal {",
      "  public:",
      "    using value_type     = T;",
      "    using container_type = std::vector<value_type>;",
      "",
      "  private:",
      "    container_type value;",
      "  ",
      "  public:",
      "    constexpr polynominal()=default;",
      "    constexpr polynominal(const polynominal&)=default;",
      "    constexpr polynominal(polynominal&&)=default;",
      "    polynominal& operator=(const polynominal&)=default;",
      "    polynominal& operator=(polynominal&&)=default;",
      "",
      "    template <typename... Args>",
      "    polynominal(Args... args) : value(std::forward<Args>(args)...) {}",
      "",
      "    auto operator()(){return value;}",
      "",
      "",
      "};",
      "",
      "template <typename T> struct is_polynominal : std::false_type{};",
      "template <typename T, T zero, T one> struct is_polynominal <polynominal<T, zero, one>> : std::true_type{};",
      "template <typename T> constexpr bool is_polynominal_v = is_polynominal<T>::value;"
    ],
    "prefix": "polynominal"
  },
  "../src/lib/number_theory/sieve_of_eratosthenes.cpp": {
    "body": [
      "template <size_t N>",
      "class sieve_of_eratosthenes {",
      "    std::bitset<N> is_prime_;",
      "",
      "  public:",
      "    constexpr sieve_of_eratosthenes(){",
      "      is_prime_ = ~is_prime_;",
      "      is_prime_.reset(0), is_prime_.reset(1);",
      "      for (size_t p = 2; p < N; p++) {",
      "        if (!is_prime_.test(p)) continue;",
      "        for (size_t j = 2; j * p < N; j++) {",
      "          is_prime_.reset(p * j);",
      "        }",
      "      }",
      "    }",
      "",
      "    // Return the bitset testing if a number is prime.",
      "    constexpr const auto& is_prime() const {return is_prime_;}",
      "",
      "    // Returns the vector of prime numbers.",
      "    template <typename T>",
      "    auto primes() const {",
      "      std::vector<T> primes{}; ",
      "      for (size_t i = 0; i < N; i++) {",
      "        if (is_prime_.test(i)) primes.push_back(i);",
      "      }",
      "      return primes;",
      "    }",
      "};"
    ],
    "prefix": "sieve_of_eratosthenes"
  },
  "../src/lib/number_theory/tropical.cpp": {
    "body": [
      "template <typename T, typename F, std::enable_if_t<",
      "    std::is_same<std::result_of_t<F(T, T)>, T>::value,",
      "    std::nullptr_t> = nullptr>",
      "class tropical {",
      "    T value;",
      "  ",
      "  public:",
      "    using value_type = T;",
      "    constexpr tropical()=default;",
      "    constexpr tropical(const tropical&)=default;",
      "    constexpr tropical(tropical&&)=default;",
      "    tropical& operator=(const tropical&)=default;",
      "    tropical& operator=(tropical&&)=default;",
      "",
      "    constexpr tropical(T t) : value(t){}",
      "",
      "    auto const& operator()() const { return value; }",
      "    template <typename U>",
      "    explicit operator U() const { return static_cast<U>(value); }",
      "",
      "    auto& operator+=(const tropical& other) {",
      "      value = F{}(value, other.value);",
      "      return *this;",
      "    }",
      "    template <typename U>",
      "    auto& operator+=(const U& other) {return *this += tropical(other); }",
      "  ",
      "    template <typename U = T>",
      "    auto& operator*=(const tropical& other) {",
      "      value += other.value;",
      "      return *this;",
      "    }",
      "};",
      "template <typename T> struct is_tropical : std::false_type{};",
      "template <typename T, typename F> struct is_tropical <tropical<T, F>> : std::true_type{};",
      "template <typename T> constexpr bool is_tropical_v = is_tropical<T>::value;",
      "",
      "template <typename T, std::enable_if_t<",
      "  is_tropical_v<T>, std::nullptr_t> = nullptr>",
      "bool operator==(const T& lhs, const T& rhs) {return lhs.value == rhs.value;}",
      "",
      "template <typename T>",
      "auto operator+(const T& lhs, const T& rhs)",
      "  -> std::enable_if_t<is_tropical_v<T>, T>",
      "  {return T(lhs) += rhs;}",
      "",
      "template <typename T>",
      "auto operator*(const T& lhs, const T& rhs)",
      "  -> std::enable_if_t<is_tropical_v<T>, T>",
      "  {return T(lhs) *= rhs;}",
      "",
      "template <typename T, typename F>",
      "std::string to_string(const tropical<T, F>& a)",
      "  {return std::to_string(a());}",
      "",
      "template <typename T, typename F>",
      "std::ostream& operator<<(std::ostream& os, const tropical<T, F>& a)",
      "  {return os << a();}",
      "",
      "template <typename T, typename F>",
      "std::istream& operator>>(std::istream& is, tropical<T, F>& a)",
      "  {T x; is >> x; a = tropical<T, F>(x); return is;}",
      "",
      "template <typename T>",
      "struct min_fn_object {",
      "  auto operator()(T a, T b) {return std::min(a, b);}",
      "};",
      "template <typename T>",
      "struct max_fn_object {",
      "  auto operator()(T a, T b) {return std::max(a, b);}",
      "};",
      "using min_tropical = tropical<int, min_fn_object<int>>;",
      "using max_tropical = tropical<int, max_fn_object<int>>;"
    ],
    "prefix": "tropical"
  },
  "../src/lib/srring_algorighms/fully_indexable_dictionary.cpp": {
    "body": [
      "class fully_indexable_dictionary {",
      "    using value_t = uint32_t;",
      "    using count_t = unsigned;",
      "    static constexpr size_t sz = 8 * sizeof(uint32_t);",
      "    bool built;",
      "    size_t full_length, n;",
      "    std::vector<value_t> row_data;",
      "    std::vector<count_t> rank_table;",
      "",
      "  public:",
      "    fully_indexable_dictionary(size_t full_length) :",
      "      built(false),",
      "      full_length(full_length),",
      "      n((full_length + sz - 1) / sz),",
      "      row_data(n), rank_table(n) {",
      "        debug(sz, n);",
      "      }",
      "",
      "    // Set the i-th bit.",
      "    void set(size_t i) {",
      "      assert(!built);",
      "      row_data.at(i / sz) |= (1u << i);",
      "    }",
      "",
      "    // Initialize the rank-table.",
      "    void build() {",
      "      assert(!built);",
      "      rank_table = [&]{",
      "        std::vector<count_t> pop_counts(n), rank_table(n);",
      "        std::transform(row_data.begin(), row_data.end(), pop_counts.begin(),",
      "          [](auto x){return __builtin_popcountl(x);});",
      "        std::partial_sum(pop_counts.begin(), pop_counts.end(), rank_table.begin());",
      "        rank_table.insert(rank_table.begin(), 0u);",
      "        return rank_table; ",
      "      }();",
      "      built = true;",
      "      debug(row_data, rank_table);",
      "    }",
      "",
      "    // Access the i-th bit.",
      "    auto access(size_t i) const -> bool {",
      "      return row_data.at(i / sz) >> (i % sz) & 1u;",
      "    }",
      "    // An alias of access",
      "    auto at(size_t i) const -> bool {return access(i);}",
      "    ",
      "    // Count the 1.",
      "    auto rank(size_t i) const -> count_t {",
      "      return rank_table.at(i / sz)",
      "        + __builtin_popcountl(row_data.at(i / sz) & ((1 << (i % sz)) - 1));",
      "    }",
      "",
      "    // Find the k-th 1. (That is the maximal i such that rank(i) <= k.)",
      "    // When not found, returns the full-size of the sequence.",
      "    auto select(size_t k) const -> size_t {",
      "      size_t left = 0, right = full_length + 1, mid;",
      "      while (right - left > 1) {",
      "        mid = (left + right) / 2;",
      "        (rank(mid) <= k ? left : right) = mid;",
      "      }",
      "      return left;",
      "    }",
      "};"
    ],
    "prefix": "fully_indexable_dictionary"
  },
  "../src/lib/srring_algorighms/rolling_hash.cpp": {
    "body": [
      "class rolling_hash {",
      "  public:",
      "    using value_type     = long long;",
      "    using container_type = std::vector<value_type>;",
      "",
      "  private:",
      "    static constexpr size_t  mod_num = 2;",
      "    static constexpr std::array<value_type, mod_num> mods = {",
      "        1'000'000'007,",
      "        1'000'000'009",
      "      };",
      "    static constexpr value_type base    = 9973;",
      "",
      "    size_t                       n;",
      "    std::vector<container_type>  hash_table;",
      "    std::vector<container_type>  pow_table;",
      "",
      "    auto inverse(value_type a, value_type m) const -> value_type {",
      "      value_type u = 0, v = 1;",
      "      while (a != 0) {",
      "        value_type t = m / a;",
      "        m -= t * a; std::swap(a, m);",
      "        u -= t * v; std::swap(u, v);",
      "      }",
      "      assert(m == 1);",
      "      return u;",
      "    }",
      "",
      "  public:",
      "    // ctor, dtor",
      "    explicit rolling_hash() = default;",
      "    explicit rolling_hash(const rolling_hash&) = default;",
      "    explicit rolling_hash(rolling_hash&&) = default;",
      "    rolling_hash& operator=(const rolling_hash&) = default;",
      "    rolling_hash& operator=(rolling_hash&&) = default;",
      "    ~rolling_hash() = default;",
      "",
      "    rolling_hash(const std::string s) :",
      "      n(s.length()),",
      "      hash_table(mod_num, container_type(n + 1, 0)),",
      "      pow_table (mod_num, container_type(n + 1, 1))",
      "      {",
      "        for (size_t i = 0; i < mod_num; i++) {",
      "          auto  mod = mods.at(i);",
      "          auto& tab = hash_table.at(i);",
      "          auto& pab = pow_table.at(i);",
      "          for (size_t j = 0; j < n; j++) {",
      "            tab.at(j + 1) = (tab.at(j) * base + s.at(j)) % mod;",
      "            pab.at(j + 1) = (pab.at(j) * base) % mod;",
      "          }",
      "        }",
      "      }",
      "",
      "    // observers",
      "    auto hash(size_t l, size_t r) const {",
      "      auto ret = std::vector<value_type>{};",
      "      for (size_t i = 0; i < mod_num; i++) {",
      "        const auto  mod = mods.at(i);",
      "        const auto& tab = hash_table.at(i);",
      "        const auto& pab = pow_table.at(i);",
      "        auto &      buf = ret.at(i);",
      "        buf = (tab.at(r) - tab.at(l)) * inverse(pab.at(l), mod) % mod;",
      "      }",
      "      return ret;",
      "    }",
      "};"
    ],
    "prefix": "rolling_hash"
  },
  "../src/lib/srring_algorighms/run_length_encoding.cpp": {
    "body": [
      "template<typename T>",
      "class run_length_encoding {",
      "  std::vector<std::pair<int, T>> rle;",
      "  public:",
      "    run_length_encoding(",
      "        std::vector<T> input",
      "      ) :",
      "      rle(0)",
      "      {",
      "        int cnt = 0;",
      "        for (auto it = input.begin(); it != input.end(); it++) {",
      "          auto jt = next(it); cnt++;",
      "          if (jt == input.end() || *it != *jt) {",
      "            rle.emplace_back(cnt, *it);",
      "            cnt = 0;",
      "          }",
      "        }",
      "      }",
      "    auto const& code () const {return rle;}",
      "};"
    ],
    "prefix": "run_length_encoding"
  },
  "../src/lib/utility/affine_group.cpp": {
    "body": [
      "  auto apply = [&] (std::pair<int, int>p, int& ret) -> void {",
      "    int coeff, a; std::tie(coeff, a) = p;",
      "    mint::mul(ret, coeff);",
      "    mint::add(ret, a);",
      "  };",
      "  auto cmp = [&] (std::pair<int, int> p, std::pair<int, int> q) -> std::pair<int, int> {",
      "    int a, b; std::tie(a, b) = p;",
      "    int c, d; std::tie(c, d) = q;",
      "    return {mint::prod(a, c), mint::sum(mint::prod(a, d), b)};",
      "  };",
      "  auto cmp_pow = [&] (std::pair<int, int> p, int k) -> std::pair<int, int> {",
      "    std::pair<int, int> ret = {1, 0};",
      "    while (k) {",
      "      if (k & 1) ret = cmp(ret, p);",
      "      k /= 2;",
      "      p = cmp(p, p);",
      "    }",
      "    return ret;",
      "  };"
    ],
    "prefix": "affine_group"
  },
  "../src/lib/utility/at.cpp": {
    "body": [
      "  // Access the j-th bit.",
      "  auto at = [](unsigned x, size_t j) -> bool {",
      "    return (x >> j) & 1;",
      "  };"
    ],
    "prefix": "at"
  },
  "../src/lib/utility/cmn_cmx.cpp": {
    "body": [
      "template<typename T, typename U>",
      "inline auto cmn (T& a, U b) {if (a > b) {a = b; return true;} return false;}",
      "template<typename T, typename U>",
      "inline auto cmx (T& a, U b) {if (a < b) {a = b; return true;} return false;}"
    ],
    "prefix": "cmn_cmx"
  },
  "../src/lib/utility/combinator.cpp": {
    "body": [
      "template<typename T>",
      "class fixed_point : T {",
      "  public:",
      "    explicit constexpr fixed_point (T&& t) noexcept",
      "      : T(std::forward<T>(t)) {}",
      "    template<typename... Args>",
      "    constexpr decltype(auto) operator()(Args&&... args) const",
      "      {return T::operator()(*this, std::forward<Args>(args)...);}",
      "};",
      "template<typename T>",
      "static inline constexpr decltype(auto) fix (T&& t) noexcept {",
      "  return fixed_point<T>{std::forward<T>(t)};",
      "}"
    ],
    "prefix": "combinator"
  },
  "../src/lib/utility/convolution.cpp": {
    "body": [
      "template<typename T>",
      "class convolution {",
      "  const T id;",
      "  const std::function<void(T&, T)> add;",
      "  const std::function<T(T, T)> mul;",
      "  public:",
      "    convolution (",
      "        T id,",
      "        std::function<void(T&, T)> add,",
      "        std::function<T(T, T)> mul",
      "      ) :",
      "      id(id),",
      "      add(add),",
      "      mul(mul)",
      "      {",
      "      }",
      "    auto operator () (",
      "        std::vector<T> a,",
      "        std::vector<T> b",
      "      ) -> std::vector<T>",
      "      {",
      "        int l = a.size();",
      "        int m = b.size();",
      "        int n = l + m - 1;",
      "        assert(l && m);",
      "        std::vector<T> c(n, id);",
      "        for (int i = 0; i < l; i++) {",
      "          for (int j = 0; j < m; j++) {",
      "            add(c[i + j], mul(a[i], b[j]));",
      "          }",
      "        }",
      "        return c;",
      "      }",
      "};",
      "convolution<${1:long long}> cnv(",
      "    ${2:id},",
      "    ${3:add},",
      "    ${4:mul}",
      "  );",
      "  "
    ],
    "prefix": "convolution"
  },
  "../src/lib/utility/didj.cpp": {
    "body": [
      "int d${1:i}[4] = {-1, +1, 0, 0};",
      "int d${2:j}[4] = {0, 0, -1, +1};"
    ],
    "prefix": "didj"
  },
  "../src/lib/utility/fix_define.cpp": {
    "body": [
      "auto ${1:cal} = fix ([&](auto $1, $0) -> ${2:int} {",
      "  ",
      "});"
    ],
    "prefix": "fix_define"
  },
  "../src/lib/utility/fix_do.cpp": {
    "body": [
      "fix ([&](auto ${1:dfs}, $0) -> ${2:void} {",
      "  ",
      "})();"
    ],
    "prefix": "fix_do"
  },
  "../src/lib/utility/free_group.cpp": {
    "body": [
      "class free_group {",
      "  public:",
      "  static inline auto mul(std::string s, std::string t) {",
      "    while (",
      "        !s.empty() && !t.empty() &&",
      "        abs(s.back() - t.front()) == 32",
      "      )",
      "      {",
      "        s.erase(s.end() - 1); t.erase(t.begin());",
      "      }",
      "      return s + t;",
      "  }",
      "  static inline auto inv (std::string s) {",
      "    auto opp = [&] (char& c) {",
      "        if (0 <= c - 'a' && c - 'a' < 26) c -= 32;",
      "        else if (0 <= c - 'A' && c - 'A' < 26) c += 32;",
      "        else assert(false);",
      "      };",
      "    reverse(s.begin(), s.end());",
      "    for_each(s.begin(), s.end(), opp);",
      "    return s;",
      "  }",
      "};"
    ],
    "prefix": "free_group"
  },
  "../src/lib/utility/gauss_jordan_int.cpp": {
    "body": [
      "class gauss_jordan {",
      "  const int h, w;",
      "  int rk;",
      "  std::vector<bool> ckd;",
      "  std::vector<int> p, a;",
      "  void init () {",
      "    for (int j = 0; j < w; j++) {",
      "      for (int pvt = 0; pvt < h; pvt++) {",
      "        if (ckd[pvt]) continue;",
      "        if (a[j] >> pvt & 1) {",
      "          ckd[pvt] = true; rk++;",
      "          int comb = a[j] ^ 1 << pvt;",
      "          for (int i = 0; i < h; i++) if (p[i] >> pvt & 1) p[i] ^= comb;",
      "          for (int k = j; k < w; k++) if (a[k] >> pvt & 1) a[k] ^= comb;",
      "          break;",
      "        }",
      "      }",
      "    }",
      "  }",
      "  inline int transform (int y) const {",
      "    int z = 0;",
      "    for (int i = 0; i < h; i++) {",
      "      if (y >> i & 1) z |= p[i];",
      "    }",
      "    return z;",
      "  }",
      "  public:",
      "    gauss_jordan (",
      "        std::vector<int> a,",
      "        int h",
      "      ) :",
      "      h(h), w(a.size()), rk(0),",
      "      ckd(h, false),",
      "      p([&]{",
      "        std::vector<int> p(h); ",
      "        for (int i = 0, x = 1; i < h; i++, x *= 2) p[i] = x;",
      "        return p;",
      "      }()),",
      "      a(a)",
      "      {",
      "        init();",
      "      }",
      "    inline int rank () const {return rk;}",
      "    inline int kernel () const {return w - rk;}",
      "    inline int image () const {return h - rk;}",
      "    inline bool solvable (int y) const {",
      "      assert (!(y >> h));",
      "      int acm = accumulate(a.begin(), a.end(), 0, [](int x, int y){return x | y;});",
      "      int z = transform(y);",
      "      return !(~acm & z);",
      "    }",
      "};"
    ],
    "prefix": "gauss_jordan_int"
  },
  "../src/lib/utility/guess.cpp": {
    "body": [
      "struct rational {int n, d;};",
      "auto to_string(rational r) -> std::string {",
      "  return (r.d == 1",
      "    ? std::to_string(r.n)",
      "    : std::to_string(r.n) + \"/\" + std::to_string(r.d));",
      "}",
      "std::ostream& operator << (std::ostream& os, rational r){",
      "  return os << to_string(r);",
      "}",
      "rational guess (mint k) {",
      "  const int dmx = 1000;",
      "  const int nmx = 1000;",
      "  for (int d = 1; d < dmx; d++) {",
      "    int n = int(k * mint(d));",
      "    if (n < nmx) return {n, d};",
      "  }",
      "  return {-1, 0};",
      "}"
    ],
    "prefix": "guess"
  },
  "../src/lib/utility/make_higher_vector.cpp": {
    "body": [
      "template <typename T>",
      "auto make_vector(size_t sz, T t) {",
      "  return std::vector<T>(sz, t);",
      "}",
      "template <size_t N, typename T, typename U, std::enable_if_t<",
      "  N == 1, std::nullptr_t> = nullptr>",
      "auto make_higher_vector(size_t sz, U u) {",
      "  return make_vector(sz, T(u));",
      "}",
      "template <size_t N, typename T, std::enable_if_t<",
      "  N == 1, std::nullptr_t> = nullptr>",
      "auto make_higher_vector(size_t sz) {",
      "  return std::vector<T>(sz);",
      "}",
      "template <size_t N, typename T, typename... Args, std::enable_if_t<",
      "  N != 1, std::nullptr_t> = nullptr>",
      "auto make_higher_vector(size_t a, Args... args) {",
      "  return make_vector(a, make_higher_vector<N - 1, T>(args...));",
      "}",
      "template <typename T, typename Size_t>",
      "auto& at(T& t, Size_t i) {",
      "  return t.at(i);",
      "}",
      "template <typename T, typename Size_t, typename... Args>",
      "auto& at(T& t, Size_t i, Args... args) {",
      "  return at(t.at(i), args...);",
      "}"
    ],
    "prefix": "make_higher_vector"
  },
  "../src/lib/utility/remove_bit_insert_bit.cpp": {
    "body": [
      "int remove_bit(int x, int j) {",
      "  int low = x & ((1 << j) - 1);",
      "  return ((x >> (j + 1)) << j) + low;",
      "}",
      "int insert_bit(int x, int j, int v) {",
      "  int low = x & ((1 << j) - 1);",
      "  return ((x >> j) << (j + 1)) + (v << j) + low;",
      "}"
    ],
    "prefix": "remove_bit_insert_bit"
  },
  "../src/lib/utility/remove_insert_bit.cpp": {
    "body": [
      "  // Remove the j-th bit of x, then shift the upper part to the right.",
      "  auto remove_bit = [](unsigned x, size_t j) -> unsigned {",
      "    return ((x >> (j + 1)) << j) + (x & ((1 << j) - 1));",
      "  };",
      "  // Insert the bit b to x.at(j), shifting the upper part to the left.",
      "  auto insert_bit = [](unsigned x, size_t j, bool b) -> unsigned {",
      "    return ((x >> j) << (j + 1)) + (b << j) + (x & ((1 << j) - 1));",
      "  };"
    ],
    "prefix": "remove_insert_bit"
  },
  "../src/lib/utility/square_matrix.cpp": {
    "body": [
      "constexpr size_t sz = 3;",
      "using vec = std::array<mint, sz>;",
      "using mat = std::array<vec, sz>;",
      "auto prod = [&] (const mat& a, const mat& b) {",
      "  mat c{};",
      "  for (size_t i = 0; i < sz; i++) {",
      "    for (size_t j = 0; j < sz; j++) {",
      "      for (size_t k = 0; k < sz; k++) {",
      "        c.at(i).at(j) += a.at(i).at(k) * b.at(k).at(j);",
      "      }",
      "    }",
      "  }",
      "  return c;",
      "};",
      "auto id = [&] {",
      "  mat c{};",
      "  for (size_t i = 0; i < sz; i++) {",
      "    c.at(i).at(i) = 1;",
      "  }",
      "  return c;",
      "};",
      "auto pow = [&] (mat a, long long b) {",
      "  auto c = id();",
      "  for (; b > 0; b /= 2) {",
      "    if (b % 2 == 1) c = prod(c, a);",
      "    a = prod(a, a);",
      "  }",
      "  return c;",
      "};",
      "auto act = [&] (mat a, vec b) {",
      "  vec c{};",
      "  for (size_t i = 0; i < sz; i++) {",
      "    for (size_t j = 0; j < sz; j++) {",
      "      c.at(i) += a.at(i).at(j) * b.at(j);",
      "    }",
      "  }",
      "  return c;",
      "};"
    ],
    "prefix": "square_matrix"
  },
  "../src/snippets/code_fragments/all.cpp": {
    "body": [
      "${1:name}.begin(), $1.end()"
    ],
    "prefix": "all"
  },
  "../src/snippets/code_fragments/for_const.cpp": {
    "body": [
      "for (auto const & ${1:e}: ${2:name}) {",
      "  $0",
      "}"
    ],
    "prefix": "for_const"
  },
  "../src/snippets/code_fragments/for_iterator.cpp": {
    "body": [
      "for (auto ${1:it} = ${2:name}.begin(); $1 != $2.end(); it++) {",
      "  $0",
      "}"
    ],
    "prefix": "for_iterator"
  },
  "../src/snippets/code_fragments/for_range.cpp": {
    "body": [
      "for (auto const& ${1:e} : ${2:name}) {",
      "  $0",
      "}"
    ],
    "prefix": "for_range"
  },
  "../src/snippets/code_fragments/for_reverse.cpp": {
    "body": [
      "for (int ${1:i} = ${2:n - 1}; $1 >= ${3:0}; $1--) {",
      "  $0",
      "}"
    ],
    "prefix": "for_reverse"
  },
  "../src/snippets/code_fragments/fors.cpp": {
    "body": [
      "for (${1:int} ${2:i} = ${3:0}; $2 < ${4:n}; $2++) {",
      "  $0",
      "}"
    ],
    "prefix": "fors"
  },
  "../src/snippets/code_fragments/inf.cpp": {
    "body": [
      "constexpr int inf = 1 << 30;"
    ],
    "prefix": "inf"
  },
  "../src/snippets/code_fragments/interval_dp.cpp": {
    "body": [
      "for (int d = 1; d <= ${1:n}; d++) {",
      "  for (int l = 0, r = d; r <= $1; l++, r++) {",
      "    $0",
      "  }",
      "}"
    ],
    "prefix": "interval_dp"
  },
  "../src/snippets/code_fragments/lambda.cpp": {
    "body": [
      "auto ${1:name} = [&] ($2) {",
      "  $0",
      "};"
    ],
    "prefix": "lambda"
  },
  "../src/snippets/code_fragments/long_inf.cpp": {
    "body": [
      "constexpr long long inf = 1LL << 60;"
    ],
    "prefix": "long_inf"
  },
  "../src/snippets/code_fragments/lower_bound.cpp": {
    "body": [
      "std::lower_bound(${1:name}.begin(), ${1:name}.end(), ${2:きじゅんち});"
    ],
    "prefix": "lower_bound"
  },
  "../src/snippets/code_fragments/output_stream.cpp": {
    "body": [
      "copy(${1:a}.begin(), $1.end(), ostream_iterator<${2:int}>(std::cout, \" \"));",
      "$0"
    ],
    "prefix": "output_stream"
  },
  "../src/snippets/code_fragments/pair.cpp": {
    "body": [
      "std::pair<${1:int}, ${2:int}> ${3:name}(${4:0}, ${5:0})$0;"
    ],
    "prefix": "pair"
  },
  "../src/snippets/code_fragments/reverse.cpp": {
    "body": [
      "reverse(${1:name}.begin(), ${1:name}.end());"
    ],
    "prefix": "reverse"
  },
  "../src/snippets/code_fragments/reverse_priority_queue.cpp": {
    "body": [
      "priority_queue<",
      "  ${1:std::pair<int, int>},",
      "  std::vector<$1>,",
      "  greater<$1>",
      "> ${2:que};",
      "$2.emplace($0);"
    ],
    "prefix": "reverse_priority_queue"
  },
  "../src/snippets/code_fragments/sort.cpp": {
    "body": [
      "sort(${1:name}.begin(), ${1:name}.end());"
    ],
    "prefix": "sort"
  },
  "../src/snippets/code_fragments/sort_reverse.cpp": {
    "body": [
      "sort(${1:name}.begin(), ${1:name}.end(), greater<${2:int}>());"
    ],
    "prefix": "sort_reverse"
  },
  "../src/snippets/code_fragments/stemp.cpp": {
    "body": [
      "#include <bits/stdc++.h>",
      "int main() {",
      "  std::cin.tie(0); std::cin.sync_with_stdio(false);",
      "  $0",
      "  return 0;",
      "}"
    ],
    "prefix": "stemp"
  },
  "../src/snippets/code_fragments/upper_bound.cpp": {
    "body": [
      "std::upper_bound(${1:name}.begin(), ${1:おname.end(), ${2:きじゅんち});"
    ],
    "prefix": "upper_bound"
  },
  "../src/snippets/code_fragments/vec.cpp": {
    "body": [
      "std::vector<${1:int}> ${2:name}(${3:n});$0"
    ],
    "prefix": "vec"
  },
  "../src/snippets/code_fragments/vecpair.cpp": {
    "body": [
      "std::vector<std::pair<${1:int}, ${2:int}>> ${3:name}(${4:n}, {${5:0}, ${6:0}})$0;"
    ],
    "prefix": "vecpair"
  },
  "../src/snippets/code_fragments/vecvec.cpp": {
    "body": [
      "std::vector<std::vector<${1:int}>> ${2:grh}($0);"
    ],
    "prefix": "vecvec"
  },
  "../src/snippets/code_fragments/vecvecpair.cpp": {
    "body": [
      "std::vector<std::vector<std::pair<${1:int}, ${2:int}>>> ${3:name}(${4:h}, std::vector<std::pair<${1:int}, ${2:int}>>(${5:w}, {${6:0}, ${7:0}}))$0;"
    ],
    "prefix": "vecvecpair"
  },
  "../src/snippets/debug/-pdbg.cpp": {
    "body": [
      "std::cout << \"(\" << ${1:name}${2:->}first << \", \" << $1$2second << \")\";"
    ],
    "prefix": "-pdbg"
  },
  "../src/snippets/debug/-ppdbg.cpp": {
    "body": [
      "std::cout << \"(\" << get<0>(${1:*it}) << \", \" << get<1>($1) << \", \" << get<2>($1) << \")\";"
    ],
    "prefix": "-ppdbg"
  },
  "../src/snippets/debug/-sdbg.cpp": {
    "body": [
      "std::cout << ${1:name};"
    ],
    "prefix": "-sdbg"
  },
  "../src/snippets/debug/1dbg.cpp": {
    "body": [
      "{ // debug",
      "  std::cout << \"${1:a} = \" << $1 << std::endl;",
      "} //"
    ],
    "prefix": "1dbg"
  },
  "../src/snippets/debug/1prompt.cpp": {
    "body": [
      "std::cout << \"${2:a} > \";",
      "${1:int} $2;",
      "std::cin >> $2;"
    ],
    "prefix": "1prompt"
  },
  "../src/snippets/debug/1vdebug.cpp": {
    "body": [
      "{ // debug",
      "  int n = 0;",
      "  if (n < (int)${1:name}.size()) n = $1.size();",
      "  std::cout << std::setw(4) << \"----\"; for (int i = 0; i < n; i++) std::cout << std::setw(4) << \"----\" ; std::cout << std::endl;",
      "  std::cout << std::setw(4) << \"\"; for (int i = 0; i < n; i++) std::cout << std::setw(4) << i; std::cout << std::endl;",
      "  std::cout << std::setw(4) << \"----\"; for (int i = 0; i < n; i++) std::cout << std::setw(4) << \"----\" ; std::cout << std::endl;",
      "  std::cout << std::setw(4) << \"$1\"; for (auto const& e : $1) std::cout << std::setw(4) << e; std::cout << std::endl;",
      "  std::cout << std::setw(4) << \"----\"; for (int i = 0; i < n; i++) std::cout << std::setw(4) << \"----\" ; std::cout << std::endl;",
      "} //"
    ],
    "prefix": "1vdebug"
  },
  "../src/snippets/debug/2dbg.cpp": {
    "body": [
      "{ // debug",
      "  std::cout",
      "    << \"${1:a} = \" << $1 << \", \"",
      "    << \"${2:b} = \" << $2",
      "    << std::endl;",
      "} //"
    ],
    "prefix": "2dbg"
  },
  "../src/snippets/debug/2prpmpt.cpp": {
    "body": [
      "std::cout << \"${2:a}, ${3:b} > \";",
      "${1:int} $2, $3;",
      "std::cin >> $2 >> $3;"
    ],
    "prefix": "2prpmpt"
  },
  "../src/snippets/debug/2vdebug.cpp": {
    "body": [
      "{ // debug",
      "  int n = 0;",
      "  if (n < (int)${1:name}.size()) n = $1.size();",
      "  if (n < (int)${2:name}.size()) n = $2.size();",
      "  std::cout << std::setw(4) << \"----\"; for (int i = 0; i < n; i++) std::cout << std::setw(4) << \"----\" ; std::cout << std::endl;",
      "  std::cout << std::setw(4) << \"\"; for (int i = 0; i < n; i++) std::cout << std::setw(4) << i; std::cout << std::endl;",
      "  std::cout << std::setw(4) << \"----\"; for (int i = 0; i < n; i++) std::cout << std::setw(4) << \"----\" ; std::cout << std::endl;",
      "  std::cout << std::setw(4) << \"$1\"; for (auto const& e : $1) std::cout << std::setw(4) << e; std::cout << std::endl;",
      "  std::cout << std::setw(4) << \"$2\"; for (auto const& e : $2) std::cout << std::setw(4) << e; std::cout << std::endl;",
      "  std::cout << std::setw(4) << \"----\"; for (int i = 0; i < n; i++) std::cout << std::setw(4) << \"----\" ; std::cout << std::endl;",
      "} //"
    ],
    "prefix": "2vdebug"
  },
  "../src/snippets/debug/3dbg.cpp": {
    "body": [
      "{ // debug",
      "  std::cout",
      "    << \"${1:a} = \" << $1 << \", \"",
      "    << \"${2:b} = \" << $2 << \", \"",
      "    << \"${3:c} = \" << $3",
      "    << std::endl;",
      "} //"
    ],
    "prefix": "3dbg"
  },
  "../src/snippets/debug/3prompt.cpp": {
    "body": [
      "std::cout << \"${2:a}, ${3:b}, ${4:c} > \";",
      "${1:int} $2, $3, $4;",
      "std::cin >> $2 >> $3 >> $4;"
    ],
    "prefix": "3prompt"
  },
  "../src/snippets/debug/3vdebug.cpp": {
    "body": [
      "{ // debug",
      "  int n = 0;",
      "  if (n < (int)${1:name}.size()) n = $1.size();",
      "  if (n < (int)${2:name}.size()) n = $2.size();",
      "  if (n < (int)${3:name}.size()) n = $3.size();",
      "  std::cout << std::setw(4) << \"----\"; for (int i = 0; i < n; i++) std::cout << std::setw(4) << \"----\" ; std::cout << std::endl;",
      "  std::cout << std::setw(4) << \"\"; for (int i = 0; i < n; i++) std::cout << std::setw(4) << i; std::cout << std::endl;",
      "  std::cout << std::setw(4) << \"----\"; for (int i = 0; i < n; i++) std::cout << std::setw(4) << \"----\" ; std::cout << std::endl;",
      "  std::cout << std::setw(4) << \"$1\"; for (auto const& e : $1) std::cout << std::setw(4) << e; std::cout << std::endl;",
      "  std::cout << std::setw(4) << \"$2\"; for (auto const& e : $2) std::cout << std::setw(4) << e; std::cout << std::endl;",
      "  std::cout << std::setw(4) << \"$3\"; for (auto const& e : $3) std::cout << std::setw(4) << e; std::cout << std::endl;",
      "  std::cout << std::setw(4) << \"----\"; for (int i = 0; i < n; i++) std::cout << std::setw(4) << \"----\" ; std::cout << std::endl;",
      "} //"
    ],
    "prefix": "3vdebug"
  },
  "../src/snippets/debug/4dbg.cpp": {
    "body": [
      "{ // debug",
      "  std::cout",
      "    << \"${1:a} = \" << $1 << \", \"",
      "    << \"${2:b} = \" << $2 << \", \"",
      "    << \"${3:c} = \" << $3 << \", \"",
      "    << \"${4:d} = \" << $4",
      "    << std::endl;",
      "} //"
    ],
    "prefix": "4dbg"
  },
  "../src/snippets/debug/4vdebug.cpp": {
    "body": [
      "{ // debug",
      "  int n = 0;",
      "  if (n < (int)${1:name}.size()) n = $1.size();",
      "  if (n < (int)${2:name}.size()) n = $2.size();",
      "  if (n < (int)${3:name}.size()) n = $3.size();",
      "  std::cout << std::setw(4) << \"----\"; for (int i = 0; i < n; i++) std::cout << std::setw(4) << \"----\" ; std::cout << std::endl;",
      "  std::cout << std::setw(4) << \"\"; for (int i = 0; i < n; i++) std::cout << std::setw(4) << i; std::cout << std::endl;",
      "  std::cout << std::setw(4) << \"----\"; for (int i = 0; i < n; i++) std::cout << std::setw(4) << \"----\" ; std::cout << std::endl;",
      "  std::cout << std::setw(4) << \"$1\"; for (auto const& e : $1) std::cout << std::setw(4) << e; std::cout << std::endl;",
      "  std::cout << std::setw(4) << \"$2\"; for (auto const& e : $2) std::cout << std::setw(4) << e; std::cout << std::endl;",
      "  std::cout << std::setw(4) << \"$3\"; for (auto const& e : $3) std::cout << std::setw(4) << e; std::cout << std::endl;",
      "  std::cout << std::setw(4) << \"$4\"; for (auto const& e : $4) std::cout << std::setw(4) << e; std::cout << std::endl;",
      "  std::cout << std::setw(4) << \"----\"; for (int i = 0; i < n; i++) std::cout << std::setw(4) << \"----\" ; std::cout << std::endl;",
      "} //"
    ],
    "prefix": "4vdebug"
  },
  "../src/snippets/debug/bug.cpp": {
    "body": [
      "/* ↓ 消し忘れないで！！！ ↓ */",
      "$0",
      "/* ↑ いや振りじゃないから ↑ */"
    ],
    "prefix": "bug"
  },
  "../src/snippets/debug/check.cpp": {
    "body": [
      "std::cout << \"/\" << ${1:crr} << std::endl;",
      "std::cout << \"\\\\\\\\\" << ${1:crr} << std::endl;"
    ],
    "prefix": "check"
  },
  "../src/snippets/debug/interval_debug.cpp": {
    "body": [
      "{ // debug",
      "  std::cout",
      "    << \"[\" << $1 << \", \" << $2 << \")\" << std::endl;",
      "} //"
    ],
    "prefix": "interval_debug"
  },
  "../src/snippets/debug/map_debug.cpp": {
    "body": [
      "{ // debug",
      "  for (auto ${2:it} = ${1:mp}.begin(); $2 != $1.end(); $2++) {",
      "    std::cout << \"mp[\";",
      "    std::cout << $0$2->first;",
      "    std::cout << \"] = \";",
      "    std::cout << $2->second;",
      "    std::cout << \"\" << (next($2) == $1.end() ? \"\\n\" : \", \");",
      "  }",
      "} //"
    ],
    "prefix": "map_debug"
  },
  "../src/snippets/debug/ndbg.cpp": {
    "body": [
      "std::cout << \"$0\" << std::endl;"
    ],
    "prefix": "ndbg"
  },
  "../src/snippets/debug/new_line.cpp": {
    "body": [
      "{ // debug",
      "  std::cout << std::endl;",
      "} //"
    ],
    "prefix": "new_line"
  },
  "../src/snippets/debug/pdbg.cpp": {
    "body": [
      "{ // debug",
      "  std::cout << \"${1:name} = (\" << $1${2:.}first << \", \" <<  $1$2second << \")\" << std::endl;",
      "} //"
    ],
    "prefix": "pdbg"
  },
  "../src/snippets/debug/pretty_debug.cpp": {
    "body": [
      "#define LOCAL",
      "using std::to_string;",
      "auto to_string(std::string s) -> std::string {",
      "  return '\"' + s + '\"';",
      "}",
      "auto to_string(char c) -> std::string {",
      "  return \"'\" + std::string{c} + \"'\";",
      "}",
      "auto to_string(const char* s) -> std::string {",
      "  return to_string((std::string) s);",
      "}",
      "auto to_string(bool b) -> std::string {",
      "  return (b ? \"true\" : \"false\");",
      "}",
      "template <typename T, typename U>",
      "auto to_string(std::pair<T, U> p) -> std::string {",
      "  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";",
      "}",
      "template <size_t N>",
      "auto to_string(std::bitset<N> bs) -> std::string {",
      "  std::string res{};",
      "  for (size_t i = 0; i < N; i++)",
      "    res.insert(res.begin(), bs.test(i) ? '1' : '0');",
      "  return res;",
      "}",
      "template <typename T>",
      "auto to_string(T v) -> std::string {",
      "  bool flg = false;",
      "  std::string res = \"{\";",
      "  for (auto const&x : v) {",
      "    if (flg) res += \", \";",
      "    else flg = true;",
      "    res += to_string(x);",
      "  }",
      "  res += \"}\";",
      "  return res;",
      "}",
      "void debug_out() { std::cerr << std::endl; }",
      "template <typename Head, typename... Tail>",
      "void debug_out(Head H, Tail... T) {",
      "  std::cerr << \" \" << to_string(H);",
      "  debug_out(T...);",
      "}",
      "#ifdef LOCAL",
      "#define debug(...) std::cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)",
      "#else",
      "#define debug(...) 42",
      "#endif"
    ],
    "prefix": "pretty_debug"
  },
  "../src/snippets/debug/vpdebug.cpp": {
    "body": [
      "{ // debug",
      "  std::cout << \"${1:name}: \";",
      "  for (auto ${2:it} = $1.begin(); $2 != $1.end(); $2++) {",
      "    std::cout << \"(\";",
      "    std::cout << $2->first;",
      "    std::cout << \", \";",
      "    std::cout << $2->second;",
      "    std::cout << \")\" << (next($2) == $1.end() ? \"\\n\" : \", \");",
      "  }",
      "  std::cout << std::endl;",
      "} //"
    ],
    "prefix": "vpdebug"
  },
  "../src/snippets/debug/vvdbg.cpp": {
    "body": [
      "{ // debug",
      "  int h = ${1:name}.size(); int w = 0;",
      "  int name_length = ${2:3}; int output_length = ${3:4};",
      "  for (int i = 0; i < h; i++) if (w < (int)$1[i].size()) w = $1[i].size();",
      "  std::cout << std::string(name_length, '-') << \"--\";",
      "  for (int j = 0; j < w; j++) std::cout << std::setw(${3:output length}) << \"----\";",
      "  std::cout << std::endl;",
      "  std::cout << std::setw(name_length) << std::right << \"$1\" << \"| \";",
      "  for (int j = 0; j < w; j++) std::cout << std::setw(output_length) << std::right <<  j;",
      "  std::cout << std::endl;",
      "  std::cout << std::string(name_length, '-') << \"+-\";",
      "  for (int j = 0; j < w; j++) std::cout << std::string(output_length, '-');",
      "  std::cout << std::endl;",
      "  for (int i = 0; i < h; i++) {",
      "    std::cout << std::setw(name_length) << std::right << i << \"| \";",
      "    for (auto const& e : $1[i]) std::cout << std::setw(output_length) << std::right << (e == ${4:0} ? \"0\" : std::to_string(e));",
      "    std::cout << std::endl;",
      "  }",
      "  std::cout << std::string(name_length, '-') << \"--\";",
      "  for (int j = 0; j < w; j++) std::cout << std::string(output_length, '-');",
      "  std::cout << std::endl;",
      "} //"
    ],
    "prefix": "vvdbg"
  },
  "../src/snippets/standard_in_out/1sin.cpp": {
    "body": [
      "${1:int} $2; std::cin >> $2;"
    ],
    "prefix": "1sin"
  },
  "../src/snippets/standard_in_out/2sin.cpp": {
    "body": [
      "${1:int} $2, $3; std::cin >> $2 >> $3;"
    ],
    "prefix": "2sin"
  },
  "../src/snippets/standard_in_out/3sin.cpp": {
    "body": [
      "${1:int} $2, $3, $4;",
      "std::cin >> $2 >> $3 >> $4;"
    ],
    "prefix": "3sin"
  },
  "../src/snippets/standard_in_out/4sin.cpp": {
    "body": [
      "${1:int} $2, $3, $4, $5;",
      "std::cin >> $2 >> $3 >> $4 >> $5;"
    ],
    "prefix": "4sin"
  },
  "../src/snippets/standard_in_out/5sin.cpp": {
    "body": [
      "${1:int} $2, $3, $4, $5, $6;",
      "std::cin >> $2 >> $3 >> $4 >> $5 >> $6;"
    ],
    "prefix": "5sin"
  },
  "../src/snippets/standard_in_out/adjacency_input.cpp": {
    "body": [
      "int ${1:n}, ${2:m};",
      "std::cin >> $1 >> $2;",
      "constexpr ${3:long long} inf = 1LL << 60;",
      "std::vector<std::vector<$3>> adj(n, std::vector<$3>(n, inf));",
      "for (int i = 0; i < $1; i++) adj[i][i] = 0;",
      "for (int i = 0; i < m; i++) {",
      "  $3 d; int s, t;",
      "  std::cin >> s >> t >> d;",
      "  chmin(adj[s][t], d);",
      "}"
    ],
    "prefix": "adjacency_input"
  },
  "../src/snippets/standard_in_out/edge_input.cpp": {
    "body": [
      "int ${1:n}, ${2:m};",
      "std::cin >> $1 >> $2;",
      "std::vector<tuple<${3:long long}, int, int>> edg;",
      "for (int i = 0; i < $2; i++) {",
      "  $3 d;",
      "  int s, t;",
      "  std::cin >> s >> t >> d;",
      "  edg.emplace_back(d, ${4:--}s, $4t);",
      "}"
    ],
    "prefix": "edge_input"
  },
  "../src/snippets/standard_in_out/err.cpp": {
    "body": [
      "auto err = [&] {",
      "  std::cout << $0 << std::endl;",
      "  exit(0);",
      "};"
    ],
    "prefix": "err"
  },
  "../src/snippets/standard_in_out/graph_input.cpp": {
    "body": [
      "std::vector<std::vector<int>> grh(${1:n});",
      "for (int i = 0; i < ${2:n - 1}; i++) {",
      "  int s, t;",
      "  std::cin >> s >> t;",
      "  grh[${3:--}s].push_back($3t);",
      "  grh[t].push_back(s);",
      "}"
    ],
    "prefix": "graph_input"
  },
  "../src/snippets/standard_in_out/graph_pair_input.cpp": {
    "body": [
      "std::vector<std::vector<std::pair<${3:long long}, int>>> grh(${1:n});",
      "for (int i = 0; i < ${2:m}; i++) {",
      "  int s, t; $3 d;",
      "  std::cin >> s >> t >> d;",
      "  grh[${4:--}s].emplace_back(d, $4t);",
      "  grh[t].emplace_back(d, s);",
      "}"
    ],
    "prefix": "graph_pair_input"
  },
  "../src/snippets/standard_in_out/grid_input.cpp": {
    "body": [
      "int ${1:h}, ${2:w};",
      "std::cin >> $1 >> $2;",
      "std::vector<std::vector<int>> grd($1, std::vector<int>($2));",
      "for (int i = 0; i < $1; i++) {",
      "  for (int j = 0; j < $2; j++) {",
      "    char c;",
      "    std::cin >> c;",
      "    grd[i][j] = c == '#';",
      "  }",
      "}"
    ],
    "prefix": "grid_input"
  },
  "../src/snippets/standard_in_out/optional_value.cpp": {
    "body": [
      "(${1:dst[i]} == ${2:inf} ? \"${3:INF}\" : to_string($1))"
    ],
    "prefix": "optional_value"
  },
  "../src/snippets/standard_in_out/sout.cpp": {
    "body": [
      "std::cout << $0 << std::endl;"
    ],
    "prefix": "sout"
  },
  "../src/snippets/standard_in_out/space_or_newline.cpp": {
    "body": [
      "(${1:i} == ${2:n - 1} ? \" \" : \"\\n\")"
    ],
    "prefix": "space_or_newline"
  },
  "../src/snippets/standard_in_out/ternary.cpp": {
    "body": [
      "($1 ? $2 : $3)"
    ],
    "prefix": "ternary"
  },
  "../src/snippets/standard_in_out/tin.cpp": {
    "body": [
      "${1:int} ${2:tmp};",
      "std::cin >> $2;",
      "$0;"
    ],
    "prefix": "tin"
  }
}