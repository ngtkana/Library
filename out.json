{
  "../include/algorithm/coenumerate.hpp": {
    "body": [
      "template < template < typename ... > class Container, typename T >",
      "auto coenumerate(Container< T > const& v) {",
      "  auto n = v.size();",
      "  Container< std::pair< T, int >> ret(n);",
      "  for (std::size_t i = 0; i < n; i++)",
      "    { ret.at(i) = {v.at(i), i}; }",
      "  return ret;",
      "}"
    ],
    "prefix": "coenumerate"
  },
  "../include/algorithm/compress.hpp": {
    "body": [
      "template < class Value >",
      "auto compress (std::vector< Value > const& v) {",
      "  int n = v.size();",
      "  if (n == 0) return std::vector< Value >{};",
      "  std::vector< std::pair< Value, int > > pairs(n);",
      "  for (auto i = 0; i < n; i++)",
      "    { pairs.at(i) = {v.at(i), i}; }",
      "  std::sort(pairs.begin(), pairs.end());",
      "  std::vector< Value > new_v(n);",
      "  auto prv = pairs.at(0).first;",
      "  auto i = 0;",
      "  for (auto & pair : pairs) {",
      "    Value crr; int pos; std::tie(crr, pos) = pair;",
      "    if (prv < crr) i++;",
      "    new_v.at(pos) = i;",
      "    prv = crr;",
      "  }",
      "  return new_v;",
      "}"
    ],
    "prefix": "compress"
  },
  "../include/algorithm/enumerate.hpp": {
    "body": [
      "template < template < typename ... > class Container, typename T >",
      "auto enumerate(Container< T > const& v) {",
      "  auto n = v.size();",
      "  Container< std::pair< int, T >> ret(n);",
      "  for (std::size_t i = 0; i < n; i++)",
      "    { ret.at(i) = {i, v.at(i)}; }",
      "  return ret;",
      "}"
    ],
    "prefix": "enumerate"
  },
  "../include/algorithm/extend.hpp": {
    "body": [
      "template < typename Container, typename = typename Container::value_type >",
      "inline auto extend(Container const& v, int k) {",
      "  auto ret = Container(k);",
      "  for (auto i = 0; i < k; i++)",
      "    { ret.at(i) = v.at(i % (int)v.size()); }",
      "  return ret;",
      "}"
    ],
    "prefix": "extend"
  },
  "../include/algorithm/keys.hpp": {
    "body": [
      "template < typename Map, typename Key = typename Map::key_type>",
      "inline auto keys(Map const& v) {",
      "  std::vector< Key > ret(v.size());",
      "  std::transform(v.begin(), v.end(), ret.begin(), [](auto&& t){ return t.first; });",
      "  return ret;",
      "}"
    ],
    "prefix": "keys"
  },
  "../include/algorithm/max_rangesum.hpp": {
    "body": [
      "template < typename Container, typename Value = typename Container::value_type >",
      "auto max_rangesum(Container v) {",
      "  assert(!v.empty());",
      "  std::partial_sum(v.begin(), v.end(), v.begin());",
      "  v.insert(v.begin(), 0);",
      "  Value min = v.front();",
      "  Value ret = v.at(1) - v.at(0);",
      "  for (auto x : v) {",
      "    ret = std::max(ret, x - min);",
      "    min = std::min(min, x);",
      "  }",
      "  return ret;",
      "}"
    ],
    "prefix": "max_rangesum"
  },
  "../include/algorithm/project.hpp": {
    "body": [
      "template < std::size_t I, typename Container,",
      "  typename Value = typename std::tuple_element_t< I, typename Container::value_type >>",
      "inline auto project(Container const& v) {",
      "  std::vector< Value > ret(v.size());",
      "  std::transform(v.begin(), v.end(), ret.begin(), [](auto&& t){ return std::get< I >(t); });",
      "  return ret;",
      "}"
    ],
    "prefix": "project"
  },
  "../include/algorithm/runlength.hpp": {
    "body": [
      "template < template < typename ... > class Container, typename Value >",
      "auto runlength(Container< Value > const& v) {",
      "  auto n = (int)v.size();",
      "  if (n == 0)",
      "    { return Container< std::pair< Value, int > >{}; }",
      "  auto pos = Container< int >{};",
      "  for (auto i = 1; i < n; i++) {",
      "    if (v.at(i - 1) != v.at(i))",
      "      { pos.emplace_back(i); }",
      "  }",
      "  pos.emplace_back(n);",
      "  auto m = (int)pos.size();",
      "  auto len = Container< int >(m);",
      "  std::adjacent_difference(pos.begin(), pos.end(), len.begin());",
      "  auto ret = Container< std::pair< Value, int > >(m);",
      "  for (auto i = 0; i != m; i++)",
      "    { ret.at(i) = {v.at(pos.at(i) - 1), len.at(i)}; }",
      "  return ret;",
      "}"
    ],
    "prefix": "runlength"
  },
  "../include/algorithm/values.hpp": {
    "body": [
      "template < typename Map, typename Value = typename Map::key_type>",
      "inline auto values(Map const& v) {",
      "  std::vector< Value > ret(v.size());",
      "  std::transform(v.begin(), v.end(), ret.begin(), [](auto&& t){ return t.second; });",
      "  return ret;",
      "}"
    ],
    "prefix": "values"
  },
  "../include/algorithm/zip.hpp": {
    "body": [
      "template < template < typename ... > class Container, typename ... Args >",
      "auto zip(Container< Args > const& ... args) {",
      "  auto n = std::min({args.size() ... });",
      "  assert(n == std::max({args.size() ... }));",
      "  Container< std::tuple< Args ... >> ret(n);",
      "  for (std::size_t i = 0; i < n; i++)",
      "    { ret.at(i) = {args.at(i) ...}; }",
      "  return ret;",
      "}"
    ],
    "prefix": "zip"
  },
  "../include/algorithm/zip2.hpp": {
    "body": [
      "template < template < typename ... > class Container, typename T, typename U >",
      "auto zip2(Container< T > const& x, Container< U > const& y) {",
      "  auto n = x.size();",
      "  auto m = y.size();",
      "  assert(n == m);",
      "  Container< std::pair< T, U >> ret(n);",
      "  for (std::size_t i = 0; i < n; i++)",
      "    { ret.at(i) = {x.at(i), y.at(i)}; }",
      "  return ret;",
      "}"
    ],
    "prefix": "zip2"
  },
  "../include/bit_operations/bat.hpp": {
    "body": [
      "bool bat (int       x, int j) {return (x >> j) & 1  ;}",
      "bool bat (long long x, int j) {return (x >> j) & 1LL;}"
    ],
    "prefix": "bat"
  },
  "../include/bit_operations/ceil2.hpp": {
    "body": [
      "long long ceil2(long long x) {",
      "  if (x == 0 || x == 1) return 1LL;",
      "  return (std::numeric_limits< long long >::max() >> __builtin_clzll(x - 1) - 1) + 1;",
      "}",
      "int ceil2(int x) {",
      "  if (x == 0 || x == 1) return 1;",
      "  return (std::numeric_limits< int >::max() >> __builtin_clz(x - 1) - 1) + 1;",
      "}"
    ],
    "prefix": "ceil2"
  },
  "../include/bit_operations/insert_bit.hpp": {
    "body": [
      "template < class Value >",
      "Value insert_bit(Value x, int j, bool bit) {",
      "  Value low = x & (Value(1) << j) - 1;",
      "  return (x >> j << j + 1) + (Value(bit) << j) + low;",
      "}"
    ],
    "prefix": "insert_bit"
  },
  "../include/bit_operations/remove_bit.hpp": {
    "body": [
      "template < class Value >",
      "Value remove_bit(Value x, int j) {",
      "  Value low = x & (Value(1) << j) - 1;",
      "  return (x >> j + 1 << j) + low;",
      "}"
    ],
    "prefix": "remove_bit"
  },
  "../include/bit_operations/remove_common_header.hpp": {
    "body": [
      "auto remove_common_header(lint x, lint y) {",
      "  auto mask = std::numeric_limits< lint >::max() >> (__builtin_clzll(x ^ y) - 1);",
      "  return std::make_tuple(x & mask, y & mask, mask);",
      "}"
    ],
    "prefix": "remove_common_header"
  },
  "../include/combinator/combinator.hpp": {
    "body": [
      "template< typename F >",
      "class fixed_point : F {",
      "  public:",
      "    explicit constexpr fixed_point (F&& f) noexcept",
      "      : F(std::forward< F >(f)) {}",
      "    template< typename ... Args >",
      "    constexpr decltype(auto) operator()(Args&& ... args) const",
      "      { return F::operator()(*this, std::forward< Args >(args)...); }",
      "};",
      "template< typename F >",
      "static inline constexpr decltype(auto) fix (F&& f) noexcept",
      "  { return fixed_point< F >{std::forward< F >(f)}; }"
    ],
    "prefix": "combinator"
  },
  "../include/disjoint_sets/quick_find.hpp": {
    "body": [
      "class quick_find",
      "{",
      "  int                           n;",
      "  std::vector<int>              prt;",
      "  std::vector<std::vector<int>> child;",
      "",
      "public:",
      "  quick_find (int n) : n(n), prt(n), child(n)",
      "  {",
      "    std::iota(prt.begin(), prt.end(), 0);",
      "    for (int i = 0; i < n; i++) {",
      "      child.at(i) = {i};",
      "    }",
      "  }",
      "",
      "  auto collect ()             const {return prt;}",
      "  bool is_root (int x)        const {return find(x) == x;}",
      "  int  size    (int x)        const {return child.at(prt.at(x)).size();}",
      "  bool same    (int x, int y) const {return find(x) == find(y);}",
      "  int  find    (int x)        const {return prt.at(x);}",
      "",
      "  // Returns `true` if x and y are newly connected.",
      "  bool unite   (int x, int y)",
      "  {",
      "    if ((x = find(x)) == (y = find(y))) return false;",
      "    if (size(x) > size(y)) std::swap(x, y);",
      "    for (auto z : child.at(x))",
      "    {",
      "      prt.at(z) = y;",
      "      child.at(y).push_back(z);",
      "    }",
      "    decltype(child)::value_type{}.swap(child.at(x));",
      "    return true;",
      "  }",
      "};"
    ],
    "prefix": "quick_find"
  },
  "../include/disjoint_sets/union_find.hpp": {
    "body": [
      "class union_find {",
      "    int n;",
      "    std::vector<int> prt;",
      "",
      "  public:",
      "    union_find (int n) : n(n), prt(n, -1){}",
      "",
      "    bool is_root (int x)        const {return prt.at(x) < 0;}",
      "    int  size    (int x)        const {return -prt.at(find(x));}",
      "    bool same(int x, int y)     const {return find(x) == find(y);}",
      "    int  find    (int x)        const {",
      "      while (!is_root(x)) x = prt.at(x);",
      "      return x;",
      "    }",
      "    // Returns `true` if x and y are newly connected.",
      "    // The smaller one x becomes a child of the larger one y.",
      "    bool unite   (int x, int y) {",
      "      if ((x = find(x)) == (y = find(y))) return false;",
      "      if (size(x) > size(y)) std::swap(x, y);",
      "      prt.at(y) += prt.at(x);",
      "      prt.at(x) = y;",
      "      return true;",
      "    }",
      "};"
    ],
    "prefix": "union_find"
  },
  "../include/disjoint_sets/valued_quick_find.hpp": {
    "body": [
      "template <typename Value, typename BinaryOp>",
      "class valued_quick_find",
      "{",
      "  int                           n;",
      "  std::vector<int>              prt;",
      "  std::vector<std::vector<int>> child;",
      "  std::vector<Value>            table;",
      "  BinaryOp                      op;",
      "  Value                         id;",
      "",
      "  auto& op_eq (Value& x, Value y) const {return x = op(x, y);}",
      "",
      "public:",
      "  valued_quick_find (int n, BinaryOp op, Value id, Value init) :",
      "    n(n), prt(n), child(n), table(n, init), op(op), id(id)",
      "  {",
      "    std::iota(prt.begin(), prt.end(), 0);",
      "    for (int i = 0; i < n; i++) {",
      "      child.at(i) = {i};",
      "    }",
      "  }",
      "",
      "  auto collect ()             const {return prt;}",
      "  bool is_root (int x)        const {return find(x) == x;}",
      "  int  size    (int x)        const {return child.at(prt.at(x)).size();}",
      "  bool same    (int x, int y) const {return find(x) == find(y);}",
      "  int  find    (int x)        const {return prt.at(x);}",
      "  auto get     (int x)        const {return table.at(find(x));}",
      "  void set     (int x, Value val)   {table.at(find(x)) = val;}",
      "  void add     (int x, Value val)   {set(x, get(x) + val);}",
      "  auto collect_vals()         const",
      "  {",
      "    auto ret = std::vector<Value>(n);",
      "    for (auto i = 0; i < n; i++)",
      "    {",
      "      ret.at(i) = get(i);",
      "    }",
      "    return ret;",
      "  }",
      "",
      "  // Returns `true` if x and y are newly connected.",
      "  bool unite   (int x, int y)",
      "  {",
      "    if ((x = find(x)) == (y = find(y))) return false;",
      "    if (size(x) < size(y)) std::swap(x, y);",
      "    for (auto z : child.at(y))",
      "    {",
      "      prt.at(z) = x;",
      "      child.at(x).push_back(z);",
      "    }",
      "    op_eq(table.at(x), table.at(y));",
      "    table.at(y) = id;",
      "    typename decltype(child)::value_type{}.swap(child.at(y));",
      "    return true;",
      "  }",
      "};",
      "",
      "template <typename Value, typename BinaryOp, typename BinaryOp2>",
      "auto make_valued_quick_find(int n, BinaryOp op, Value id) {",
      "  return valued_quick_find<Value, BinaryOp>(n, op, id);",
      "}"
    ],
    "prefix": "valued_quick_find"
  },
  "../include/disjoint_sets/valued_union_find.hpp": {
    "body": [
      "",
      "template <typename Value, typename BinaryOp>",
      "class valued_union_find",
      "{",
      "  int                n;",
      "  std::vector<Value> table;",
      "  std::vector<int>   prt;",
      "  BinaryOp           op;",
      "  Value              id;",
      "",
      "public:",
      "  valued_union_find (int n, BinaryOp op, Value id, Value init) :",
      "    n(n), table(n, init), prt(n, -1), op(op), id(id)",
      "    {}",
      "",
      "  bool is_root (int x)        const {return prt.at(x) < 0;}",
      "  int  size    (int x)        const {return -prt.at(find(x));}",
      "  bool same    (int x, int y) const {return find(x) == find(y);}",
      "  int  find    (int x)        const",
      "  {",
      "    while (!is_root(x)) x = prt.at(x);",
      "    return x;",
      "  }",
      "  auto collect ()             const {return prt;}",
      "",
      "  // Returns `true` if x and y are newly connected.",
      "  // y becomes the partent.",
      "  bool unite   (int x, int y)",
      "  {",
      "    if ((x = find(x)) == (y = find(y))) return false;",
      "    if (size(x) > size(y)) std::swap(x, y);",
      "    prt.at(y) += prt.at(x);",
      "    prt.at(x) = y;",
      "    table.at(y) = op(table.at(y), table.at(x));",
      "    table.at(x) = id;",
      "    return true;",
      "  }",
      "",
      "  auto get     (int x)        const {return table.at(find(x));}",
      "  auto collect_vals ()        const",
      "  {",
      "    std::vector<Value> ret(n);",
      "    for (auto i = 0; i < n; i++)",
      "    {",
      "      ret.at(i) = get(i);",
      "    }",
      "    return ret;",
      "  }",
      "  void set     (int x, Value val)    {table.at(find(x)) = val;}",
      "  void add     (int x, Value val)    {set(x, get(x) + val);}",
      "};",
      "",
      "template <typename Value, typename BinaryOp>",
      "auto make_valued_union_find(int n, BinaryOp op, Value id, Value init)",
      "{",
      "  return valued_union_find<Value, BinaryOp>(n, op, id, init);",
      "}"
    ],
    "prefix": "valued_union_find"
  },
  "../include/disjoint_sets/weighted_quick_find.hpp": {
    "body": [
      "template <typename Value, typename BinaryOp1, typename BinaryOp2>",
      "class weighted_quick_find",
      "{",
      "  int                           n;",
      "  std::vector<int>              prt;",
      "  std::vector<std::vector<int>> child;",
      "  std::vector<Value>            table;",
      "  BinaryOp1                     op1;",
      "  BinaryOp2                     op2;",
      "  Value                         id;",
      "",
      "  auto& op1_eq (Value& x, Value y) const {return x = op1(x, y);}",
      "  auto& op2_eq (Value& x, Value y) const {return x = op2(x, y);}",
      "  auto& inv_eq (Value& x)          const {return x = op2(id, x);}",
      "",
      "public:",
      "  weighted_quick_find (int n, BinaryOp1 op1, BinaryOp2 op2, Value id) :",
      "    n(n), prt(n), child(n), table(n, id), op1(op1), op2(op2), id(id)",
      "  {",
      "    std::iota(prt.begin(), prt.end(), 0);",
      "    for (int i = 0; i < n; i++) {",
      "      child.at(i) = {i};",
      "    }",
      "  }",
      "",
      "  auto collect ()             const {return prt;}",
      "  bool is_root (int x)        const {return find(x) == x;}",
      "  int  size    (int x)        const {return child.at(prt.at(x)).size();}",
      "  bool same    (int x, int y) const {return find(x) == find(y);}",
      "  int  find    (int x)        const {return prt.at(x);}",
      "",
      "  // x - y",
      "  auto diff    (int x, int y) const",
      "  {",
      "    assert(same(x, y));",
      "    return op2(table.at(x), table.at(y));",
      "  }",
      "",
      "  // Returns `true` if x and y are newly connected.",
      "  // x - y = d",
      "  bool unite   (int x, int y, Value d)",
      "  {",
      "    inv_eq(d);",
      "    op1_eq(d, table.at(x));",
      "    op2_eq(d, table.at(y));",
      "    if ((x = find(x)) == (y = find(y))) return false;",
      "    if (size(x) < size(y))",
      "    {",
      "      std::swap(x, y);",
      "      inv_eq(d);",
      "    }",
      "    for (auto z : child.at(y))",
      "    {",
      "      prt.at(z) = x;",
      "      op1_eq(table.at(z), d);",
      "      child.at(x).push_back(z);",
      "    }",
      "    typename decltype(child)::value_type{}.swap(child.at(y));",
      "    return true;",
      "  }",
      "};",
      "",
      "template <typename Value, typename BinaryOp1, typename BinaryOp2>",
      "auto make_weighted_quick_find(int n, BinaryOp1 op1, BinaryOp2 op2, Value id) {",
      "  return weighted_quick_find<Value, BinaryOp1, BinaryOp2>(n, op1, op2, id);",
      "}"
    ],
    "prefix": "weighted_quick_find"
  },
  "../include/disjoint_sets/weighted_union_find.hpp": {
    "body": [
      "template <typename Value, typename BinaryOp1, typename BinaryOp2>",
      "class weighted_union_find",
      "{",
      "  int                n;",
      "  std::vector<int>   prt;",
      "  std::vector<Value> wt;",
      "  BinaryOp1          op1;",
      "  BinaryOp2          op2;",
      "  Value              id;",
      "",
      "  auto op1_eq (Value& x, Value y) const {return x = op1(x, y);}",
      "  auto op2_eq (Value& x, Value y) const {return x = op2(x, y);}",
      "  auto inv_eq (Value& x)          const {return x = op2(id, x);}",
      "  auto inv    (Value& x)          const {return inv_eq(x);}",
      "",
      "public:",
      "  weighted_union_find",
      "    (int n, BinaryOp1 op1, BinaryOp2 op2, Value id) :",
      "    n(n), prt(n, -1), wt(n, id), op1(op1), op2(op2), id(id)",
      "    {}",
      "",
      "  bool is_root   (int x)        const {return prt.at(x) < 0;}",
      "  int  size      (int x)              {return -prt.at(find(x));}",
      "  bool same      (int x, int y)       {return find(x) == find(y);}",
      "  auto collect   ()             const {return prt;}",
      "",
      "  auto get       (int x)",
      "  {",
      "    find(x);",
      "    return wt.at(x);",
      "  }",
      "  auto quiet_get (int x) const",
      "  {",
      "    auto ret = id;",
      "    while(!is_root(x))",
      "    {",
      "      op1_eq(ret, wt.at(x));",
      "      x = prt.at(x);",
      "    }",
      "    return ret;",
      "  }",
      "",
      "  // x - y",
      "  auto diff      (int x, int y)",
      "  {",
      "    assert(same(x, y));",
      "    return op2(get(x), get(y));",
      "  }",
      "  auto collect_wts ()",
      "  {",
      "    auto ret = std::vector<Value>(n);",
      "    for (auto i = 0; i < n; i++)",
      "    {",
      "      ret.at(i) = get(i);",
      "    }",
      "    return ret;",
      "  }",
      "  auto quiet_collect_wts() const",
      "  {",
      "    auto ret = std::vector<Value>(n);",
      "    for (auto i = 0; i < n; i++)",
      "    {",
      "      ret.at(i) = quiet_get(i);",
      "    }",
      "    return ret;",
      "  }",
      "",
      "  // Path compression.",
      "  int  find    (int x)",
      "  {",
      "    if (is_root(x)) return x;",
      "    else",
      "    {",
      "      auto root = find(prt.at(x));",
      "      op1_eq(wt.at(x), wt.at(prt.at(x)));",
      "      return prt.at(x) = root;",
      "    }",
      "  }",
      "",
      "  // Returns `true` if x and y are newly connected.",
      "  // x is the parent.",
      "  // x - y = d",
      "  bool unite   (int x, int y, Value d)",
      "  {",
      "    inv_eq(d);",
      "    op1_eq(d, get(x));",
      "    op2_eq(d, get(y));",
      "    if ((x = find(x)) == (y = find(y)))",
      "    {",
      "      assert(op2(get(x), get(y)) == d);",
      "      return false;",
      "    }",
      "    if (size(x) < size(y))",
      "    {",
      "      std::swap(x, y);",
      "      inv_eq(d);",
      "    }",
      "    prt.at(x) += prt.at(y);",
      "    prt.at(y) = x;",
      "    wt.at(y) = d;",
      "    return true;",
      "  }",
      "};",
      "",
      "template <typename Value, typename BinaryOp1, typename BinaryOp2>",
      "auto make_weighted_union_find(int n, BinaryOp1 op1, BinaryOp2 op2, Value id)",
      "{",
      "  return weighted_union_find<Value, BinaryOp1, BinaryOp2>(n, op1, op2, id);",
      "}"
    ],
    "prefix": "weighted_union_find"
  },
  "../include/flow/bipartite_matching.hpp": {
    "body": [
      "class bipartite_matching {",
      "    int L, R;",
      "    std::vector<std::vector<int>> graph;",
      "    std::vector<int> match, level;",
      "",
      "    bool bfs() {",
      "      std::fill(level.begin(), level.end(), -1);",
      "      std::queue<int> que;",
      "      for (auto i = 0; i < L; i++) {",
      "        if (match.at(i) < 0) {",
      "          level.at(i) = 0;",
      "          que.emplace(i);",
      "        }",
      "      }",
      "      bool ret = false;",
      "      while (!que.empty()) {",
      "        auto crr = que.front(); que.pop();",
      "        for (auto nxt : graph.at(crr)) {",
      "          if (level.at(nxt) != -1) continue;",
      "          level.at(nxt) = level.at(crr) + 1;",
      "          auto w = match.at(nxt);",
      "          if (w == -1)",
      "            { ret = true; }",
      "          else if (level.at(w) == -1) {",
      "            level.at(w) = level.at(crr) + 1;",
      "            que.emplace(w);",
      "          }",
      "        }",
      "      }",
      "      return ret;",
      "    }",
      "",
      "    bool dfs(int crr) {",
      "      for (auto nxt : graph.at(crr)) {",
      "        assert(level.at(nxt) <= level.at(crr) + 1);",
      "        if (level.at(nxt) < level.at(crr) + 1) continue;",
      "        level.at(nxt) = -1;",
      "        auto w = match.at(nxt);",
      "        if (w == -1 || dfs(w)) {",
      "          match.at(nxt) = crr;",
      "          match.at(crr) = nxt;",
      "          level.at(crr) = -1;",
      "          return true;",
      "        }",
      "      }",
      "      level.at(crr) = -1;",
      "      return false;",
      "    }",
      "",
      "  public:",
      "    bipartite_matching()=default;",
      "    bipartite_matching(int L, int R):",
      "      L(L), R(R), graph(L + R), match(L + R, -1), level(L + R)",
      "      {}",
      "",
      "    void insert(int u, int v) {",
      "      v += L;",
      "      graph.at(u).emplace_back(v);",
      "      graph.at(v).emplace_back(u);",
      "    }",
      "",
      "",
      "    int build () {",
      "      auto ret = 0;",
      "      while (bfs()) {",
      "        for (int i = 0; i < L; i++) {",
      "          if (match.at(i) == -1 && dfs(i))",
      "            { ret++; }",
      "        }",
      "      }",
      "      return ret;",
      "    }",
      "",
      "    auto collect() const {return match;}",
      "",
      "    auto count() const {",
      "      auto k = L + R - std::count(match.begin(), match.end(), -1);",
      "      assert(k % 2 == 0);",
      "      return k / 2;",
      "    }",
      "};"
    ],
    "prefix": "bipartite_matching"
  },
  "../include/flow/burnbury.hpp": {
    "body": [
      "template <typename Value>",
      "struct residue_edge {",
      "  int to; Value cap, original_cap; int rev;",
      "  residue_edge(int to, Value cap, int rev):",
      "    to(to), cap(cap), original_cap(cap), rev(rev){}",
      "};",
      "",
      "template <typename Value>",
      "std::ostream& operator<< (std::ostream& os, const residue_edge<Value>& e)",
      "  { return os << \"residue_edge{\" << \"to:\" << e.to << \",\" << \"cap:\" << e.cap << \",\" << \"rev:\" << e.rev << \"}\"; }",
      "",
      "template < typename Value >",
      "struct flow_edge {",
      "  int to; Value flow;",
      "  flow_edge(int to, Value flow) : to(to), flow(flow){}",
      "};",
      "template < typename Value >",
      "std::ostream& operator<< (std::ostream& os, const flow_edge<Value>& e)",
      "  { return os  << \"flow_edge{\"  << \"to:\" << e.to << \",\"  << \"flow:\" << e.flow  << \"}\"; }",
      "",
      "template < typename Value >",
      "class burnbury {",
      "    int                 n, source, sink;",
      "    Value               offset;",
      "    std::vector< bool > ckd;",
      "    std::vector< int >  level;",
      "    std::vector< std::vector< residue_edge< Value > > > graph;",
      "",
      "    static constexpr Value inf_flow = std::numeric_limits< Value >::max();",
      "",
      "    void bfs () {",
      "      std::queue<int> que;",
      "      que.emplace(source); level.at(source) = 0;",
      "      while (!que.empty()) {",
      "        auto crr = que.front(); que.pop();",
      "        for (auto const& e : graph.at(crr)) {",
      "          if (e.cap == 0) continue;",
      "          int nxt = e.to;",
      "          if (level.at(nxt) != -1) continue;",
      "          que.push(nxt);",
      "          level.at(nxt) = level.at(crr) + 1;",
      "        }",
      "      }",
      "    }",
      "",
      "    auto dfs (int crr, Value f = inf_flow) {",
      "      if (crr == sink) return f;",
      "      ckd.at(crr) = true;",
      "      for (auto& e : graph.at(crr)) {",
      "        auto nxt = e.to;",
      "        if (ckd.at(nxt) || e.cap == 0 || level.at(crr) >= level.at(nxt)) continue;",
      "        auto d = dfs(nxt, std::min(f, e.cap));",
      "        if (d > 0) {",
      "          e.cap -= d;",
      "          graph.at(nxt).at(e.rev).cap += d;",
      "          return d;",
      "        }",
      "      }",
      "      level.at(crr) = -1;",
      "      return Value(0);",
      "    }",
      "",
      "  public:",
      "    burnbury(int n, int source, int sink):",
      "      n(n), offset(0), source(source), sink(sink), graph(n){}",
      "",
      "    auto make_node() {",
      "      n++;",
      "      graph.resize(n);",
      "      return n - 1;",
      "    }",
      "",
      "    void insert(int u, int v, Value c) {",
      "      graph.at(u).emplace_back(v, c, graph.at(v).size());",
      "      graph.at(v).emplace_back(u, 0, graph.at(u).size() - 1);",
      "    }",
      "",
      "    void red_costs  (int x, Value c) { insert(source, x, c); }",
      "    void blue_costs (int x, Value c) { insert(x, sink, c);   }",
      "    void red_blue_costs(int x, int y, Value c) { insert(y, x, c); }",
      "    void blue_red_costs(int x, int y, Value c) { insert(x, y, c); }",
      "    void red_red_profits(int x, int y, Value c) {",
      "      offset += c;",
      "      auto z = make_node();",
      "      blue_costs(z, c);",
      "      red_blue_costs(z, x, inf_flow);",
      "      red_blue_costs(z, y, inf_flow);",
      "    }",
      "    void blue_blue_profits(int x, int y, Value c) {",
      "      offset += c;",
      "      auto z = make_node();",
      "      red_costs(z, c);",
      "      blue_red_costs(z, x, inf_flow);",
      "      blue_red_costs(z, y, inf_flow);",
      "    }",
      "",
      "    auto build() {",
      "      Value ret = 0;",
      "      while (true) {",
      "        level.assign(n, -1);",
      "        bfs();",
      "        if (level.at(sink) == -1) return ret;",
      "        ckd.assign(n, false);",
      "        while (true) {",
      "          auto f = dfs(source);",
      "          if (f == 0) break;",
      "          ret += f;",
      "        }",
      "      }",
      "    }",
      "",
      "    auto collect() const {",
      "      std::vector<std::vector<flow_edge<Value>>> ret(n);",
      "      for (auto i = 0; i < n; i++) {",
      "        for (auto const& e : graph.at(i)) {",
      "          auto flow = e.original_cap - e.cap;",
      "          if (flow > 0) ret.at(i).emplace_back(e.to, flow);",
      "        }",
      "      }",
      "      return ret;",
      "    }",
      "};"
    ],
    "prefix": "burnbury"
  },
  "../include/flow/dinic.hpp": {
    "body": [
      "template <typename Flow>",
      "struct residue_edge {",
      "  int to; Flow cap, original_cap; int rev;",
      "  residue_edge(int to, Flow cap, int rev):",
      "    to(to), cap(cap), original_cap(cap), rev(rev){}",
      "};",
      "",
      "template <typename Flow>",
      "std::ostream& operator<< (std::ostream& os, const residue_edge<Flow>& e){",
      "  return os",
      "    << \"residue_edge{\"",
      "    << \"to:\" << e.to << \",\"",
      "    << \"cap:\" << e.cap << \",\"",
      "    << \"rev:\" << e.rev",
      "    << \"}\";",
      "}",
      "",
      "template <typename Flow>",
      "struct flow_edge {",
      "  int to; Flow flow;",
      "  flow_edge(int to, Flow flow) : to(to), flow(flow){}",
      "};",
      "",
      "template <typename Flow>",
      "std::ostream& operator<< (std::ostream& os, const flow_edge<Flow>& e) {",
      "  return os",
      "    << \"flow_edge{\"",
      "    << \"to:\" << e.to << \",\"",
      "    << \"flow:\" << e.flow",
      "    << \"}\";",
      "}",
      "",
      "template <typename Flow>",
      "class dinic {",
      "    int                                          n, source, sink;",
      "    std::vector<bool>                            ckd;",
      "    std::vector<int>                             level;",
      "    std::vector<std::vector<residue_edge<Flow>>> graph;",
      "",
      "    static constexpr Flow inf_flow = std::numeric_limits<Flow>::max();",
      "",
      "    void bfs () {",
      "      std::queue<int> que;",
      "      que.emplace(source); level.at(source) = 0;",
      "      while (!que.empty()) {",
      "        auto crr = que.front(); que.pop();",
      "        for (auto const& e : graph.at(crr)) {",
      "          if (e.cap == 0) continue;",
      "          int nxt = e.to;",
      "          if (level.at(nxt) != -1) continue;",
      "          que.push(nxt);",
      "          level.at(nxt) = level.at(crr) + 1;",
      "        }",
      "      }",
      "    }",
      "",
      "    auto dfs (int crr, Flow f = inf_flow) {",
      "      if (crr == sink) return f;",
      "      ckd.at(crr) = true;",
      "      for (auto& e : graph.at(crr)) {",
      "        auto nxt = e.to;",
      "        if (ckd.at(nxt) || e.cap == 0 || level.at(crr) >= level.at(nxt)) continue;",
      "        auto d = dfs(nxt, std::min(f, e.cap));",
      "        if (d > 0) {",
      "          e.cap -= d;",
      "          graph.at(nxt).at(e.rev).cap += d;",
      "          return d;",
      "        }",
      "      }",
      "      level.at(crr) = -1;",
      "      return Flow(0);",
      "    }",
      "",
      "  public:",
      "    dinic (int n, int source, int sink):",
      "      n(n), source(source), sink(sink), graph(n){}",
      "",
      "    void insert(int u, int v, Flow c) {",
      "      graph.at(u).emplace_back(v, c, graph.at(v).size());",
      "      graph.at(v).emplace_back(u, 0, graph.at(u).size() - 1);",
      "    }",
      "",
      "    auto build() {",
      "      Flow ret = 0;",
      "      while (true) {",
      "        level.assign(n, -1);",
      "        bfs();",
      "        if (level.at(sink) == -1) return ret;",
      "        ckd.assign(n, false);",
      "        while (true) {",
      "          auto f = dfs(source);",
      "          if (f == 0) break;",
      "          ret += f;",
      "        }",
      "      }",
      "    }",
      "",
      "    auto collect() const {",
      "      std::vector<std::vector<flow_edge<Flow>>> ret(n);",
      "      for (auto i = 0; i < n; i++) {",
      "        for (auto const& e : graph.at(i)) {",
      "          auto flow = e.original_cap - e.cap;",
      "          if (flow > 0) ret.at(i).emplace_back(e.to, flow);",
      "        }",
      "      }",
      "      return ret;",
      "    }",
      "};"
    ],
    "prefix": "dinic"
  },
  "../include/flow/ford_fulkerson.hpp": {
    "body": [
      "template <typename T>",
      "class ford_fulkerson {",
      "  struct edge {",
      "    int to; T cap;",
      "    weak_ptr<edge> rev;",
      "    edge(int to, T cap) : to(to), cap(cap) {}",
      "  };",
      "  const int n, source, sink;",
      "  std::vector<bool> ckd;",
      "  std::vector<std::vector<shared_ptr<edge>>> grh;",
      "  static constexpr T inf = numeric_limits<T>::max();",
      "  T dfs () {",
      "    return fix ([&](auto dfs, int crr, int f = inf) -> T {",
      "      if (crr == sink) return f;",
      "      ckd[crr] = true;",
      "      for (auto& e : grh[crr]) {",
      "        if (ckd[e->to] || !e->cap) continue;",
      "        T d = dfs(e->to, min(f, e->cap));",
      "        if (d) {",
      "          e->cap -= d;",
      "          e->rev.lock()->cap += d;",
      "          return d;",
      "        }",
      "      }",
      "      return 0;",
      "    })(source);",
      "  }",
      "  public:",
      "    ford_fulkerson (int n, int source, int sink) :",
      "      n(n), source(source), sink(sink), grh(n)",
      "      {}",
      "    void insert(int u, int v, T c) {",
      "      auto e = make_shared<edge>(v, c);",
      "      auto r = make_shared<edge>(u, 0);",
      "      e->rev = r;",
      "      r->rev = e;",
      "      grh[u].push_back(e);",
      "      grh[v].push_back(r);",
      "    }",
      "    T cal() {",
      "      T ret = 0;",
      "      while (true) {",
      "        ckd.assign(n, false);",
      "        T f = dfs();",
      "        if (!f) return ret;",
      "        ret += f;",
      "      }",
      "    }",
      "};"
    ],
    "prefix": "ford_fulkerson"
  },
  "../include/flow/minimum_cost_flow.hpp": {
    "body": [
      "template <typename Flow, typename Cost>",
      "class minimum_cost_flow {",
      "    struct edge {",
      "      int to; Flow cap; Cost cost; int rev;",
      "      edge(int to, Flow cap, Cost cost, int rev): to(to), cap(cap), cost(cost), rev(rev){}",
      "    };",
      "",
      "    const int                      n, source, sink;",
      "    std::vector<Cost>              distance;",
      "    std::vector<std::vector<edge>> graph;",
      "    std::vector<int>               ckd;",
      "",
      "    const Flow max_flow = std::numeric_limits<Flow>::max();",
      "    const Cost max_dist = std::numeric_limits<Cost>::max();",
      "",
      "    template <typename T, typename U>",
      "    auto cmn(T& a, U b) {if (a > b) {a = b; return true;} return false;}",
      "",
      "    void bellman_ford() {",
      "      distance.assign(n, max_dist);",
      "      distance.at(source) = 0;",
      "      for (int t = 0; t < n; t++) {",
      "        bool renewed = false;",
      "        for (int i = 0; i < n; i++) {",
      "          for (auto const& e : graph.at(i)) {",
      "            if (e.cap == 0) continue;",
      "            auto crr = distance.at(i);",
      "            if (crr == max_dist) continue;",
      "            if (cmn(distance.at(e.to), crr + e.cost)) {",
      "              renewed = true;",
      "            }",
      "          }",
      "        }",
      "        if (!renewed) break;",
      "      }",
      "    }",
      "",
      "    void dijkstra() {",
      "      distance.assign(n, max_dist);",
      "      auto que = std::priority_queue<",
      "        std::pair    < Cost, int >,",
      "        std::vector  < std::pair < Cost, int > >,",
      "        std::greater < std::pair < Cost, int >> >{};",
      "      que.emplace(0, source);",
      "      while (!que.empty()) {",
      "        auto pair = que.top(); que.pop();",
      "        auto crd = pair.first;",
      "        auto crr = pair.second;",
      "        if (!cmn(distance.at(crr), crd)) continue;",
      "        for (auto e : graph.at(crr)) {",
      "          if (e.cap == 0) continue;",
      "          auto nxd = crd + e.cost;",
      "          if (distance.at(e.to) <= nxd) continue;",
      "          que.emplace(nxd, e.to);",
      "        }",
      "      }",
      "    }",
      "",
      "    auto flush_impl(int crr, Flow f) {",
      "      if (ckd.at(crr)) return Flow(0);",
      "      ckd.at(crr) = true;",
      "      if (crr == sink) return f;",
      "      for (auto & e : graph.at(crr)) {",
      "        if (e.cap == 0) continue;",
      "        if (distance.at(crr) + e.cost != distance.at(e.to)) continue;",
      "        auto d = flush_impl(e.to, std::min(f, e.cap));",
      "        if (d > 0) {",
      "          e.cap -= d;",
      "          graph.at(e.to).at(e.rev).cap += d;",
      "          return d;",
      "        }",
      "      }",
      "      return Flow(0);",
      "    }",
      "",
      "    auto flush() {",
      "      ckd.assign(n, false);",
      "      return flush_impl(source, max_flow);",
      "    }",
      "",
      "  public:",
      "    minimum_cost_flow(int n, int source, int sink) :",
      "      n(n), source(source), sink(sink), graph(n) {}",
      "",
      "    void insert(int u, int v, Flow cap, Cost cost) {",
      "      graph.at(u).emplace_back(v, cap, cost, graph.at(v).size());",
      "      graph.at(v).emplace_back(u, 0, -cost,  graph.at(u).size() - 1);",
      "    }",
      "",
      "    auto build(Flow required_flow) {",
      "      Cost ret = 0;",
      "      while (true) {",
      "        bellman_ford();",
      "        auto d = distance.at(sink);",
      "        if (distance.at(sink) == max_dist) break;",
      "        auto f = flush();",
      "        if (f >= required_flow) {",
      "          ret += d * required_flow;",
      "          return ret;",
      "        } else {",
      "          ret += d * f;",
      "          required_flow -= f;",
      "        }",
      "      }",
      "      return -1;",
      "    }",
      "};"
    ],
    "prefix": "minimum_cost_flow"
  },
  "../include/free_group/free_group.hpp": {
    "body": [
      "class free_group {",
      "  public:",
      "  static inline auto mul(std::string s, std::string t) {",
      "    while (",
      "        !s.empty() && !t.empty() &&",
      "        abs(s.back() - t.front()) == 32",
      "      )",
      "      {",
      "        s.erase(s.end() - 1); t.erase(t.begin());",
      "      }",
      "      return s + t;",
      "  }",
      "  static inline auto inv (std::string s) {",
      "    auto opp = [&] (char& c) {",
      "        if (0 <= c - 'a' && c - 'a' < 26) c -= 32;",
      "        else if (0 <= c - 'A' && c - 'A' < 26) c += 32;",
      "        else assert(false);",
      "      };",
      "    reverse(s.begin(), s.end());",
      "    for_each(s.begin(), s.end(), opp);",
      "    return s;",
      "  }",
      "};"
    ],
    "prefix": "free_group"
  },
  "../include/graph/bellman_ford.hpp": {
    "body": [
      "template <typename T>",
      "class bellman_ford {",
      "  using edge_t = tuple<T, int, int>;",
      "  const int n, r;",
      "  const std::vector<edge_t>& edg;",
      "  bool flg;",
      "  std::vector<long long> dst;",
      "  void cal () {",
      "      dst[r] = 0;",
      "      for (int q = n; q--;) {",
      "        flg = false;",
      "        for (auto const& e : edg) {",
      "          T d; int s, t; std::tie(d, s, t) = e;",
      "          if (dst[s] == inf) continue;",
      "          if (cmn(dst[t], dst[s] + d)) flg = true;",
      "        }",
      "      }",
      "  }",
      "  public:",
      "    const T inf;",
      "    bellman_ford (",
      "        const int n, const int r,",
      "        const std::vector<edge_t>& edg,",
      "        const T inf = numeric_limits<T>::max()",
      "      ) :",
      "      n(n), r(r), edg(edg), ",
      "      flg(false), dst(n, inf), inf(inf)",
      "      {",
      "        cal();",
      "      }",
      "    bellman_ford (",
      "        const int n, const int r,",
      "        const std::vector<edge_t>& edg",
      "      ) :",
      "      bellman_ford(n, r, edg, numeric_limits<T>::max())",
      "      {",
      "      }",
      "    bool has_negative_cycle () const {return flg;}",
      "    auto& result () {return dst;}",
      "};"
    ],
    "prefix": "bellman_ford"
  },
  "../include/graph/diameter_bfs.hpp": {
    "body": [
      "auto diameter_bfs(std::vector< std::vector< int > > graph) {",
      "  int n = graph.size();",
      "  auto ret = 0;",
      "  std::vector< int > dist(n, -1);",
      "  for (auto root = 0; root < n; root++) {",
      "    dist.assign(n, -1);",
      "    std::queue< int > que;",
      "    que.emplace(root);",
      "    dist.at(root) = 0;",
      "    while (!que.empty()) {",
      "      auto crr = que.front(); que.pop();",
      "      for (auto nxt : graph.at(crr)) {",
      "        if (dist.at(nxt) == -1) {",
      "          dist.at(nxt) = dist.at(crr) + 1;",
      "          que.emplace(nxt);",
      "        }",
      "      }",
      "    }",
      "    for (auto d : dist)",
      "      { ret = std::max(ret, d); }",
      "  }",
      "  return ret;",
      "}"
    ],
    "prefix": "diameter_bfs"
  },
  "../include/graph/diameter_dijkstra.hpp": {
    "body": [
      "template < class Value >",
      "auto diameter_dijkstra(std::vector< std::vector< std::pair< int, Value > > > graph) {",
      "  int n = graph.size();",
      "  auto inf = std::numeric_limits< Value >::max();",
      "  Value ret = 0;",
      "  std::vector< Value > dist(n, inf);",
      "  for (auto i = 0; i < n; i++) {",
      "    std::priority_queue<",
      "      std::pair< Value, int >,",
      "      std::vector < std::pair< Value, int > >,",
      "      std::greater< std::pair< Value, int > > > que;",
      "    auto root = i;",
      "    dist.assign(n, inf);",
      "    que.emplace(0, root);",
      "    dist.at(root) = 0;",
      "    while (!que.empty()) {",
      "      Value d; int crr; std::tie(d, crr) = que.top(); que.pop();",
      "      for (auto pair : graph.at(crr)) {",
      "        int nxt; Value w; std::tie(nxt, w) = pair;",
      "        auto e = d + w;",
      "        if (e < dist.at(nxt)) {",
      "          dist.at(nxt) = e;",
      "          que.emplace(e, nxt);",
      "        }",
      "      }",
      "    }",
      "    for (auto d : dist)",
      "      { ret = std::max(ret, d); }",
      "  }",
      "  return ret;",
      "}"
    ],
    "prefix": "diameter_dijkstra"
  },
  "../include/graph/diameter_floyd_warshall.hpp": {
    "body": [
      "template < class Value >",
      "auto diameter_floyd_warshall(std::vector< std::vector< Value > > a) {",
      "  int n = a.size();",
      "  auto inf = std::numeric_limits< Value >::max();",
      "  for (auto k = 0; k < n; k++) {",
      "    for (auto i = 0; i < n; i++) {",
      "      for (auto j = 0; j < n; j++) {",
      "        auto & z = a.at(i).at(j);",
      "        auto   x = a.at(i).at(k);",
      "        auto   y = a.at(k).at(j);",
      "        z = std::min(z, inf - x <= y",
      "          ? inf : x + y);",
      "      }",
      "    }",
      "  }",
      "  Value ret = 0;",
      "  for (auto i = 0; i < n; i++) {",
      "    for (auto j = 0; j < n; j++) {",
      "      ret = std::max(ret, a.at(i).at(j));",
      "    }",
      "  }",
      "  return ret;",
      "}"
    ],
    "prefix": "diameter_floyd_warshall"
  },
  "../include/graph/dijkstra.hpp": {
    "body": [
      "template < typename Value >",
      "auto dijkstra(std::vector< std::vector< std::pair< Value, int > > > const & graph, int start) {",
      "  std::vector< Value > dist(graph.size(), std::numeric_limits< Value >::max());",
      "  std::priority_queue<",
      "    std::pair< Value, int >,",
      "    std::vector< std::pair< Value, int > >,",
      "    std::greater< std::pair< Value, int > > > que;",
      "  que.emplace(0, start);",
      "  while (!que.empty()) {",
      "    Value d; int crr; std::tie(d, crr) = que.top(); que.pop();",
      "    if (dist.at(crr) <= d) continue;",
      "    dist.at(crr) = d;",
      "    for (auto pair : graph.at(crr)) {",
      "      Value cost; int nxt; std::tie(cost, nxt) = pair;",
      "      if (dist.at(nxt) - d <= cost) continue;",
      "      que.emplace(d + cost, nxt);",
      "    }",
      "  }",
      "  return dist;",
      "}"
    ],
    "prefix": "dijkstra"
  },
  "../include/graph/floyd_warshall.hpp": {
    "body": [
      "template < class Value >",
      "auto floyd_warshall(std::vector< std::vector< Value > > adj) {",
      "  int n = adj.size();",
      "  for (auto k = 0; k < n; k++) {",
      "    for (auto i = 0; i < n; i++) {",
      "      for (auto j = 0; j < n; j++) {",
      "        auto & crr = adj.at(i).at(j);",
      "        auto x = adj.at(i).at(k);",
      "        auto y = adj.at(k).at(j);",
      "        if (x < crr - y) {",
      "          crr = x + y;",
      "        }",
      "      }",
      "    }",
      "  }",
      "  return adj;",
      "}"
    ],
    "prefix": "floyd_warshall"
  },
  "../include/graph/heights.hpp": {
    "body": [
      "template<typename T>",
      "class calculate_heights {",
      "  const int n;",
      "  const std::vector<std::vector<std::pair<T, int>>>& grh;",
      "  std::vector<T> dp, ep;",
      "",
      "  void dfs (",
      "      int crr = 0,",
      "      int prt = 0",
      "    ) {",
      "      for (auto const& e : grh[crr]) {",
      "        T w; int nxt; std::tie(w, nxt) = e;",
      "        if (nxt == prt) continue;",
      "        dfs(nxt, crr);",
      "        chmax(dp[crr], dp[nxt] + w);",
      "      }",
      "    }",
      "",
      "  void efs (",
      "      int crr = 0,",
      "      int prt = 0",
      "    ) {",
      "      std::vector<T> cld = {ep[crr]};",
      "      for (auto const& e : grh[crr]) {",
      "        T w; int nxt; std::tie(w, nxt) = e;",
      "        if (nxt == prt) continue;",
      "        cld.push_back(dp[nxt] + w);",
      "      }",
      "      sort(cld.begin(), cld.end(), greater<T>());",
      "      for (auto const& e : grh[crr]) {",
      "        T w; int nxt; std::tie(w, nxt) = e;",
      "        if (nxt == prt) continue;",
      "        ep[nxt] = dp[nxt] + w == cld[0] ?",
      "            cld[1] + w : cld[0] + w;",
      "      }",
      "      for (auto const& e : grh[crr]) {",
      "        T w; int nxt; std::tie(w, nxt) = e;",
      "        if (nxt == prt) continue;",
      "        efs(nxt, crr);",
      "      }",
      "      chmax(dp[crr], ep[crr]);",
      "    }",
      "",
      "  public:",
      "    calculate_heights(",
      "        std::vector<std::vector<std::pair<T, int>>>& grh",
      "      ) :",
      "      n(grh.size()),",
      "      grh(grh),",
      "      dp(n, 0),",
      "      ep(n, 0)",
      "      {",
      "        dfs();",
      "        efs();",
      "      }",
      "    ",
      "    auto operator[] (int i) const -> const T {return dp[i];}",
      "};"
    ],
    "prefix": "heights"
  },
  "../include/graph/is_tree.hpp": {
    "body": [
      "auto is_tree(std::vector< std::vector< int > > const & graph) {",
      "  int n = graph.size();",
      "  std::vector< int > ckd(n, false);",
      "  auto dfs = [&] (auto&& f, int crr, int prt) -> bool {",
      "    ckd.at(crr) = true;",
      "    for (auto nxt : graph.at(crr)) {",
      "      if (ckd.at(nxt)) {",
      "        if (nxt == prt) continue;",
      "        return true;",
      "      }",
      "      f(f, nxt, crr);",
      "    }",
      "    return false;",
      "  };",
      "  auto has_cycle   = dfs(dfs, 0, 0);",
      "  auto is_spanning = std::all_of(all(ckd), [](auto x){ return x; });",
      "  return !has_cycle && is_spanning;",
      "}"
    ],
    "prefix": "is_tree"
  },
  "../include/graph/kruskal.hpp": {
    "body": [
      "template<typename T>",
      "struct kruskal {",
      "  using edge_type = tuple<T, int, int>;",
      "  const int n;",
      "  std::vector<edge_type> edg;",
      "  std::vector<edge_type> mst;",
      "  T weight_of_mst;",
      "  kruskal (",
      "      int n,",
      "      std::vector<edge_type> edg",
      "    ) :",
      "    n(n),",
      "    edg(edg),",
      "    mst(n - 1),",
      "    weight_of_mst(0)",
      "    {",
      "      sort(edg.begin(), edg.end());",
      "      disjoint_set djs(n);",
      "      int cnt = 0;",
      "      for (auto e : edg) {",
      "        T w; int s, t; std::tie(w, s, t) = e;",
      "        if (djs.unite(s, t)) {",
      "          weight_of_mst += w;",
      "          mst[cnt] = {w, s, t};",
      "          if (++cnt == n - 1) break;",
      "        }",
      "      }",
      "      if (cnt < n - 1) assert(false);",
      "    }    ",
      "};"
    ],
    "prefix": "kruskal"
  },
  "../include/graph/low_link_tree.hpp": {
    "body": [
      "struct low_link_tree {",
      "  const int n;",
      "  const int r = 0;",
      "  int tmr = 0;",
      "  std::vector<int> ord;",
      "  std::vector<int> low;",
      "  set<int> art;",
      "  set<std::pair<int, int>> bdg;",
      "  std::vector<std::vector<int>> grh;",
      "public:",
      "  low_link_tree (",
      "    std::vector<std::vector<int>> const& grh,",
      "    const int root",
      "  )",
      "  : n(grh.size())",
      "  , r(root)",
      "  , ord(n, -1)",
      "  , low(n, -1)",
      "  , grh(grh)",
      "  {",
      "    dfs(r, r);",
      "  }",
      "  void dfs (",
      "    int crr",
      "  ,  int prt",
      "  ) {",
      "    int cnt = 0;",
      "    ord[crr] = low[crr] = tmr++;",
      "    for (int nxt : grh[crr]) {",
      "      if (ord[nxt] == -1) {",
      "        cnt++;",
      "        dfs(nxt, crr);",
      "        chmin(low[crr], low[nxt]);",
      "        if (crr != r && ord[crr] <= low[nxt]) art.insert(crr);",
      "        if (ord[crr] < low[nxt]) bdg.emplace(min(crr, nxt), max(crr, nxt));",
      "      }",
      "      if (nxt != prt) chmin(low[crr], ord[nxt]);",
      "    }",
      "    if (crr == r && cnt > 1) art.insert(crr);",
      "  }",
      "};"
    ],
    "prefix": "low_link_tree"
  },
  "../include/graph/prim.hpp": {
    "body": [
      "template <typename T>",
      "struct prim {",
      "  const int n;",
      "  std::vector<std::vector<std::pair<T, int>>> grh;",
      "  T weight_of_mst;",
      "  prim (",
      "      std::vector<std::vector<std::pair<T, int>>> grh",
      "    ) :",
      "    n(grh.size()),",
      "    grh(grh),",
      "    weight_of_mst(0)",
      "    {",
      "      std::vector<bool> ckd(n, false);",
      "      priority_queue<",
      "        std::pair<T, int>,",
      "        std::vector<std::pair<T, int>>,",
      "        greater<std::pair<T, int>>",
      "      > que;",
      "      que.emplace(0, 0);",
      "      while (!que.empty()) {",
      "        T w; int t;",
      "        std::tie(w, t) = que.top(), que.pop();",
      "        if (ckd[t]) continue;",
      "        weight_of_mst += w, ckd[t] = true;",
      "        for (auto p : grh[t]) que.push(p);",
      "      }",
      "    }",
      "};"
    ],
    "prefix": "prim"
  },
  "../include/graph/shortest_cycle.hpp": {
    "body": [
      "// Returns {} if no cycle",
      "inline auto shortest_cycle (std::vector< std::vector< int > > const & graph) {",
      "  constexpr auto inf = std::numeric_limits< int >::max();",
      "  int n = graph.size();",
      "",
      "  std::vector< std::vector< int > > rev(n);",
      "  for (auto i = 0; i < n; i++) {",
      "    for (auto j : graph.at(i)) {",
      "      assert(i != j);               // no self-loop allowed",
      "      rev.at(j).emplace_back(i);",
      "    }",
      "  }",
      "",
      "  auto bfs = [&] (auto start) {",
      "    std::vector< int > dist(n, inf);",
      "    std::queue< int > que;",
      "    que.emplace(start);",
      "    while (!que.empty()) {",
      "      auto crr = que.front(); que.pop();",
      "      auto finish = false;",
      "      for (auto nxt : graph.at(crr)) {",
      "        if (dist.at(nxt) != inf) continue;",
      "        que.emplace(nxt);",
      "        dist.at(nxt) = (crr == start ? 0 : dist.at(crr)) + 1;",
      "        if (nxt == start) {",
      "          finish = true;",
      "          break;",
      "        }",
      "      }",
      "      if (finish)",
      "        { break; }",
      "    }",
      "",
      "    auto len = dist.at(start);",
      "    if (len == inf)",
      "      { return std::vector< int > {}; }",
      "    auto ret = std::vector< int > (len);",
      "    ret.front() = start;",
      "    auto crr = start;",
      "    for (auto d = len - 1; d >= 1; d--) {",
      "      for (auto nxt : rev.at(crr)) {",
      "        if (dist.at(nxt) == d)",
      "          { crr = nxt; break; }",
      "      }",
      "      ret.at(d) = crr;",
      "    }",
      "",
      "    // uniqueness check",
      "    std::set< int > set;",
      "    for (auto x : ret) set.insert(x);",
      "    assert((int)set.size() == len);",
      "",
      "    return ret;",
      "  };",
      "",
      "  auto min = inf;",
      "  auto ret = std::vector< int >{};",
      "  for (auto i = 0; i < n; i++) {",
      "    auto now = bfs(i);",
      "    if (!now.empty() && (int)now.size() < min) {",
      "      min = now.size();",
      "      std::swap(now, ret);",
      "    }",
      "  }",
      "  return ret;",
      "}"
    ],
    "prefix": "shortest_cycle"
  },
  "../include/graph/topological_sort.hpp": {
    "body": [
      "inline auto topological_sort(std::vector< std::vector < int > > const & graph) {",
      "  int n = graph.size();",
      "  std::vector< int > ckd(n, 0);",
      "  std::vector< int > sorted{};",
      "  auto dfs = [&] (auto&& f, int crr) -> bool {",
      "    ckd.at(crr) = 1;",
      "    auto ret = false;",
      "    for (auto nxt : graph.at(crr)) {",
      "      if (ckd.at(nxt) == 1) return true;",
      "      if (ckd.at(nxt) == 2) continue;",
      "      ret |= f(f, nxt);",
      "    }",
      "    sorted.emplace_back(crr);",
      "    ckd.at(crr) = 2;",
      "    return ret;",
      "  };",
      "  for (auto i = 0; i < n; i++) {",
      "    if (ckd.at(i) == 0 && dfs(dfs, i))",
      "      { return std::vector< int > {}; }",
      "  }",
      "  std::reverse(sorted.begin(), sorted.end());",
      "  return sorted;",
      "}"
    ],
    "prefix": "topological_sort"
  },
  "../include/grid/print_grid.hpp": {
    "body": [
      "template < typename Grid >",
      "auto print_grid(Grid const& grid) {",
      "  int h = grid.size();",
      "  int w = grid.front().size();",
      "  for (auto i = 0; i < h; i++) {",
      "    for(auto j = 0; j < w; j++) {",
      "      std::cout << (grid.at(i).at(j) ? '#' : '.');",
      "    }",
      "    std::cout << std::endl;",
      "  }",
      "}"
    ],
    "prefix": "print_grid"
  },
  "../include/grid/rotate45.hpp": {
    "body": [
      "template < typename Value >",
      "auto rotate45(std::vector< std::vector< Value > > const& grid, Value def) {",
      "  int h = grid.size();",
      "  int w = grid.front().size();",
      "  auto even = std::vector< std::vector < Value > >((h + w) / 2, std::vector< Value >((h + w) / 2, def));",
      "  auto odd  = std::vector< std::vector < Value > >((h + w) / 2, std::vector< Value >((h + w) / 2, def));",
      "  for (auto i = 0; i < h; i++) {",
      "    for(auto j = 0; j < w; j++) {",
      "      ((i + j) % 2 == 0 ? even : odd)",
      "        .at((i + j) / 2)",
      "        .at((h - 1 - i + j) / 2)",
      "        = grid.at(i).at(j);",
      "    }",
      "  }",
      "  return std::make_pair(even, odd);",
      "}"
    ],
    "prefix": "rotate45"
  },
  "../include/grid/rotate90.hpp": {
    "body": [
      "template < class Value >",
      "auto rotate90(std::vector< std::vector< Value > > const& a) {",
      "  std::size_t h = a.size(), w = a.front().size();",
      "  std::vector< std::vector< Value > > b(w, std::vector< Value >(h));",
      "  for (std::size_t i = 0; i < h; i++) {",
      "    for (std::size_t j = 0; j < w; j++) {",
      "      b.at(j).at(i) = a.at(i).at(j);",
      "    }",
      "  }",
      "  return b;",
      "}"
    ],
    "prefix": "rotate90"
  },
  "../include/grid/transpose.hpp": {
    "body": [
      "template < typename Value >",
      "auto transpose(std::vector< std::vector< Value > > const& grid) {",
      "  int h = grid.size();",
      "  int w = grid.front().size();",
      "  auto ret = std::vector< std::vector< Value > > (w, std::vector< Value >(h));",
      "  for (auto i = 0; i < h; i++) {",
      "    for(auto j = 0; j < w; j++) {",
      "      ret.at(j).at(i) = grid.at(i).at(j);",
      "    }",
      "  }",
      "  return ret;",
      "}"
    ],
    "prefix": "transpose"
  },
  "../include/io/container_io.hpp": {
    "body": [
      "template < typename Container, typename Value = typename Container::value_type, std::enable_if_t<!std::is_same< Container, std::string >::value, std::nullptr_t> = nullptr>",
      "std::istream& operator>> (std::istream& is, Container& v)",
      "  { for (auto & x : v) { is >> x; } return is; }",
      "",
      "template < typename Container, typename Value = typename Container::value_type, std::enable_if_t<!std::is_same< Container, std::string >::value, std::nullptr_t> = nullptr >",
      "std::ostream& operator<< (std::ostream& os, Container const& v) {",
      " os << \"{\";",
      "  for (auto it = v.begin(); it != v.end(); it++)",
      "    {os << (it != v.begin() ? \",\" : \"\") << *it;}",
      "  return os << \"}\";",
      "}"
    ],
    "prefix": "container_io"
  },
  "../include/io/pair_io.hpp": {
    "body": [
      "template <typename T, typename U>",
      "std::ostream& operator<< (std::ostream& os, const std::pair<T, U>& pair)",
      "  { return os << \"(\" << pair.first << \",\" << pair.second << \")\"; }",
      "",
      "template <typename T, typename U>",
      "std::istream& operator>> (std::iostream& is, std::pair<T, U>& pair)",
      "  { return is >> pair.first >> pair.second; }"
    ],
    "prefix": "pair_io"
  },
  "../include/io/tuple_io.hpp": {
    "body": [
      "template < template < typename ... > class Tuple,  typename... Args, std::size_t ... Inds, std::size_t = std::tuple_size< Tuple < Args ... > >::value >",
      "std::istream& tuple_input_impl(std::istream& os, Tuple<Args...>& tuple, std::integer_sequence<std::size_t, Inds...>)",
      "  { (void)std::initializer_list<int>{((void)(os >> std::get< Inds >(tuple)), 0)...}; return os; }",
      "template < template < typename ... > class Tuple,  typename... Args, std::size_t = std::tuple_size< Tuple < Args ... > >::value >",
      "std::istream& operator>> (std::istream& os, Tuple<Args...>& tuple)",
      "  { return tuple_input_impl(os, tuple, std::index_sequence_for<Args...>()); }",
      "",
      "template < template < typename ... > class Tuple,  typename... Args, std::size_t ... Inds, std::size_t = std::tuple_size< Tuple < Args ... > >::value >",
      "std::ostream& tuple_output_impl(std::ostream& os, const Tuple<Args...>& tuple, std::integer_sequence<std::size_t, Inds...>)",
      "  { os << \"(\"; (void)std::initializer_list<int>{((void)(os << (Inds > 0 ? \",\" : \"\") << std::get< Inds >(tuple)), 0)...}; return os << \")\"; }",
      "template < template < typename ... > class Tuple,  typename... Args, std::size_t = std::tuple_size< Tuple < Args ... > >::value >",
      "std::ostream& operator<< (std::ostream& os, const Tuple<Args...>& tuple)",
      " { return tuple_output_impl(os, tuple, std::index_sequence_for<Args...>()); }"
    ],
    "prefix": "tuple_io"
  },
  "../include/matricies/gauss_jordan_int.hpp": {
    "body": [
      "class gauss_jordan {",
      "  const int h, w;",
      "  int rk;",
      "  std::vector<bool> ckd;",
      "  std::vector<int> p, a;",
      "  void init () {",
      "    for (int j = 0; j < w; j++) {",
      "      for (int pvt = 0; pvt < h; pvt++) {",
      "        if (ckd[pvt]) continue;",
      "        if (a[j] >> pvt & 1) {",
      "          ckd[pvt] = true; rk++;",
      "          int comb = a[j] ^ 1 << pvt;",
      "          for (int i = 0; i < h; i++) if (p[i] >> pvt & 1) p[i] ^= comb;",
      "          for (int k = j; k < w; k++) if (a[k] >> pvt & 1) a[k] ^= comb;",
      "          break;",
      "        }",
      "      }",
      "    }",
      "  }",
      "  int transform (int y) const {",
      "    int z = 0;",
      "    for (int i = 0; i < h; i++) {",
      "      if (y >> i & 1) z |= p[i];",
      "    }",
      "    return z;",
      "  }",
      "  public:",
      "    gauss_jordan (",
      "        std::vector<int> a,",
      "        int h",
      "      ) :",
      "      h(h), w(a.size()), rk(0),",
      "      ckd(h, false),",
      "      p([&]{",
      "        std::vector<int> p(h); ",
      "        for (int i = 0, x = 1; i < h; i++, x *= 2) p[i] = x;",
      "        return p;",
      "      }()),",
      "      a(a)",
      "      {",
      "        init();",
      "      }",
      "    int rank () const {return rk;}",
      "    int kernel () const {return w - rk;}",
      "    int image () const {return h - rk;}",
      "    bool solvable (int y) const {",
      "      assert (!(y >> h));",
      "      int acm = accumulate(a.begin(), a.end(), 0, [](int x, int y){return x | y;});",
      "      int z = transform(y);",
      "      return !(~acm & z);",
      "    }",
      "};"
    ],
    "prefix": "gauss_jordan_int"
  },
  "../include/matricies/right_norm.hpp": {
    "body": [
      "// b = a * p",
      "template < typename Value >",
      "auto right_norm(std::vector< Value > const& a, int h) {",
      "  int  w = a.size();",
      "  auto b = a;",
      "  std::vector< int > frozen(w, false);",
      "  for (auto i = h - 1; i >= 0; i--) {",
      "    auto pivot = -1;",
      "    for (auto j = 0; j < w; j++) {",
      "      if (!frozen.at(j) && (b.at(j) & (1LL << i)))",
      "        { pivot = j; break; }",
      "    }",
      "    if (pivot == -1) continue;",
      "    frozen.at(pivot) = true;",
      "    for (auto j = 0; j < w; j++) {",
      "      if (j != pivot && (b.at(j) & (1LL << i)))",
      "        { b.at(j) ^= b.at(pivot); }",
      "    }",
      "  }",
      "  return b;",
      "}"
    ],
    "prefix": "right_norm"
  },
  "../include/matricies/square_matrix.hpp": {
    "body": [
      "template <int N, typename Semiring>",
      "class square_matrix",
      "{",
      "  template <int N_, typename Semiring_>",
      "  friend bool operator==(const square_matrix<N_, Semiring_>&, const square_matrix<N_, Semiring_>&);",
      "",
      "  public:",
      "    using this_type   = square_matrix<N, Semiring>;",
      "    using value_type  = typename Semiring::type;",
      "    using matrix_type = std::array<std::array<value_type, N>,  N>;",
      "",
      "  private:",
      "    matrix_type storage;",
      "",
      "  public:",
      "    constexpr square_matrix() = default;",
      "    constexpr square_matrix(const square_matrix&) = default;",
      "    constexpr square_matrix(square_matrix&&) = default;",
      "    square_matrix& operator=(const square_matrix&) = default;",
      "    square_matrix& operator=(square_matrix&&) = default;",
      "",
      "    constexpr square_matrix(const matrix_type& x) : storage(x){}",
      "    constexpr square_matrix",
      "    (",
      "      std::initializer_list<std::initializer_list<value_type>> list",
      "    )",
      "    {",
      "      int i = 0;",
      "      for (auto &row: list)",
      "      {",
      "        int j = 0;",
      "        for (auto val : row)",
      "        {",
      "          storage.at(i).at(j) = val;",
      "          j++;",
      "        }",
      "        i++;",
      "      }",
      "    }",
      "",
      "    // Special Elements.",
      "    static auto zero_matrix()",
      "    {",
      "      auto ret = this_type{};",
      "      for (int i = 0; i < N; i++)",
      "      {",
      "        for (int j = 0; j < N; j++)",
      "        {",
      "          ret.at(i, j) = Semiring::add_id();",
      "        }",
      "      }",
      "      return ret;",
      "    }",
      "",
      "    static auto identity_matrix()",
      "    {",
      "      auto ret = this_type{};",
      "      for (int i = 0; i < N; i++)",
      "      {",
      "        for (int j = 0; j < N; j++)",
      "        {",
      "          ret.at(i, j) = i == j",
      "            ? Semiring::mul_id()",
      "            : Semiring::add_id();",
      "        }",
      "      }",
      "      return ret;",
      "    }",
      "",
      "    // Accessors.",
      "    auto& at(int i, int j)       {return storage.at(i).at(j);}",
      "    auto& at(int i, int j) const {return storage.at(i).at(j);}",
      "",
      "    // Operaters.",
      "    auto& operator+=(const square_matrix& other)",
      "    {",
      "      auto ret = zero_matrix();",
      "      for (int i = 0; i < N; i++)",
      "      {",
      "        for (int j = 0; j < N; j++)",
      "        {",
      "          Semiring::add_eq(at(i,j), other.at(i, j));",
      "        }",
      "      }",
      "      return *this;",
      "    }",
      "",
      "    auto& operator*=(const square_matrix& other)",
      "    {",
      "      auto ret = zero_matrix();",
      "      for (int i = 0; i < N; i++)",
      "      {",
      "        for (int j = 0; j < N; j++)",
      "        {",
      "          for (int k = 0; k < N; k++)",
      "          {",
      "            Semiring::add_eq(ret.at(i, k), Semiring::mul(at(i, j), other.at(j, k)));",
      "          }",
      "        }",
      "      }",
      "      return *this = ret;",
      "    }",
      "};",
      "",
      "template <typename T>",
      "struct is_square_matrix : std::false_type{};",
      "",
      "template <int N, typename Semiring>",
      "struct is_square_matrix<square_matrix<N, Semiring>> : std::true_type{};",
      "",
      "template <typename T>",
      "bool operator==(const T& lhs, const T& rhs) { return lhs.value == rhs.value; }",
      "",
      "template <typename T>",
      "bool operator!=(const T& lhs, const T& rhs) { return !(lhs == rhs); }",
      "",
      "template <typename T>",
      "T operator+(T lhs, const T& rhs) { return lhs += rhs; }",
      "",
      "template <typename T>",
      "T operator*(T lhs, const T& rhs) { return lhs *= rhs; }",
      "",
      "",
      "template <int N, typename Semiring>",
      "std::string to_string(const square_matrix<N, Semiring>& a)",
      "{",
      "  using std::literals::string_literals::operator\"\"s;",
      "  auto ret = \"square_matrix{ \"s;",
      "  for (int i = 0; i < N; i++)",
      "  {",
      "    if (i > 0) ret += \", \";",
      "    ret += \"{ \";",
      "    for (int j = 0; j < N; j++)",
      "    {",
      "      if (j > 0) ret += \", \";",
      "      ret += std::to_string(a.at(i, j));",
      "    }",
      "    ret += \" }\";",
      "  }",
      "  ret += \" }\";",
      "  return ret;",
      "}",
      "",
      "template <typename T>",
      "struct min_tolopical",
      "{",
      "  using type = T;",
      "  static auto add_id()  {return std::numeric_limits<T>::max();}",
      "  static auto mul_id()  {return 0;}",
      "  static auto add(T x, T y) {return std::min(x, y);}",
      "  static auto mul(T x, T y)",
      "  {",
      "    if (x == add_id() || y == add_id()) return add_id();",
      "    return x + y;",
      "  }",
      "  static auto add_eq(T& x, T y) {return x = add(x, y);}",
      "};",
      "",
      "template <typename T>",
      "struct min_tolopical",
      "{",
      "  using type = T;",
      "  static auto add_id()  {return std::numeric_limits<T>::min();}",
      "  static auto mul_id()  {return 0;}",
      "  static auto add(T x, T y) {return std::max(x, y);}",
      "  static auto mul(T x, T y)",
      "  {",
      "    if (x == add_id() || y == add_id()) return add_id();",
      "    return x + y;",
      "  }",
      "  static auto add_eq(T& x, T y) {return x = add(x, y);}",
      "};",
      "",
      "template <int N, typename T>",
      "using min_tolopical_matrix = square_matrix<N, min_tolopical<T>>;",
      "",
      "template <int N, typename T>",
      "using max_tolopical_matrix = square_matrix<N, min_tolopical<T>>;"
    ],
    "prefix": "square_matrix"
  },
  "../include/mo/mo.hpp": {
    "body": [
      "class mo_algorithm {",
      "    int n, q, block;",
      "    std::vector< std::tuple< int, int, int > > queries;",
      "",
      "  public:",
      "    mo_algorithm(int n, int q, int block) :",
      "      n(n),",
      "      q(q),",
      "      block(block),",
      "      queries(q)",
      "      {}",
      "",
      "    void set(int i, int l, int r)",
      "      { queries.at(i) = std::make_tuple(i, l, r); }",
      "",
      "    void build() {",
      "      std::sort(queries.begin(), queries.end(), [this](auto const& a, auto const& b){",
      "        int la, ra, lb, rb;",
      "        std::tie(std::ignore, la, ra) = a;",
      "        std::tie(std::ignore, lb, rb) = b;",
      "        auto qa = la / block, qb = lb / block;",
      "        return qa != qb",
      "          ? qa < qb",
      "          : qa % 2 == 1",
      "          ? ra < rb",
      "          : ra > rb;",
      "      });",
      "    }",
      "",
      "    template < class Append, class Remove, class Write >",
      "    void run(Append const & append, Remove const & remove, Write const & write) {",
      "      auto i = 0, j = 0;",
      "      for(auto const tuple : queries) {",
      "        int id, l, r; std::tie(id, l, r) = tuple;",
      "        while (l < i) append(--i);",
      "        while (j < r) append(j++);",
      "        while (i < l) remove(i++);",
      "        while (r < j) remove(--j);",
      "        write(id);",
      "      }",
      "    }",
      "};"
    ],
    "prefix": "mo"
  },
  "../include/number_theory/divisors.hpp": {
    "body": [
      "inline auto divisors(int x) {",
      "  std::vector< int > ret;",
      "  std::stack < int > stk;",
      "  for (auto i = 1; i * i <= x; i++) {",
      "    if (x % i == 0) {",
      "      ret.emplace_back(i);",
      "      if (i * i < x)",
      "        { stk.emplace(x / i); }",
      "    }",
      "  }",
      "  while (!stk.empty())",
      "    { ret.emplace_back(stk.top()), stk.pop(); }",
      "  return ret;",
      "}"
    ],
    "prefix": "divisors"
  },
  "../include/number_theory/factor.hpp": {
    "body": [
      "template < class Value >",
      "inline auto factor(Value x) {",
      "  std::vector< std::pair< Value, int > > ret;",
      "  for (Value p = 2; p * p <= x; p++) {",
      "    int m = 0;",
      "    for (; x % p == 0; m++)",
      "      { x /= p; }",
      "    if (m > 0)",
      "      { ret.emplace_back(p, m); }",
      "  }",
      "  if (1 < x)",
      "    { ret.emplace_back(x, 1); }",
      "  return ret;",
      "}"
    ],
    "prefix": "factor"
  },
  "../include/number_theory/factorials.hpp": {
    "body": [
      "template < typename Value >",
      "class factorials {",
      "    std::vector< Value > fact, finv;",
      "",
      "  public:",
      "    factorials()=default;",
      "",
      "    void build(int n) {",
      "      fact.resize(n), finv.resize(n);",
      "      fact.at(0) = 1;",
      "      for (int i = 1; i < n; i++) fact.at(i) = fact.at(i - 1) * Value(i);",
      "      finv.at(n - 1) = Value(1) / fact.at(n - 1);",
      "      for (int i = n - 2; i >= 0; i--) finv.at(i) = finv.at(i + 1) * Value(i + 1);",
      "    }",
      "    auto operator()  (int i) const {return fact.at(i);}",
      "    auto inv         (int i) const {return finv.at(i);}",
      "    auto binom(int i, int j) const {",
      "      assert(0 <= i);",
      "      if (j < 0 ||i < j) return Value(0);",
      "      return fact.at(i) * finv.at(j) * finv.at(i - j);",
      "    }",
      "    auto deal(int i, int j) const",
      "      { return binom(i + j - 1, j - 1); }",
      "};"
    ],
    "prefix": "factorials"
  },
  "../include/number_theory/gcd.hpp": {
    "body": [
      "template < typename Value >",
      "inline auto gcd (Value a, Value b) {",
      "  if (a < 0) a = -a;",
      "  if (b < 0) b = -b;",
      "  if (a < b) std::swap(a, b);",
      "  while (b) {",
      "    a %= b;",
      "    std::swap(a, b);",
      "  }",
      "  return a;",
      "}"
    ],
    "prefix": "gcd"
  },
  "../include/number_theory/sieve_of_eratosthenes.hpp": {
    "body": [
      "template <size_t N>",
      "class sieve_of_eratosthenes {",
      "    std::bitset<N> is_prime_;",
      "",
      "  public:",
      "    constexpr sieve_of_eratosthenes(){",
      "      is_prime_ = ~is_prime_;",
      "      is_prime_.reset(0), is_prime_.reset(1);",
      "      for (size_t p = 2; p < N; p++) {",
      "        if (!is_prime_.test(p)) continue;",
      "        for (size_t j = 2; j * p < N; j++) {",
      "          is_prime_.reset(p * j);",
      "        }",
      "      }",
      "    }",
      "",
      "    // Return the bitset testing if a number is prime.",
      "    constexpr const auto& is_prime() const {return is_prime_;}",
      "",
      "    // Returns the vector of prime numbers.",
      "    template <typename T>",
      "    auto primes() const {",
      "      std::vector<T> primes{}; ",
      "      for (size_t i = 0; i < N; i++) {",
      "        if (is_prime_.test(i)) primes.push_back(i);",
      "      }",
      "      return primes;",
      "    }",
      "};"
    ],
    "prefix": "sieve_of_eratosthenes"
  },
  "../include/number_theory/tropical.hpp": {
    "body": [
      "template <typename T, typename F, std::enable_if_t<",
      "    std::is_same<std::result_of_t<F(T, T)>, T>::value,",
      "    std::nullptr_t> = nullptr>",
      "class tropical {",
      "    T value;",
      "  ",
      "  public:",
      "    using value_type = T;",
      "    constexpr tropical()=default;",
      "    constexpr tropical(const tropical&)=default;",
      "    constexpr tropical(tropical&&)=default;",
      "    tropical& operator=(const tropical&)=default;",
      "    tropical& operator=(tropical&&)=default;",
      "",
      "    constexpr tropical(T t) : value(t){}",
      "",
      "    auto const& operator()() const { return value; }",
      "    template <typename U>",
      "    explicit operator U() const { return static_cast<U>(value); }",
      "",
      "    auto& operator+=(const tropical& other) {",
      "      value = F{}(value, other.value);",
      "      return *this;",
      "    }",
      "    template <typename U>",
      "    auto& operator+=(const U& other) {return *this += tropical(other); }",
      "  ",
      "    template <typename U = T>",
      "    auto& operator*=(const tropical& other) {",
      "      value += other.value;",
      "      return *this;",
      "    }",
      "};",
      "template <typename T> struct is_tropical : std::false_type{};",
      "template <typename T, typename F> struct is_tropical <tropical<T, F>> : std::true_type{};",
      "template <typename T> constexpr bool is_tropical_v = is_tropical<T>::value;",
      "",
      "template <typename T, std::enable_if_t<",
      "  is_tropical_v<T>, std::nullptr_t> = nullptr>",
      "bool operator==(const T& lhs, const T& rhs) {return lhs.value == rhs.value;}",
      "",
      "template <typename T>",
      "auto operator+(const T& lhs, const T& rhs)",
      "  -> std::enable_if_t<is_tropical_v<T>, T>",
      "  {return T(lhs) += rhs;}",
      "",
      "template <typename T>",
      "auto operator*(const T& lhs, const T& rhs)",
      "  -> std::enable_if_t<is_tropical_v<T>, T>",
      "  {return T(lhs) *= rhs;}",
      "",
      "template <typename T, typename F>",
      "std::string to_string(const tropical<T, F>& a)",
      "  {return std::to_string(a());}",
      "",
      "template <typename T, typename F>",
      "std::ostream& operator<<(std::ostream& os, const tropical<T, F>& a)",
      "  {return os << a();}",
      "",
      "template <typename T, typename F>",
      "std::istream& operator>>(std::istream& is, tropical<T, F>& a)",
      "  {T x; is >> x; a = tropical<T, F>(x); return is;}",
      "",
      "template <typename T>",
      "struct min_fn_object {",
      "  auto operator()(T a, T b) {return std::min(a, b);}",
      "};",
      "template <typename T>",
      "struct max_fn_object {",
      "  auto operator()(T a, T b) {return std::max(a, b);}",
      "};",
      "using min_tropical = tropical<int, min_fn_object<int>>;",
      "using max_tropical = tropical<int, max_fn_object<int>>;"
    ],
    "prefix": "tropical"
  },
  "../include/range_queries/compressed_segment_tree.hpp": {
    "body": [
      "template<typename T, typename U>",
      "class compressed_segment_tree {",
      "  const std::vector<T> a;",
      "  const size_t sz, Sz;",
      "  std::vector<U> seg;",
      "  const std::function<U(U, U)> o;",
      "  const U id;",
      "  auto find (T k) const {",
      "    auto it = std::lower_bound(a.begin(), a.end(), k);",
      "    assert(it != a.end() && *it == k);",
      "    return it - a.begin() + sz;",
      "  }",
      "  public:",
      "    compressed_segment_tree (",
      "        const std::vector<T> a,",
      "        const std::function<U(U, U)> o,",
      "        const U id",
      "      ) :",
      "      a(a),",
      "      sz([&](){",
      "          size_t ret = 1;",
      "          for (; ret < a.size(); ret <<= 1) {}",
      "          return ret;",
      "        }()),",
      "      Sz(sz << 1),",
      "      seg(Sz, id),",
      "      o(o),",
      "      id(id)",
      "      {",
      "      }",
      "    void update (T x, const U& y) {",
      "      auto k = find(x);",
      "      seg[k] = y;",
      "      while(k >>= 1) {",
      "        seg[k] = o(seg[2 * k], seg[2 * k + 1]);",
      "      }",
      "    }",
      "    void add (T x, const U& y) {",
      "      update(x, at(x) + y);",
      "    }",
      "    U query (T l, T r) {",
      "      l = std::lower_bound(a.begin(), a.end(), l) - a.begin();",
      "      r = std::lower_bound(a.begin(), a.end(), r) - a.begin();",
      "      U L = id, R = id;",
      "      for(l += sz, r += sz; l < r; l >>= 1, r >>= 1) {",
      "        if(l & 1) L = o(L, seg[l++]);",
      "        if(r & 1) R = o(seg[--r], R);",
      "      }",
      "      return o(L, R);",
      "    }",
      "    U at (T x) const {",
      "      return seg[find(x)];",
      "    }",
      "    void print () const {",
      "      int n = a.size();",
      "      std::cout << std::setw(4) << \"----\"; for (int i = 0; i < n; i++) std::cout << std::setw(4) << \"----\" ; std::cout << std::endl;",
      "      std::cout << std::setw(4) << \"\"; for (auto const& e : a) std::cout << std::setw(4) << e; std::cout << std::endl;",
      "      std::cout << std::setw(4) << \"----\"; for (int i = 0; i < n; i++) std::cout << std::setw(4) << \"----\" ; std::cout << std::endl;",
      "      std::cout << std::setw(4) << \"val\"; for (auto const& e : a) std::cout << std::setw(4) << at(e); std::cout << std::endl;",
      "      std::cout << std::setw(4) << \"----\"; for (int i = 0; i < n; i++) std::cout << std::setw(4) << \"----\" ; std::cout << std::endl;",
      "    }",
      "};"
    ],
    "prefix": "compressed_segment_tree"
  },
  "../include/range_queries/disjoint_sparse_table.hpp": {
    "body": [
      "template <typename T>",
      "class disjoint_sparse_table {",
      "  const int n, ht;",
      "  const std::vector<int> msb;",
      "  const std::function<T(T, T)> o;",
      "  const std::vector<std::vector<T>> tab;",
      "  public:",
      "    disjoint_sparse_table (",
      "        const std::vector<T> a,",
      "        const std::function<T(T, T)> o",
      "      ) :",
      "      n(a.size()),",
      "      ht([&](){",
      "          int ret = 1;",
      "          for (int b = 2; b < n; b <<= 1) ret++;",
      "          return ret;",
      "        }()),",
      "      msb([&](){",
      "          int N = 1 << ht;",
      "          auto ret = std::vector<int>(N, 0); ret[0] = -1;",
      "          for (int i = 2; i < N; i++) ret[i] = ret[i >> 1] + 1;",
      "          return ret;",
      "        }()),",
      "      o(o),",
      "      tab([&](){",
      "          auto ret = std::vector<std::vector<T>>(ht, a);",
      "          for (int i = 1; i < ht; i++) {",
      "            int p = 1 << i; int P = p << 1;",
      "            for (int s = 0; s < n; s += P) {",
      "              int t = min(s + p, n);",
      "              for (int j = t - 2; j >= s; j--) ret[i][j] = o(a[j], ret[i][j + 1]);",
      "              for (int j = t + 1; j < min(s + P, n); j++) ret[i][j] = o(ret[i][j - 1], a[j]);",
      "            }",
      "          }",
      "          return ret;",
      "        }())",
      "      {",
      "      }",
      "    auto query (",
      "        int l,",
      "        int r",
      "      ) -> T",
      "      {",
      "        assert(l <= --r);",
      "        int m = msb[l ^ r];",
      "        return m == -1 ? tab[0][l] : o(tab[m][l], tab[m][r]);",
      "      }",
      "};"
    ],
    "prefix": "disjoint_sparse_table"
  },
  "../include/range_queries/lazy_segment_tree.hpp": {
    "body": [
      "",
      "template<",
      "  typename Value1,    typename Value2,",
      "  typename BinaryOp1, typename BinaryOp2, typename BinaryOp3,",
      "  typename UnaryOp1,  typename UnaryOp2",
      "  >",
      "class lazy_segment_tree {",
      "    struct node {",
      "      int id, l, r;",
      "      node(int id, int l, int r): id(id), l(l), r(r) {};",
      "      auto size() const { return r - l; }",
      "      auto left_child () const { assert(size() > 1); return node(id * 2,     l, (l + r) / 2); }",
      "      auto right_child() const { assert(size() > 1); return node(id * 2 + 1, (l + r) / 2, r); }",
      "    };",
      "",
      "    int                   size;",
      "    int                   n;",
      "    int                   N;",
      "    BinaryOp1             op1;",
      "    BinaryOp2             op2;",
      "    BinaryOp3             op3;",
      "    Value1                id1;",
      "    Value2                id2;",
      "    UnaryOp1              expand;",
      "    UnaryOp2              shrink;",
      "    std::vector< Value1 > table;",
      "    std::vector< Value2 > lazy;",
      "    node                  initial_node;",
      "",
      "    auto& op1_eq(Value1& x, Value1 y) {return x = op1(x, y);}",
      "    auto& op2_eq(Value1& x, Value2 y) {return x = op2(x, y);}",
      "    auto& op3_eq(Value2& x, Value2 y) {return x = op3(x, y);}",
      "",
      "    void cal(int u)",
      "      { table.at(u) = op1(table.at(2 * u), table.at(2 * u + 1)); }",
      "",
      "    auto chain(int u) const {",
      "      auto ret = std::vector<int>{};",
      "      for (auto i = u; i > 0; i /= 2)",
      "        { ret.emplace_back(i); }",
      "      std::reverse(ret.begin(), ret.end());",
      "      return ret;",
      "    }",
      "",
      "    auto prop(int u) {",
      "      op2_eq(table.at(u), lazy.at(u));",
      "      if (u < n) {",
      "        op3_eq(lazy.at(2 * u),     shrink(lazy.at(u)));",
      "        op3_eq(lazy.at(2 * u + 1), shrink(lazy.at(u)));",
      "      }",
      "      lazy.at(u)     = id2;",
      "      return table.at(u);",
      "    }",
      "",
      "    auto query_base(int l, int r, Value2 val, const node& now) {",
      "      prop(now.id);",
      "      if (now.r <= l || r <= now.l) return id1;",
      "      else if (l <= now.l && now.r <= r) {",
      "        op3_eq(lazy.at(now.id), val);",
      "        return prop(now.id);",
      "      }",
      "      else {",
      "        auto ret =op1(",
      "          query_base(l, r, shrink(val), now.left_child()),",
      "          query_base(l, r, shrink(val), now.right_child())",
      "        );",
      "        cal(now.id);",
      "        return ret;",
      "      }",
      "    }",
      "",
      "  public:",
      "    lazy_segment_tree(",
      "      int        size,",
      "      BinaryOp1  op1,",
      "      BinaryOp2  op2,",
      "      BinaryOp3  op3,",
      "      Value1     id1,",
      "      Value2     id2,",
      "      UnaryOp1   expand,",
      "      UnaryOp2   shrink",
      "    ):",
      "      size         (size),",
      "      n            (std::pow(2, int(std::log2(size)) + 1)),",
      "      N            (n * 2),",
      "      op1          (op1),",
      "      op2          (op2),",
      "      op3          (op3),",
      "      id1          (id1),",
      "      id2          (id2),",
      "      expand       (expand),",
      "      shrink       (shrink),",
      "      table        (N, id1),",
      "      lazy         (N, id2),",
      "      initial_node(1, 0, n)",
      "      {",
      "        std::mt19937 mt(std::random_device{}());",
      "        std::uniform_int_distribution< int > dist(-1'000'000, 1'000'000);",
      "        for (auto i = 0; i < 20; i++) {",
      "          Value1 ex1 = dist(mt), ex1_ = dist(mt);",
      "          Value2 ex2 = dist(mt);",
      "          assert(op1(ex1, id1)       == ex1);",
      "          assert(op2(ex1, id2)       == ex1);",
      "          assert(op3(ex2, id2)       == ex2);",
      "          assert(shrink(expand(ex2)) == ex2);",
      "          assert(op2(op1(ex1, ex1_), expand(ex2)) == op1(op2(ex1, ex2), op2(ex1_, ex2)));",
      "        }",
      "      }",
      "",
      "    void build(const Value1 x)",
      "      { std::fill(table.begin(), table.end(), x); }",
      "",
      "    void build(const std::vector< Value1 >& v) {",
      "      assert(int(v.size()) <= n);",
      "      std::copy(v.begin(), v.end(), table.begin() + n);",
      "      for (int i = n - 1; i >= 0; i--)",
      "        { cal(i); }",
      "    }",
      "",
      "    void act(int l, int r, Value2 val) {",
      "      for (int i = 1; i < n; i *= 2)",
      "        { val = expand(val); }",
      "      query_base(l, r, val, initial_node);",
      "    }",
      "",
      "    auto query(int l, int r)",
      "      { return query_base(l, r, id2, initial_node); }",
      "",
      "    auto quiet_at(int i) const {",
      "      i += n;",
      "      auto actor = id2;",
      "      for (auto j : chain(i)) {",
      "        actor = shrink(actor);",
      "        actor = op3(actor, lazy.at(j));",
      "      }",
      "      return op2(table.at(i), actor);",
      "    }",
      "",
      "    auto quiet_collect() const {",
      "      auto ret = std::vector< Value1 >(size);",
      "      for (auto i = 0; i < size; i++)",
      "        { ret.at(i) = quiet_at(i); }",
      "      return ret;",
      "    }",
      "",
      "    auto at(int i) {",
      "      i += n;",
      "      for (auto j : chain(i))",
      "        { prop(j); }",
      "      return table.at(i);",
      "    }",
      "",
      "    auto collect() {",
      "      for (int i = 0; i < N; i++)",
      "        { prop(i); }",
      "      auto ret = std::vector< Value1 >(size);",
      "      for (auto i = 0; i < size; i++)",
      "        { ret.at(i) = table.at(i + n); }",
      "      return ret;",
      "    }",
      "};",
      "",
      "template< class Value1, class Value2, class BinaryOp1, class BinaryOp2, class BinaryOp3, class UnaryOp1, class UnaryOp2 >",
      "auto make_lazy_segment_tree(",
      "  int        size,",
      "  BinaryOp1  op1,",
      "  BinaryOp2  op2,",
      "  BinaryOp3  op3,",
      "  Value1     id1,",
      "  Value2     id2,",
      "  UnaryOp1   expand,",
      "  UnaryOp2   shrink",
      ") {",
      "  return lazy_segment_tree<Value1, Value2, BinaryOp1, BinaryOp2, BinaryOp3, UnaryOp1, UnaryOp2 >(",
      "    size, op1, op2, op3, id1, id2, std::move(expand), std::move(shrink));",
      "}",
      "",
      "template< class Value1, class Value2, class BinaryOp1, class BinaryOp2, class BinaryOp3 >",
      "auto make_lazy_segment_tree(",
      "  int        size,",
      "  BinaryOp1  op1,",
      "  BinaryOp2  op2,",
      "  BinaryOp3  op3,",
      "  Value1     id1,",
      "  Value2     id2",
      ") {",
      "  auto f = [](auto x){return x;};",
      "  return make_lazy_segment_tree(size, op1, op2, op3, id1, id2, f, f);",
      "}",
      "",
      "template < class Value >",
      "struct vending_machine {",
      "  Value i;",
      "  vending_machine(Value i) : i(i) {}",
      "  auto issue() { return i++; }",
      "};"
    ],
    "prefix": "lazy_segment_tree"
  },
  "../include/range_queries/segment_tree.hpp": {
    "body": [
      "template<typename Value, typename BinaryOp>",
      "class segment_tree {",
      "    int                 sz, n, N;",
      "    BinaryOp            op;",
      "    Value               id;",
      "    std::vector<Value>  table;",
      "",
      "    auto& op_eq(Value& x, Value y) const { return x = op(x, y); }",
      "",
      "    void merge(int u)",
      "      { table.at(u) = op(table.at(2 * u), table.at(2 * u + 1)); }",
      "",
      "    Value query_impl(int l, int r, int k, int L, int R) const {",
      "      return l <= L && R <= r",
      "        ? table.at(k)",
      "        : R <= l || r <= L",
      "        ? id",
      "        : op(",
      "          query_impl(l, r, 2 * k, L, (L + R) / 2),",
      "          query_impl(l, r, 2 * k + 1, (L + R) / 2, R)",
      "        );",
      "    }",
      "",
      "  public:",
      "    segment_tree(int sz, BinaryOp op, Value id):",
      "      sz    (sz),",
      "      n     (std::pow(2, int(std::log2(2 * sz - 1)))),",
      "      N     (n * 2),",
      "      op    (op),",
      "      id    (id),",
      "      table (N, id)",
      "      {}",
      "",
      "    auto& at(int i)       { return table.at(n + i); }",
      "",
      "    auto& at(int i) const { return table.at(n + i); }",
      "",
      "    auto collect() const {",
      "      auto ret = std::vector<Value>(sz);",
      "      for (auto i = 0; i < sz; i++)",
      "        { ret.at(i) = at(i); }",
      "      return ret;",
      "    }",
      "",
      "    auto query(int l, int r) const",
      "      { return query_impl(l, r, 1, 0, n); }",
      "",
      "    void build_oneline(int i)",
      "      { for (i += n, i /= 2; i > 0; i /= 2) merge(i); }",
      "",
      "    void build()",
      "      { for (auto i = 1; i < n; i++) merge(i); }",
      "",
      "    void update (int u, Value val) {",
      "      at(u) = val;",
      "      build_oneline(u);",
      "    }",
      "",
      "    void add (int u, Value val) {",
      "      at(u) += val;",
      "      build_oneline(u);",
      "    }",
      "};",
      "",
      "template<typename Value, typename BinaryOp>",
      "auto make_segment_tree(int sz, BinaryOp op, Value id)",
      "  { return segment_tree<Value, BinaryOp>(sz, std::move(op), id); }"
    ],
    "prefix": "segment_tree"
  },
  "../include/range_queries/sliding_minimum.hpp": {
    "body": [
      "template < typename Value, typename Cmp = std::less< Value > >",
      "class sliding_minimum {",
      "    std::deque< Value > que;",
      "    void pop_to(int target) {",
      "      assert(target <= right);",
      "      while (left < target)",
      "        { shrink(); }",
      "    }",
      "    void push_to(int target) {",
      "      assert(target <= n);",
      "      while (right < target)",
      "        { extend(); }",
      "    }",
      "  public:",
      "    int n, left, right;",
      "    std::vector< Value > v;",
      "    Cmp                  cmp;",
      "    sliding_minimum(std::vector< Value > const& v, Cmp const & cmp) :",
      "      n(v.size()), left(0), right(0), v(v), cmp(cmp)",
      "      {}",
      "    auto get_left_index()  const { return left; }",
      "    auto get_right_index() const { return right; }",
      "    auto query_index() const",
      "      { assert(!que.empty()); return que.front(); }",
      "    auto query() const",
      "      { return v.at(query_index()); }",
      "    void shrink() {",
      "      if (que.front() == left++)",
      "        { que.pop_front(); }",
      "      assert(left <= right);",
      "    }",
      "    void extend() {",
      "      while (!que.empty() && !cmp(v.at(que.back()), v.at(right)))",
      "        { que.pop_back(); }",
      "      que.push_back(right++);",
      "      assert(right <= n);",
      "    }",
      "    void slide()",
      "      { shrink(); extend(); }",
      "    void advance_to(int l, int r)",
      "      { push_to(r); pop_to(l); }",
      "};",
      "template < typename Value, typename Cmp = std::less< Value > >",
      "auto make_sliding_minimum(std::vector< Value > const& v, Cmp const & cmp)",
      "  { return sliding_minimum< Value, Cmp >(v, cmp); }"
    ],
    "prefix": "sliding_minimum"
  },
  "../include/range_queries/sparse_table.hpp": {
    "body": [
      "template < class Value, class Op >",
      "class sparse_table {",
      "    int n, ht;",
      "    Op op;",
      "    std::vector< std::vector< Value > > table;",
      "",
      "  public:",
      "    sparse_table()=default;",
      "    sparse_table(std::vector< Value > const & a, Op const & op) :",
      "      n(a.size()),",
      "      ht(std::log2(n) + 1),",
      "      op(op),",
      "      table([this, &a, &op]{",
      "        std::vector< std::vector< Value > > table(ht, a);",
      "        auto block = 1;",
      "        for (auto & v : table) {",
      "          auto forward = false;",
      "          auto l = 0, r = block;",
      "          for (; forward || r <= n; l += block, r += block, forward ^= 1) {",
      "            if (forward)",
      "              { std::partial_sum(v.begin() + l, v.begin() + std::min(r, n), v.begin() + l, op);}",
      "            else",
      "              { std::partial_sum(v.rbegin() + n - r, v.rbegin() + n - l, v.rbegin() + n - r, op); }",
      "          }",
      "          block *= 2;",
      "        }",
      "        return table;",
      "      }())",
      "      {}",
      "",
      "    auto query(int l, int r) const {",
      "      r--;",
      "      if (l == r) return table.front().at(l);",
      "      auto const & v = table.at(std::log2(l ^ r));",
      "      return op(v.at(l), v.at(r));",
      "    }",
      "};",
      "template < class Value, class Op >",
      "auto make_sparse_table(std::vector< Value > const & a, Op const & op)",
      "  { return sparse_table< Value, Op>(a, op); }"
    ],
    "prefix": "sparse_table"
  },
  "../include/range_queries/sqrt_decomposition.hpp": {
    "body": [
      "class sqrt_decomposition {",
      "  public:",
      "    int n, block_size, block_number;",
      "",
      "    sqrt_decomposition(int n, int block_size) :",
      "      n(n),",
      "      block_size(block_size),",
      "      block_number((n + block_size - 1) / block_size)",
      "      {}",
      "",
      "    auto get_block_size()   const { return block_size;   }",
      "    auto get_block_number() const { return block_number; }",
      "",
      "    template < class Append, class Stamp >",
      "    void query(int l, int r, Append const & append, Stamp const & stamp) {",
      "      while (l % block_size && l < r) {",
      "        append(l, l / block_size);",
      "        l++;",
      "      }",
      "      while (r % block_size && l < r) {",
      "        r--;",
      "        append(r, r / block_size);",
      "      }",
      "      for (auto j = l / block_size; j < r / block_size; j++) {",
      "        stamp(j);",
      "      }",
      "    }",
      "};"
    ],
    "prefix": "sqrt_decomposition"
  },
  "../include/range_queries/wavelet_matrix.hpp": {
    "body": [
      "class fully_indexable_dictionary {",
      "    int                   n, blk;",
      "    std::vector<unsigned> data;",
      "    std::vector<int>      cum;",
      "",
      "    auto quat(int i) const { return i / 32; }",
      "    auto res (int i) const { return i % 32; }",
      "    bool bat  (unsigned  x, int i) const { return (x >> i) & 1u; }",
      "    auto bit_set (unsigned& x, int i) const { return x |= (1u << i); }",
      "",
      "  public:",
      "    fully_indexable_dictionary()=default;",
      "    fully_indexable_dictionary(int n):",
      "      n     (n),",
      "      blk   (n / 32 + 1),",
      "      data  (blk, 0),",
      "      cum   (blk)",
      "      {}",
      "",
      "    auto size()      const { return n; }",
      "    bool at  (int i) const { return bat (data.at(quat(i)), res(i)); }",
      "    void set (int i)       {        bit_set(data.at(quat(i)), res(i)); }",
      "",
      "    void build() {",
      "      cum.at(0) = 0;",
      "      for (auto i = 0; i < blk - 1; i++)",
      "        { cum.at(i + 1) = cum.at(i) + __builtin_popcount(data.at(i)); }",
      "    }",
      "",
      "    auto rank(int k) const {",
      "      return cum.at(quat(k))",
      "        + __builtin_popcount(data.at(quat(k)) & ((1u << res(k)) - 1));",
      "    }",
      "    auto rank(int k, bool x) const",
      "      { return x ? rank(k) : k - rank(k); }",
      "",
      "    auto select(int k, bool x) const {",
      "      assert(0 <= k);",
      "      auto lwr = 0, upr = n + 1;",
      "      while (lwr + 1 < upr) {",
      "        auto mid = (lwr + upr) / 2;",
      "        (rank(mid, x) <= k ? lwr : upr) = mid;",
      "      }",
      "      return lwr;",
      "    }",
      "    auto select(int k, bool x, int offset) const",
      "      { return select(x, k + rank(x, offset)); }",
      "};",
      "",
      "std::ostream& operator<<(std::ostream& os, fully_indexable_dictionary const& v) {",
      "  auto n = v.size();",
      "  os << \"{\";",
      "  for (auto i = 0; i < n; i++)",
      "    { os << (i > 0 ? \",\" : \"\") << std::noboolalpha << v.at(i); }",
      "  return os << \"}\";",
      "}",
      "",
      "template < typename Value  >",
      "class wavelet_matrix  {",
      "    using dict = fully_indexable_dictionary;",
      "",
      "    int                 h;",
      "    int                 w;",
      "    std::vector< dict > tab;",
      "    std::vector< int  > zs;",
      "    std::vector< int  > buf0;",
      "    std::vector< int  > buf1;",
      "",
      "    auto bat (int x, int j) -> bool {return (x >> j) & 1;}",
      "",
      "    auto rangefreq_impl(int i, int l, int r, Value min, Value max, Value lwr, Value upr) {",
      "      if (l == r) { return 0;}",
      "      if (i == h) { return (lwr <= min && min < upr) ? r - l : 0;}",
      "      auto mid = min + (max - min) / 2;",
      "      if (max < lwr || upr <= min) return 0;",
      "      if (lwr <= min && max < upr) return r - l;",
      "      auto lc = tab.at(i).rank(l, 1);",
      "      auto rc = tab.at(i).rank(r, 1);",
      "      return",
      "          rangefreq_impl(i + 1,        l - lc,        r - rc, min, mid, lwr, upr)",
      "        + rangefreq_impl(i + 1, lc + zs.at(i), rc + zs.at(i), mid, max, lwr, upr);",
      "    }",
      "",
      "  public:",
      "    wavelet_matrix()=default;",
      "    wavelet_matrix(std::vector< Value > v, int const h):",
      "      h   (h),",
      "      w   (v.size()),",
      "      tab (h, dict(w)),",
      "      zs  (h),",
      "      buf0(h),",
      "      buf1(h)",
      "    {",
      "      std::vector< Value > l(w), r(w);",
      "      for (auto i = 0; i < h; i++) {",
      "        auto& row = tab.at(i);",
      "        int p = 0, q = 0;",
      "        for (auto j = 0; j < w; j++) {",
      "          auto crr = v.at(j);",
      "          if (bat(crr, h - 1 - i)) {",
      "            r.at(q++) = crr;",
      "            row.set(j);",
      "          } else {",
      "            l.at(p++) = crr;",
      "          }",
      "        }",
      "        row.build();",
      "        zs.at(i) = p;",
      "        std::copy(r.begin(), r.begin() + q, l.begin() + p);",
      "        std::swap(l, v);",
      "      }",
      "    }",
      "",
      "    auto access(int k) const {",
      "      Value ret = 0;",
      "      for (auto i = 0; i < h; i++) {",
      "        auto& row = tab.at(i);",
      "        auto const upr = row.at(k);",
      "        ret = (ret << 1) | upr;",
      "        k = row.rank(k, upr) + zs.at(i) * upr;",
      "      }",
      "      return ret;",
      "    }",
      "    auto at(int k) const { return access(k); }",
      "",
      "    auto rank(int l, int r, Value x) {",
      "      for (auto i = 0; i < h; i++) {",
      "        auto upr = bat(x, h - i - 1);",
      "        l = tab.at(i).rank(l, upr) + zs.at(i) * upr;",
      "        r = tab.at(i).rank(r, upr) + zs.at(i) * upr;",
      "      }",
      "      return r - l;",
      "    }",
      "",
      "    auto select(int k, Value x) {",
      "      rank(0, w, x);",
      "      for (auto i = h - 1; i >= 0; i--) {",
      "        auto upr = bat(x, h - 1 - i);",
      "        k = tab.at(i).select(k, upr, buf0.at(i));",
      "        if (k < 0 || buf1.at(i) <= k) return w;",
      "        k -= buf0.at(i);",
      "      }",
      "      return k;",
      "    }",
      "    auto select(int k, Value x, int offset)",
      "      { return select(k + rank(0, offset, x), x); }",
      "",
      "    auto quantile(int l, int r, int k) {",
      "      assert(0 <= k && k <= r - l);",
      "      Value ret = 0;",
      "      for (auto i = 0; i < h; i++) {",
      "        auto p = tab.at(i).rank(l, true);",
      "        auto q = tab.at(i).rank(r, true);",
      "        if (k < q - p) {",
      "          l = p + zs.at(i);",
      "          r = q + zs.at(i);",
      "          ret |= Value(1) << (h - 1 - i);",
      "        } else {",
      "          k -= (q - p);",
      "          l -= p;",
      "          r -= q;",
      "        }",
      "      }",
      "      return ret;",
      "    }",
      "    auto rquantile(int l, int r, int k)",
      "      { return quantile(l, r, r - l - 1 - k); }",
      "",
      "    auto rangefreq(int l, int r, Value lwr, Value upr)",
      "      { return rangefreq_impl(0, l, r, 0, Value(1) << h, lwr, upr); }",
      "};"
    ],
    "prefix": "wavelet_matrix"
  },
  "../include/semirings/mint.hpp": {
    "body": [
      "template <typename T>",
      "T inverse(T a, T m) {",
      "  T u = 0, v = 1;",
      "  while (a != 0) {",
      "    T t = m / a;",
      "    m -= t * a; std::swap(a, m);",
      "    u -= t * v; std::swap(u, v);",
      "  }",
      "  assert(m == 1);",
      "  return u;",
      "}",
      "template <typename T>",
      "class modular {",
      "  private:",
      "    int value;",
      "  public:",
      "    constexpr modular() = default;",
      "    constexpr modular(const modular&) = default;",
      "    constexpr modular(modular&&) = default;",
      "    modular& operator=(const modular&) = default;",
      "    modular& operator=(modular&&) = default;",
      "",
      "    template <typename U>",
      "    modular (const U& x) {value = normalize(x);}",
      "",
      "    template <typename U>",
      "    static auto normalize(const U& x) {",
      "      int v = static_cast<int>(-mod() <= x && x < mod() ? x : x % mod());",
      "      if (v < 0) v += mod();",
      "      return v;",
      "    }",
      "",
      "    auto const& operator()() const { return value; }",
      "    template <typename U>",
      "    explicit operator U() const { return static_cast<U>(value); }",
      "    constexpr static auto mod() { return T::value; }",
      "",
      "    auto& operator+=(const modular& other) {",
      "      if ((value += other.value) >= mod()) value -= mod();",
      "      return *this;",
      "    }",
      "    auto& operator-=(const modular& other) {",
      "      if ((value -= other.value) < 0) value += mod();",
      "      return *this;",
      "    }",
      "    template <typename U>",
      "    auto& operator+=(const U& other) {return *this += modular(other); }",
      "    template <typename U>",
      "    auto& operator-=(const U& other) {return *this -= modular(other); }",
      "    auto operator-() const { return modular(-value); }",
      "    auto& operator++() {return *this += 1;}",
      "    auto& operator--() {return *this -= 1;}",
      "    auto  operator++(int) {modular result(*this); operator++(); return result;}",
      "    auto  operator--(int) {modular result(*this); operator--(); return result;}",
      "",
      "    template <typename U = T>",
      "    auto& operator*=(const modular& rhs) {",
      "      value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));",
      "      return *this;",
      "    }",
      "    auto& operator/=(const modular& other) {",
      "      return *this *= modular(inverse(other.value, mod()));",
      "    }",
      "};",
      "template <typename T> struct is_modular : std::false_type {};",
      "template <typename T> struct is_modular <modular<T>> : std::true_type{};",
      "template <typename T> constexpr bool is_modular_v = is_modular<T>::value;",
      "",
      "template <typename T> bool operator==(const modular<T>& lhs, const modular<T>& rhs) { return lhs() == rhs(); }",
      "template <typename T, typename U> bool operator==(const modular<T>& lhs, U rhs) { return lhs == modular<T>(rhs); }",
      "template <typename T, typename U> bool operator==(U lhs, const modular<T>& rhs) { return modular<T>(lhs) == rhs; }",
      "",
      "template <typename T> bool operator!=(const modular<T>& lhs, const modular<T>& rhs) { return !(lhs == rhs); }",
      "template <typename T, typename U> bool operator!=(const modular<T>& lhs, U rhs) { return !(lhs == rhs); }",
      "template <typename T, typename U> bool operator!=(U lhs, const modular<T>& rhs) { return !(lhs == rhs); }",
      "",
      "template <typename T> modular<T> operator+(const modular<T>& lhs, const modular<T>& rhs) { return modular<T>(lhs) += rhs; }",
      "template <typename T, typename U> modular<T> operator+(const modular<T>& lhs, U rhs) { return modular<T>(lhs) += rhs; }",
      "template <typename T, typename U> modular<T> operator+(U lhs, const modular<T>& rhs) { return modular<T>(lhs) += rhs; }",
      "",
      "template <typename T> modular<T> operator-(const modular<T>& lhs, const modular<T>& rhs) { return modular<T>(lhs) -= rhs; }",
      "template <typename T, typename U> modular<T> operator-(const modular<T>& lhs, U rhs) { return modular<T>(lhs) -= rhs; }",
      "template <typename T, typename U> modular<T> operator-(U lhs, const modular<T>& rhs) { return modular<T>(lhs) -= rhs; }",
      "",
      "template <typename T> modular<T> operator*(const modular<T>& lhs, const modular<T>& rhs) { return modular<T>(lhs) *= rhs; }",
      "template <typename T, typename U> modular<T> operator*(const modular<T>& lhs, U rhs) { return modular<T>(lhs) *= rhs; }",
      "template <typename T, typename U> modular<T> operator*(U lhs, const modular<T>& rhs) { return modular<T>(lhs) *= rhs; }",
      "",
      "template <typename T> modular<T> operator/(const modular<T>& lhs, const modular<T>& rhs) { return modular<T>(lhs) /= rhs; }",
      "template <typename T, typename U> modular<T> operator/(const modular<T>& lhs, U rhs) { return modular<T>(lhs) /= rhs; }",
      "template <typename T, typename U> modular<T> operator/(U lhs, const modular<T>& rhs) { return modular<T>(lhs) /= rhs; }",
      "",
      "template<typename T, typename U>",
      "modular<T> power (const modular<T>& a, U b) {",
      "  assert(b >= 0);",
      "  modular<T> x = a, ret = 1;",
      "  for (; b > 0; b /= 2) {",
      "    if (b % 2 == 1) ret *= x;",
      "    x *= x;",
      "  }",
      "  return ret;",
      "}",
      "",
      "template <typename T>",
      "std::string to_string(const modular<T>& a) {",
      "  return std::to_string(a());",
      "}",
      "template <typename T>",
      "auto operator<<(std::ostream& os, const T& a)",
      "  -> std::enable_if_t<is_modular_v<T>, std::ostream&>{",
      "    return os << a();",
      "  }",
      "template <typename T>",
      "auto operator>>(std::istream& is, T& a)",
      "  -> std::enable_if_t<is_modular_v<T>, std::istream&> {",
      "  long long x; is >> x;",
      "  a = T(x);",
      "  return is;",
      "}",
      "",
      "using mod_type = int;",
      "",
      "// struct variable_mod { static mod_type value; };",
      "// mod_type variable_mod::value;",
      "// mod_type& mod = variable_mod::value;",
      "// using mint = modular< variable_mod >;",
      "",
      "// constexpr int mod = 1'000'000'007;",
      "// using mint = modular<std::integral_constant<std::decay_t<decltype(mod)>, mod>>;"
    ],
    "prefix": "mint"
  },
  "../include/semirings/polynominal.hpp": {
    "body": [
      "",
      "template < class Mul, class Add, class Value, class Div, class Sub >",
      "class polynominal {",
      "    using poly_type = std::vector< Value >;",
      "    Mul mul_fn;",
      "    Add add_fn;",
      "    Value zero;",
      "    Div div_fn;",
      "    Sub sub_fn;",
      "    auto add_eq(Value & x, Value y) const { x = add_fn(x, y); }",
      "    auto sub_eq(Value & x, Value y) const { x = sub_fn(x, y); }",
      "",
      "  public:",
      "    polynominal()=default;",
      "    polynominal(",
      "      Mul const& mul_fn,",
      "      Add const& add_fn,",
      "      Value zero,",
      "      Div const& div_fn,",
      "      Sub const& sub_fn",
      "    ) :",
      "      mul_fn(mul_fn), add_fn(add_fn),",
      "      zero(zero),",
      "      div_fn(div_fn), sub_fn(sub_fn)",
      "      {}",
      "",
      "    auto& normalize(poly_type & a) const {",
      "      while (!a.empty() && a.back() == zero)",
      "        { a.pop_back(); }",
      "      return a;",
      "    }",
      "",
      "    auto add(poly_type const & a , poly_type const & b) const {",
      "      int l = a.size(), m = b.size();",
      "      int n = std::max(a.size(), b.size());",
      "      poly_type c(n, zero);",
      "      for (auto i = 0; i < n; i++) {",
      "        if (i < l) add_eq(c.at(i), a.at(i));",
      "        if (i < m) add_eq(c.at(i), b.at(i));",
      "      }",
      "      return normalize(c);",
      "    }",
      "    auto mul(poly_type const & a, poly_type const & b) const {",
      "      int l = a.size(), m = b.size();",
      "      int n = l + m - 1;",
      "      poly_type c(n, zero);",
      "      for (auto i = 0; i < l; i++) {",
      "        for (auto j = 0; j < m; j++) {",
      "          add_eq(c.at(i + j), mul_fn(a.at(i), b.at(j)));",
      "        }",
      "      }",
      "      return normalize(c);",
      "    }",
      "    auto sub(poly_type const & a , poly_type const & b) const {",
      "      int l = a.size(), m = b.size();",
      "      int n = std::max(a.size(), b.size());",
      "      poly_type c(n, zero);",
      "      for (auto i = 0; i < n; i++) {",
      "        if (i < l) add_eq(c.at(i), a.at(i));",
      "        if (i < m) sub_eq(c.at(i), b.at(i));",
      "      }",
      "      return normalize(c);",
      "    }",
      "    auto div(poly_type a, poly_type b) const {",
      "      normalize(a), normalize(b);",
      "      assert(!b.empty());",
      "      int l = a.size(), m = b.size();",
      "      if (l < m)",
      "        { return std::make_pair(poly_type{}, a); }",
      "      poly_type q(l - m + 1, zero);",
      "      while (m <= l) {",
      "        auto d = l - m;",
      "        auto x = div_fn(a.back(), b.back());",
      "        q.at(d) = x;",
      "        for (auto i = 0; i < m; i++)",
      "          { sub_eq(a.at(i + d), x * b.at(i)); }",
      "        normalize(a);",
      "        assert((int)a.size() < l);",
      "        l = a.size();",
      "      }",
      "      assert(a.size() < b.size());",
      "      return std::make_pair(q, normalize(a));",
      "    }",
      "};",
      "constexpr auto not_implemented = [](auto const x, auto const) {",
      "  static_assert([]{ return false; }(), \"Call to a not-implemented function.\" );",
      "  return x;",
      "};",
      "using not_implemented_t = std::decay_t< decltype(not_implemented) >;",
      "template < class Mul, class Add, class Value, class Div = not_implemented_t, class Sub = not_implemented_t >",
      "auto make_polynominal(",
      "  Mul const& mul_fn,",
      "  Add const& add_fn,",
      "  Value zero,",
      "  Div const& div_fn = not_implemented,",
      "  Sub const& sub_fn = not_implemented) {",
      "  return polynominal< Mul, Add, Value, Div, Sub >(mul_fn, add_fn, zero, div_fn, sub_fn);",
      "}"
    ],
    "prefix": "polynominal"
  },
  "../include/string_algorighms/fully_indexable_dictionary.hpp": {
    "body": [
      "class fully_indexable_dictionary {",
      "    using value_t = uint32_t;",
      "    using count_t = unsigned;",
      "    static constexpr size_t sz = 8 * sizeof(uint32_t);",
      "    bool built;",
      "    size_t full_length, n;",
      "    std::vector<value_t> row_data;",
      "    std::vector<count_t> rank_table;",
      "",
      "  public:",
      "    fully_indexable_dictionary(size_t full_length) :",
      "      built(false),",
      "      full_length(full_length),",
      "      n((full_length + sz - 1) / sz),",
      "      row_data(n), rank_table(n) {",
      "        debug(sz, n);",
      "      }",
      "",
      "    // Set the i-th bit.",
      "    void set(size_t i) {",
      "      assert(!built);",
      "      row_data.at(i / sz) |= (1u << i);",
      "    }",
      "",
      "    // Initialize the rank-table.",
      "    void build() {",
      "      assert(!built);",
      "      rank_table = [&]{",
      "        std::vector<count_t> pop_counts(n), rank_table(n);",
      "        std::transform(row_data.begin(), row_data.end(), pop_counts.begin(),",
      "          [](auto x){return __builtin_popcountl(x);});",
      "        std::partial_sum(pop_counts.begin(), pop_counts.end(), rank_table.begin());",
      "        rank_table.insert(rank_table.begin(), 0u);",
      "        return rank_table; ",
      "      }();",
      "      built = true;",
      "      debug(row_data, rank_table);",
      "    }",
      "",
      "    // Access the i-th bit.",
      "    auto access(size_t i) const -> bool {",
      "      return row_data.at(i / sz) >> (i % sz) & 1u;",
      "    }",
      "    // An alias of access",
      "    auto at(size_t i) const -> bool {return access(i);}",
      "    ",
      "    // Count the 1.",
      "    auto rank(size_t i) const -> count_t {",
      "      return rank_table.at(i / sz)",
      "        + __builtin_popcountl(row_data.at(i / sz) & ((1 << (i % sz)) - 1));",
      "    }",
      "",
      "    // Find the k-th 1. (That is the maximal i such that rank(i) <= k.)",
      "    // When not found, returns the full-size of the sequence.",
      "    auto select(size_t k) const -> size_t {",
      "      size_t left = 0, right = full_length + 1, mid;",
      "      while (right - left > 1) {",
      "        mid = (left + right) / 2;",
      "        (rank(mid) <= k ? left : right) = mid;",
      "      }",
      "      return left;",
      "    }",
      "};"
    ],
    "prefix": "fully_indexable_dictionary"
  },
  "../include/string_algorighms/kmp_algorithm.hpp": {
    "body": [
      "auto make_failure_table (std::string w) -> std::vector<int>",
      "{",
      "  int n = w.length();",
      "  std::vector<int> ret(n + 1, -1);",
      "  int len = 0, pos = 1;",
      "  while (pos < n) {",
      "    if (w.at(pos) == w.at(len)) {",
      "      ret.at(pos) = ret.at(len);",
      "    } else {",
      "      ret.at(pos) = len;",
      "      len = ret.at(len);",
      "      while (len >= 0 && w.at(len) != w.at(pos)) len = ret.at(len);",
      "    }",
      "    len++, pos++;",
      "  }",
      "  ret.at(pos) = len;",
      "  return ret;",
      "}",
      "",
      "class kmp_algorithm",
      "{",
      "    std::string w;",
      "    std::vector<int> failure_table;",
      "",
      "  public:",
      "    kmp_algorithm()=default;",
      "",
      "    kmp_algorithm(const std::string& w) :",
      "      w(w),",
      "      failure_table(std::move(make_failure_table(this->w)))",
      "      {}",
      "",
      "    // Returns the starting positions of all the matches.",
      "    auto search(std::string s) -> std::vector<int>",
      "    {",
      "      std::vector<int> ret;",
      "      int pos_w = 0, pos_s = 0;",
      "      while (pos_s < (int)s.length()) {",
      "        if (s.at(pos_s) == w.at(pos_w)) {",
      "          pos_s++, pos_w++;",
      "          if (pos_w == (int)w.length()) {",
      "            ret.push_back(pos_s - pos_w);",
      "            pos_w = failure_table.at(pos_w);",
      "          }",
      "        } else {",
      "          pos_w = failure_table.at(pos_w);",
      "          if (pos_w < 0) {",
      "            pos_s++, pos_w++;",
      "          }",
      "        }",
      "      }",
      "      return ret;",
      "    }",
      "};"
    ],
    "prefix": "kmp_algorithm"
  },
  "../include/string_algorighms/rolling_hash.hpp": {
    "body": [
      "class rolling_hash {",
      "  public:",
      "    using value_type     = long long;",
      "    using container_type = std::vector<value_type>;",
      "",
      "  private:",
      "    static constexpr size_t  mod_num = 2;",
      "    static constexpr std::array<value_type, mod_num> mods = {",
      "        1'000'000'007,",
      "        1'000'000'009",
      "      };",
      "    static constexpr value_type base    = 9973;",
      "",
      "    size_t                       n;",
      "    std::vector<container_type>  hash_table;",
      "    std::vector<container_type>  pow_table;",
      "",
      "    auto inverse(value_type a, value_type m) const -> value_type {",
      "      value_type u = 0, v = 1;",
      "      while (a != 0) {",
      "        value_type t = m / a;",
      "        m -= t * a; std::swap(a, m);",
      "        u -= t * v; std::swap(u, v);",
      "      }",
      "      assert(m == 1);",
      "      return u;",
      "    }",
      "",
      "  public:",
      "    // ctor, dtor",
      "    explicit rolling_hash() = default;",
      "    explicit rolling_hash(const rolling_hash&) = default;",
      "    explicit rolling_hash(rolling_hash&&) = default;",
      "    rolling_hash& operator=(const rolling_hash&) = default;",
      "    rolling_hash& operator=(rolling_hash&&) = default;",
      "    ~rolling_hash() = default;",
      "",
      "    rolling_hash(const std::string s) :",
      "      n(s.length()),",
      "      hash_table(mod_num, container_type(n + 1, 0)),",
      "      pow_table (mod_num, container_type(n + 1, 1))",
      "      {",
      "        for (size_t i = 0; i < mod_num; i++) {",
      "          auto  mod = mods.at(i);",
      "          auto& tab = hash_table.at(i);",
      "          auto& pab = pow_table.at(i);",
      "          for (size_t j = 0; j < n; j++) {",
      "            tab.at(j + 1) = (tab.at(j) * base + s.at(j)) % mod;",
      "            pab.at(j + 1) = (pab.at(j) * base) % mod;",
      "          }",
      "        }",
      "      }",
      "",
      "    // observers",
      "    auto hash(size_t l, size_t r) const {",
      "      auto ret = std::vector<value_type>{};",
      "      for (size_t i = 0; i < mod_num; i++) {",
      "        const auto  mod = mods.at(i);",
      "        const auto& tab = hash_table.at(i);",
      "        const auto& pab = pow_table.at(i);",
      "        auto &      buf = ret.at(i);",
      "        buf = (tab.at(r) - tab.at(l)) * inverse(pab.at(l), mod) % mod;",
      "      }",
      "      return ret;",
      "    }",
      "};"
    ],
    "prefix": "rolling_hash"
  },
  "../include/string_algorighms/suffix_array.hpp": {
    "body": [
      "class suffix_array {",
      "    int                n;",
      "    std::string        s;",
      "    std::vector< int > suf;",
      "    std::vector< int > rank;",
      "    std::vector< int > lcp;",
      "",
      "  public:",
      "    suffix_array()=default;",
      "    suffix_array(const std::string& s) :",
      "      n(s.length()), s(s), suf(n), rank(n), lcp(n) {}",
      "",
      "    void build() {",
      "      suf.resize(n, 0);",
      "      rank.resize(n, 0);",
      "      std::iota(suf.begin(), suf.end(), 0);",
      "      for (auto i = 0; i < n; i++)",
      "        { rank.at(i) = s.at(i); }",
      "      auto comb = 1;",
      "      auto cmp = [&](auto i, auto j) {",
      "        if (rank.at(i) < rank.at(j)) return true;",
      "        if (rank.at(i) > rank.at(j)) return false;",
      "        if (n <= i + comb) return true;",
      "        if (n <= j + comb) return false;",
      "        return rank.at(i + comb) < rank.at(j + comb);",
      "      };",
      "      std::vector< int > buff(n);",
      "      for (; comb < n; comb *= 2) {",
      "        std::sort(suf.begin(), suf.end(), cmp);",
      "        buff.at(suf.front()) = 0;",
      "        for (auto i = 1; i < n; i++) {",
      "          buff.at(suf.at(i)) = buff.at(suf.at(i - 1)) + cmp(suf.at(i - 1), suf.at(i));",
      "        }",
      "        buff.swap(rank);",
      "      }",
      "      for (auto i = 0; i < n; i++)",
      "        { rank.at(suf.at(i)) = i; }",
      "",
      "      auto now = 0;",
      "      for (auto i = 0; i < n; i++) {",
      "        auto x = rank.at(i);",
      "        if (x == n - 1) continue;",
      "        auto y = x + 1;",
      "        auto j = suf.at(y);",
      "        if (0 < now) now--;",
      "        for (; now + std::max(i, j) < n; now++) {",
      "          if (s.at(i + now) != s.at(j + now))",
      "            { break; }",
      "        }",
      "        lcp.at(x) = now;",
      "      }",
      "    }",
      "",
      "    auto get_suf() const { return suf; }",
      "    auto get_lcp() const { return lcp; }",
      "};"
    ],
    "prefix": "suffix_array"
  },
  "../include/string_algorighms/trie.hpp": {
    "body": [
      "class trie_node {",
      "    int                 d;   // Root -> 0, One letter -> 1",
      "    std::vector< int >  ids;",
      "    std::vector< int >  nexts;",
      "",
      "  public:",
      "    trie_node(int n, int d): d(d), ids(), nexts(n, -1) {}",
      "",
      "    auto get_ids()   const { return ids;   }",
      "    auto get_nexts() const { return nexts; }",
      "    auto depth()     const { return d;     }",
      "",
      "    decltype(auto) emplace_back(int x) { return ids.emplace_back(x); }",
      "    decltype(auto) at          (int i) { return nexts.at(i);   }",
      "};",
      "",
      "std::ostream& operator<< (std::ostream& os, trie_node const& v) {",
      "  auto const & a = v.get_ids();",
      "  auto const & b = v.get_nexts();",
      "  os << \"({\";",
      "  for (auto it = a.begin(); it != a.end(); it++)",
      "    { os << (it == a.begin() ? \"\" : \" \" ) << *it; }",
      "  os << \"},{\";",
      "  for (auto it = b.begin(); it != b.end(); it++)",
      "    { os << (it == b.begin() ? \"\" : \" \" ) << *it; }",
      "  return os << \"})\";",
      "}",
      "",
      "template < typename Fn >",
      "class trie {",
      "  int                 n;       // The number of the kinds of chars",
      "  int                 cnt;     // The number of the strings",
      "  std::vector< trie_node > storage; // The seq of nodes",
      "  Fn                  encoder; // char -> int",
      "",
      "public:",
      "  trie()=default;",
      "  trie(int n, const Fn& encoder):",
      "    n(n),",
      "    cnt(0),",
      "    storage(1, trie_node(n, 0)),",
      "    encoder(encoder)",
      "    {}",
      "",
      "  auto get() const { return storage; }",
      "",
      "  // Automatically issue a string id.",
      "  void insert(const std::string& s) {",
      "    std::vector< int > seq(s.length());",
      "    std::transform(s.begin(), s.end(), seq.begin(), encoder);",
      "    auto pos = 0, d = 0;",
      "    for (auto x : seq) {",
      "      d++;",
      "      auto& now      = storage.at(pos);",
      "      auto& next_pos = now.at(x);",
      "      if (next_pos == -1) {",
      "        next_pos = storage.size();",
      "        storage.emplace_back(n, d);",
      "      }",
      "      pos = next_pos;",
      "    }",
      "    storage.at(pos).emplace_back(cnt++);",
      "  }",
      "",
      "  // Return the string ids.",
      "  auto find(const std::string& s) {",
      "    std::vector<int> seq(s.length());",
      "    std::transform(s.begin(), s.end(), seq.begin(), encoder);",
      "    auto vid = 0;",
      "    for (auto x : seq) {",
      "      vid = storage.at(vid).at(x);",
      "      if (vid == -1) return std::vector< int >{};",
      "    }",
      "    return storage.at(vid).get_ids();",
      "  }",
      "",
      "  auto count(const std::string& s)",
      "    { return find(s).size(); }",
      "",
      "  // Return the pairs of length & id",
      "  auto find_prefices(const std::string& s) {",
      "    int  n   = s.length();",
      "    auto ret = std::vector< std::pair< int, int > >{};",
      "    auto vid = 0;",
      "    for (int i = 0; i < n; i++) {",
      "      vid = storage.at(vid).at(encoder(s.at(i)));",
      "      if (vid == -1) return ret;",
      "      for (auto id : storage.at(vid).get_ids())",
      "        { ret.emplace_back(i + 1, id); }",
      "    }",
      "    return ret;",
      "  }",
      "};",
      "",
      "template < typename Fn >",
      "auto make_trie(int n, const Fn& encoder)",
      "  { return trie< Fn >(n, encoder); }"
    ],
    "prefix": "trie"
  },
  "../include/string_algorighms/z_algorithm.hpp": {
    "body": [
      "template < template < typename ... > class Container, typename Value >",
      "auto make_z_array(Container< Value > const & s) -> std::vector< int > {",
      "  if (s.empty()) return {};",
      "  auto n = (int)s.size();",
      "  std::vector< int > ret(n);",
      "  ret.at(0) = n;",
      "  auto i = 1, j = 0;",
      "  while (i < n) {",
      "    while (i + j < n && s.at(j) == s.at(i + j))",
      "      { j++; }",
      "    ret.at(i) = j;",
      "    if (j == 0)",
      "      { i++; }",
      "    else {",
      "      auto k = 1;",
      "      while (i + k < n && k + ret.at(k) < j) {",
      "        ret.at(i + k) = ret.at(k);",
      "        k++;",
      "      }",
      "      i += k, j -= k;",
      "    }",
      "  }",
      "  return ret;",
      "}",
      "",
      "// Returns turns all the occurence of w in s.",
      "template < template < typename ... > class Container, typename Value >",
      "auto z_search(Container< Value > const & w, Container< Value > const & s, Value dammy) -> std::vector<int> {",
      "  if (s.empty()) return {};",
      "  assert(!w.empty());",
      "  assert(std::find(w.begin(), w.end(), dammy) == w.end());",
      "  assert(std::find(s.begin(), s.end(), dammy) == s.end());",
      "  auto long_string = w;",
      "  long_string.push_back(dammy);",
      "  long_string.insert(long_string.end(), s.begin(), s.end());",
      "  auto z_array = make_z_array(std::move(long_string));",
      "  int m = w.size(), n = s.size();",
      "  std::vector<int> ret;",
      "  for (int i = 0; i < n; i++) {",
      "    if (z_array.at(m + 1 + i) == m)",
      "      { ret.push_back(i); }",
      "  }",
      "  return ret;",
      "}"
    ],
    "prefix": "z_algorithm"
  },
  "../include/templates/ctemp.hpp": {
    "body": [
      "#include <catch2/catch.hpp>",
      "#include <bits/stdc++.h>",
      "#define loop(n) for (int ngtkana_is_a_genius = 0; ngtkana_is_a_genius < int(n); ngtkana_is_a_genius++)",
      "#define rep(i, begin, end) for (int i = int(begin); (i) < int(end); i++)",
      "#define all(v) v.begin(), v.end()",
      "#define rand(l, r) std::uniform_int_distribution<>(l, r)(mt)",
      "using lint = long long;",
      "auto mt = std::mt19937_64(std::random_device{}());",
      "auto cmn = [](auto& a, auto b){ if (a > b) {a = b; return true;} return false; };",
      "auto cmx = [](auto& a, auto b){ if (a < b) {a = b; return true;} return false; };",
      "void debug_impl() { std::cerr << std::endl; }",
      "template <typename Head, typename... Tail>",
      "void debug_impl(Head head, Tail... tail) { std::cerr << \" \" << head; debug_impl(tail...); }",
      "#ifndef STOPIT",
      "#define debug(...)\\",
      "  do {\\",
      "    std::cerr << std::boolalpha << \"[\" << #__VA_ARGS__ << \"]:\";\\",
      "    debug_impl(__VA_ARGS__);\\",
      "    std::cerr << std::noboolalpha;\\",
      "  } while (false)",
      "#else",
      "#define debug(...) 0;",
      "#endif",
      "",
      "TEST_CASE( \"\", \"[]\" ) {",
      "  $0",
      "}"
    ],
    "prefix": "ctemp"
  },
  "../include/templates/stemp.hpp": {
    "body": [
      "#include <bits/stdc++.h>",
      "#define loop(n) for (int ngtkana_is_a_genius = 0; ngtkana_is_a_genius < int(n); ngtkana_is_a_genius++)",
      "#define rep(i, begin, end) for (int i = int(begin); (i) < int(end); i++)",
      "#define all(v) v.begin(), v.end()",
      "#define rand(l, r) std::uniform_int_distribution<>(l, r)(mt)",
      "using lint = long long;",
      "auto mt = std::mt19937_64(std::random_device{}());",
      "auto cmn = [](auto& a, auto b){ if (a > b) {a = b; return true;} return false; };",
      "auto cmx = [](auto& a, auto b){ if (a < b) {a = b; return true;} return false; };",
      "void debug_impl() { std::cerr << std::endl; }",
      "template <typename Head, typename... Tail>",
      "void debug_impl(Head head, Tail... tail) { std::cerr << \" \" << head; debug_impl(tail...); }",
      "#ifndef STOPIT",
      "#define debug(...)\\",
      "  do {\\",
      "    std::cerr << std::boolalpha << \"[\" << #__VA_ARGS__ << \"]:\";\\",
      "    debug_impl(__VA_ARGS__);\\",
      "    std::cerr << std::noboolalpha;\\",
      "  } while (false)",
      "#else",
      "#define debug(...) 0;",
      "#endif",
      "",
      "int main() {",
      "  std::cin.tie(0); std::cin.sync_with_stdio(false);",
      "  $0",
      "  return 0;",
      "}"
    ],
    "prefix": "stemp"
  },
  "../include/tree/centroid_tree.hpp": {
    "body": [
      "",
      "class centroid_tree {",
      "    int n;",
      "    int centroid;",
      "    std::vector< std::vector< int > > graph;",
      "    std::vector< int > depth;",
      "    std::vector< int > size;",
      "    std::vector< std::vector< int > > subtrees;",
      "",
      "    auto dead(int i) { return depth.at(i) != -1; }",
      "",
      "    auto build_impl(int root, int n, int d) -> int {",
      "      auto ctr = -1;",
      "      auto dfs = [&, this](auto&& f, int crr, int prv) -> int {",
      "        auto sz = 1;",
      "        for (auto const nxt : graph.at(crr)) {",
      "          if (nxt == prv || this->dead(nxt)) continue;",
      "          sz += f(f, nxt, crr);",
      "        }",
      "        if (ctr == -1 && n <= 2 * sz)",
      "          { ctr = crr; }",
      "        return size.at(crr) = sz;",
      "      };",
      "      dfs(dfs, root, root);",
      "",
      "      depth.at(ctr) = d;",
      "      for (auto const & nxt : graph.at(ctr)) {",
      "        if (dead(nxt)) continue;",
      "        auto sz = size.at(nxt);",
      "        if (n <= 2 * sz)",
      "          { sz = n - size.at(ctr); }",
      "        subtrees.at(ctr).emplace_back(build_impl(nxt, sz, d + 1));",
      "      }",
      "      size.at(ctr) = n;",
      "      return ctr;",
      "    }",
      "",
      "  public:",
      "    centroid_tree(std::vector< std::vector< int > > const& graph) :",
      "      n(graph.size()),",
      "      graph(graph),",
      "      depth(n, -1),",
      "      size(n),",
      "      subtrees(n)",
      "      {}",
      "",
      "    void build() {",
      "      centroid = build_impl(0, n, 0);",
      "    }",
      "",
      "    auto get_depth   () const { return depth;    }",
      "    auto get_size    () const { return size;     }",
      "    auto get_subtrees() const { return subtrees; }",
      "    auto get_centroid() const { return centroid; }",
      "};"
    ],
    "prefix": "centroid_tree"
  },
  "../include/tree/diameter_tree.hpp": {
    "body": [
      "template<typename T>",
      "class diameter_tree {",
      "    struct edge {",
      "      size_t to; T cost;",
      "      edge(size_t to, T cost) : to(to), cost(cost){}",
      "    };",
      "    size_t n;",
      "    std::vector<std::vector<edge>> graph;",
      "",
      "  public:",
      "    diameter_tree(size_t n) : n(n), graph(n){}",
      "",
      "    // Insert an edge.",
      "    void insert(size_t i, size_t j, T cost = 1) {",
      "      assert(0 <= i && i < n);",
      "      assert(0 <= j && j < n);",
      "      graph.at(i).emplace_back(j, cost);",
      "      graph.at(j).emplace_back(i, cost);",
      "    };",
      "",
      "    // Calculate the diameter_tree.",
      "    auto operator()(size_t root = 0){",
      "      std::vector<T> depth; ",
      "      auto cal = [&] (size_t r) {",
      "        depth.assign(n, 0);",
      "        fix ([&](auto dfs, size_t crr, size_t p) -> void {",
      "          for (auto const& e : graph.at(crr)) {",
      "            if (e.to == p) continue;",
      "            depth.at(e.to) = depth.at(crr) + e.cost;",
      "            dfs(e.to, crr);",
      "          }",
      "        })(r, r);",
      "      };",
      "      cal(root);",
      "      auto ex = std::max_element(depth.begin(), depth.end()) - depth.begin();",
      "      cal(ex);",
      "      return *std::max_element(depth.begin(), depth.end());",
      "    }",
      "};"
    ],
    "prefix": "diameter_tree"
  },
  "../include/tree/dynamic_distance.hpp": {
    "body": [
      "template <typename Cost>",
      "class dynamic_distance {",
      "    struct edge {",
      "        int to; Cost cost;",
      "        edge(int to, Cost cost) : to(to), cost(cost){}",
      "    };",
      "    int                            n, lg;",
      "    std::vector<std::vector<edge>> graph;",
      "    std::vector<int>               level;",
      "    std::vector<Cost>              depth;",
      "    std::vector<int>               prt;",
      "    std::vector<std::vector<int>>  tab;",
      "",
      "    auto lca (int u, int v) const -> int {",
      "        if (level.at(u) > level.at(v)) std::swap(u, v);",
      "        auto d = level.at(v) - level.at(u);",
      "        if (d > 0) {",
      "          for (int p = lg, q = std::pow(2, lg); p >= 0; p--, q /= 2) {",
      "            if (d > q) v = tab.at(p).at(v), d -= q;",
      "          }",
      "          v = prt.at(v), d--;",
      "        }",
      "        assert(d == 0);",
      "        assert(level.at(u) == level.at(v));",
      "        if (u == v) return u;",
      "        for (int p = lg, q = std::pow(2, lg); p >= 0; p--, q /= 2) {",
      "          auto next_u = tab.at(p).at(u);",
      "          auto next_v = tab.at(p).at(v);",
      "          if (next_u != next_v) u = next_u, v = next_v;",
      "        }",
      "        assert(u != v);",
      "        u = prt.at(u), v = prt.at(v);",
      "        assert(u == v);",
      "        return u;",
      "      }",
      "",
      "  public:",
      "    dynamic_distance(int n) :",
      "      n     (n),",
      "      lg    (std::log2(n)),",
      "      graph (n),",
      "      level (n, 0),",
      "      depth (n, 0),",
      "      prt   (n, -1),",
      "      tab   (lg + 1, std::vector<int>(n)) {}",
      "",
      "    void insert (int u, int v, Cost cost = 1) {",
      "      graph.at(u).emplace_back(v, cost);",
      "      graph.at(v).emplace_back(u, cost);",
      "    }",
      "",
      "    void build (int root = 0) {",
      "      prt.at(root) = root;",
      "      std::queue<int> que;",
      "      que.emplace(root);",
      "      while (!que.empty()) {",
      "        auto crr = que.front(); que.pop();",
      "        for (auto e : graph.at(crr)) {",
      "          if (prt.at(e.to) != -1) continue;",
      "          prt.at(e.to) = crr;",
      "          level.at(e.to) = level.at(crr) + 1;",
      "          depth.at(e.to) = depth.at(crr) + e.cost;",
      "          que.emplace(e.to);",
      "        }",
      "      }",
      "      assert(std::none_of(prt.begin(), prt.end(), [](auto x){ return x == -1; }));",
      "      tab.at(0) = prt;",
      "      for (auto i = 0; i < lg - 1; i++) {",
      "        auto& crr = tab.at(i);",
      "        auto& nxt = tab.at(i + 1);",
      "        for (auto x = 0; x < n; x++) {",
      "          nxt.at(x) = crr.at(crr.at(x));",
      "        }",
      "      }",
      "    }",
      "",
      "    auto operator() (int u, int v) const -> Cost {",
      "      return depth.at(u) + depth.at(v) - 2 * depth.at(lca(u, v));",
      "    }",
      "};"
    ],
    "prefix": "dynamic_distance"
  },
  "../include/tree/heavy_light_decomposition.hpp": {
    "body": [
      "class heavy_light_decomposition",
      "{",
      "  public:",
      "    using size_type  = int;",
      "    using index_type = int;",
      "    using id_type    = int;",
      "    using graph_type = std::vector<std::vector<index_type>>;",
      "    using tablele_type = std::vector<int>;",
      "",
      "  private:",
      "    size_type  n;",
      "    graph_type graph;",
      "    tablele_type prt, sz, depth, vid, ord, head;",
      "",
      "    // Helper",
      "    void first_dfs(index_type x)",
      "    {",
      "      for (auto& y : graph.at(x))",
      "      {",
      "        if (y == prt.at(x)) continue;",
      "        prt.at(y)   = x;",
      "        depth.at(y) = depth.at(x) + 1;",
      "",
      "        first_dfs(y);",
      "",
      "        sz.at(x) += sz.at(y);",
      "        auto& h = graph.at(x).front();",
      "        if (sz.at(h) < sz.at(y))",
      "        {",
      "          std::swap(h, y);",
      "        }",
      "      }",
      "    }",
      "",
      "    // Helper",
      "    void second_dfs(index_type x, id_type& counter)",
      "    {",
      "      ord.at(vid.at(x) = counter++) = x;",
      "      for (auto y : graph.at(x))",
      "      {",
      "        if (y == prt.at(x)) continue;",
      "        head.at(y) = y == graph.at(x).front()",
      "          ? head.at(x)",
      "          : y;",
      "         second_dfs(y, counter);",
      "      }",
      "    }",
      "",
      "  public:",
      "    heavy_light_decomposition()=default;",
      "    heavy_light_decomposition(const heavy_light_decomposition&)=default;",
      "    heavy_light_decomposition(heavy_light_decomposition&&)=default;",
      "    heavy_light_decomposition& operator=(const heavy_light_decomposition&)=default;",
      "    heavy_light_decomposition& operator=(heavy_light_decomposition&&)=default;",
      "",
      "    heavy_light_decomposition(int n) :",
      "      n     (n),",
      "      graph (n),",
      "      prt   (n),",
      "      sz    (n, 1),",
      "      depth (n, 0),",
      "      vid   (n),",
      "      ord   (n),",
      "      head  (n)",
      "      {}",
      "",
      "    // Accessers.",
      "    auto id(index_type x) const {return vid.at(x);}",
      "",
      "    void build (index_type root = 0)",
      "    {",
      "      id_type counter = 0;",
      "      first_dfs(root);",
      "      second_dfs(root, counter);",
      "    }",
      "",
      "    void insert (index_type x, index_type y)",
      "    {",
      "      graph.at(x).push_back(y);",
      "      graph.at(y).push_back(x);",
      "    }",
      "",
      "    template <typename RangeOp>",
      "    void for_each",
      "    (",
      "      index_type     x,",
      "      index_type     y,",
      "      RangeOp const& op,   // range-operation f([vid(x), vid(y)[)",
      "      bool           skip  // skip the top vertex",
      "    )",
      "    {",
      "      while (true)",
      "      {",
      "        if (id(x) > id(y)) std::swap(x, y);",
      "        if (head.at(x) == head.at(y))",
      "        {",
      "          op(id(x) + skip, id(y) + 1);",
      "          break;",
      "        }",
      "        op(id(head.at(y)), id(y) + 1);",
      "        y = prt.at(head.at(y));",
      "      }",
      "    }",
      "};"
    ],
    "prefix": "heavy_light_decomposition"
  },
  "../include/tree/lowest_common_ancestor.hpp": {
    "body": [
      "// Class for calculating LCA.",
      "// Dependent libraries: Combinator.",
      "template <typename T>",
      "class lowest_common_ancestor {",
      "    struct edge {",
      "        size_t to; T cost;",
      "        edge(size_t to, T cost) : to(to), cost(cost){}",
      "      };",
      "    size_t n, lg;",
      "    std::vector<std::vector<edge>>   graph;",
      "    std::vector<unsigned>            depth;",
      "    std::vector<T>                   weighted_depth;",
      "    std::vector<std::vector<size_t>> prt;",
      "  public:",
      "    using cost_type = T;",
      "    lowest_common_ancestor(size_t n) :",
      "      n(n), lg(std::log2(n)),",
      "      graph(n), depth(n, 0), weighted_depth(n, 0),",
      "      prt(lg + 1, std::vector<size_t>(n)) {}",
      "    // Insert an edge.",
      "    void insert (size_t u, size_t v, T cost = 1) {",
      "        graph.at(u).emplace_back(v, cost);",
      "        graph.at(v).emplace_back(u, cost);",
      "      }",
      "    // Build a doubling table.",
      "    void build (size_t root = 0) {",
      "        fix ([&](auto dfs, size_t crr, size_t p) -> void {",
      "          prt.at(0).at(crr) = p;",
      "          for (auto const& e : graph.at(crr)) {",
      "            if (e.to == p) continue;",
      "            depth.at(e.to) = depth.at(crr) + 1;",
      "            weighted_depth.at(e.to) = weighted_depth.at(crr) + e.cost;",
      "            dfs(e.to, crr);",
      "          }",
      "        })(root, root);",
      "        for (size_t p = 1; p <= lg; p++) {",
      "          for (size_t i = 0; i < n; i++) {",
      "            prt.at(p).at(i) = prt.at(p - 1).at(prt.at(p - 1).at(i));",
      "          }",
      "        }",
      "      }",
      "    // Calculate the lca.",
      "    auto operator()(size_t u, size_t v) const -> size_t {",
      "        if (depth.at(u) < depth.at(v)) std::swap(u, v);",
      "        auto diff = depth.at(u) - depth.at(v);",
      "        if (diff > 0) {",
      "          for (size_t p = lg, q = std::pow(2, lg); p <= lg; p--, q /= 2) {",
      "            if (diff > q) u = prt.at(p).at(u), diff -= q;",
      "          }",
      "          u = prt.at(0).at(u), diff--;",
      "        }",
      "        assert(diff == 0), assert(depth.at(u) == depth.at(v));",
      "        if (u == v) return u;",
      "        for (size_t p = lg, q = std::pow(2, lg); p <= lg; p--, q /= 2) {",
      "          auto next_u = prt.at(p).at(u);",
      "          auto next_v = prt.at(p).at(v);",
      "          if (next_u != next_v) u = next_u, v = next_v;",
      "        }",
      "        assert(u != v);",
      "        u = prt.at(0).at(u), v = prt.at(0).at(v), assert(u == v);",
      "        return u;",
      "      }",
      "    // Calculate the count-based distance.",
      "    auto row_dist (size_t u, size_t v) const -> unsigned {",
      "      return depth.at(u) + depth.at(v) - 2 * depth.at(operator()(u, v));}",
      "    // Calculate the count-based distance.",
      "    auto weighted_dist (size_t u, size_t v) const -> T {",
      "      auto& x = weighted_depth;",
      "      return x.at(u) + x.at(v) - 2 * x.at(operator()(u, v));}",
      "};"
    ],
    "prefix": "lowest_common_ancestor"
  },
  "../include/utility/fmt.hpp": {
    "body": [
      "// require gcc >= 7.1.0",
      "template < class ... Keys >",
      "class fmt_t {",
      "    using storage_t = std::tuple< Keys ... >;",
      "    storage_t storage;",
      "    static constexpr std::size_t N = sizeof ... (Keys);",
      "",
      "    // is_exact_match_impl",
      "    template < std::size_t I, class Value >",
      "      auto is_exact_match_impl(long, Value) const",
      "        { return false; }",
      "",
      "    template < std::size_t I, class Value,",
      "      std::enable_if_t<",
      "        std::is_same< std::decay_t< Value > , char >::value",
      "        == std::is_same< std::tuple_element_t< I, storage_t >, char >::value,",
      "      std::nullptr_t > = nullptr,",
      "      class = decltype(std::declval< Value >() == std::get< I >(std::declval< storage_t >())) >",
      "      auto is_exact_match_impl(int, Value x) const",
      "        { return x == std::get< I >(storage); }",
      "",
      "    template < class Value, std::size_t ... Is >",
      "      auto find_exact_match_impl(Value x, std::integer_sequence< std::size_t, Is ... >) const {",
      "        auto ret = false;",
      "        (void)std::initializer_list< std::nullptr_t >",
      "          { (ret |= is_exact_match_impl< Is >(int{}, x), nullptr) ...  };",
      "        return ret;",
      "      }",
      "",
      "    template < class Value >",
      "      auto exists_exact_match(Value x) const",
      "      {  return find_exact_match_impl(x, std::make_index_sequence< N >()); }",
      "",
      "    // tuple_format_impl",
      "    template < class Tuple,  std::size_t ... Is >",
      "    std::string tuple_format_impl(const Tuple& tuple, std::integer_sequence< std::size_t, Is ... >) const {",
      "      std::string ret = \"(\";",
      "      (void)std::initializer_list< std::nullptr_t >",
      "        { (ret = ret + (Is == 0 ? \"\" : \",\") + format(std::get< Is >(tuple)), nullptr) ... };",
      "      return ret + \")\";",
      "    }",
      "",
      "    // usual_format",
      "    template < class Value >",
      "    std::string usual_format(long, Value x) const",
      "      { return std::to_string(x); }",
      "",
      "    template < class Value, std::enable_if_t< std::is_same< std::decay_t< Value >, char >::value, std::nullptr_t > = nullptr >",
      "    std::string usual_format(int, Value c) const",
      "      { return std::string{'\\''} + std::string{c} + std::string{'\\''}; }",
      "",
      "    std::string usual_format(int, char const* s) const",
      "      { return \"\\\"\" + std::string(s) + \"\\\"\"; }",
      "",
      "    std::string usual_format(int, std::string const s) const",
      "      { return \"\\\"\" + s + \"\\\"\"; }",
      "",
      "    template < class Container, class = typename Container::value_type >",
      "    std::string usual_format(int, Container const & v) const {",
      "      return \"{\" + std::accumulate(v.begin(), v .end(), std::string{},",
      "        [this](auto const& s, auto const x) { return s + (s.empty() ? \"\" : \",\") + this->format(x); })",
      "        + \"}\";",
      "    }",
      "",
      "    template < class Tuple, std::size_t N = std::tuple_size< Tuple >::value >",
      "    std::string usual_format(int, Tuple const& tuple) const",
      "      { return tuple_format_impl(tuple, std::make_index_sequence< N >()); }",
      "",
      "    // format",
      "    template < class Value > std::string format(Value&& x) const",
      "      { return exists_exact_match(x) ? std::string{'_'} : usual_format(int{}, x); }",
      "",
      "  public:",
      "    fmt_t()=default;",
      "    template < Keys ... > fmt_t(Keys&& ... keys ) : storage(keys ... ){}",
      "",
      "    template < class Value > std::string operator()(Value&& x) const",
      "      { return format(x); }",
      "};",
      "template < class ... Keys > auto fmt(Keys&& ... keys)",
      "  { return fmt_t< Keys ... >(std::forward< Keys >(keys) ... ); }"
    ],
    "prefix": "fmt"
  },
  "../include/utility/guess.hpp": {
    "body": [
      "struct rational {int n, d;};",
      "auto to_string(rational r) -> std::string {",
      "  return r.d == 1",
      "    ? std::to_string(r.n)",
      "    : std::to_string(r.n) + \"/\" + std::to_string(r.d);",
      "}",
      "std::ostream& operator << (std::ostream& os, rational r)",
      "  { return os << to_string(r); }",
      "auto guess (mint k) -> rational {",
      "  auto const dmax = 1000;",
      "  auto const nmax = 1000;",
      "  for (auto d = 1; d < dmax; d++) {",
      "    auto n = int(k * mint(d));",
      "    if (n < nmax) return {n, d};",
      "    n = mod - n;",
      "    if (n < nmax) return {-n, d};",
      "  }",
      "  return {-1, 0};",
      "}"
    ],
    "prefix": "guess"
  },
  "../include/utility/inf.hpp": {
    "body": [
      "constexpr auto inf = (1 << 30) - 1;"
    ],
    "prefix": "inf"
  },
  "../include/utility/linf.hpp": {
    "body": [
      "constexpr auto inf = (1LL << 62) - 1;"
    ],
    "prefix": "linf"
  },
  "../include/utility/make_vector.hpp": {
    "body": [
      "template <typename T>",
      "auto make_vector_impl(size_t sz, T t) {return std::vector<T>(sz, t);}",
      "",
      "template <size_t N, typename T, typename U, std::enable_if_t<N == 1, std::nullptr_t> = nullptr>",
      "auto make_vector(size_t sz, U u) {return make_vector_impl(sz, T(u));}",
      "",
      "template <size_t N, typename T, std::enable_if_t<N == 1, std::nullptr_t> = nullptr>",
      "auto make_vector(size_t sz) {return std::vector<T>(sz);}",
      "",
      "template <size_t N, typename T, typename... Args, std::enable_if_t<N != 1, std::nullptr_t> = nullptr>",
      "auto make_vector(size_t a, Args... args) {return make_vector_impl(a, make_vector<N - 1, T>(args...));}",
      "",
      "template <typename T, typename Size_t>",
      "auto& at(T& t, Size_t i) {return t.at(i);}",
      "",
      "template <typename T, typename Size_t, typename... Args>",
      "auto& at(T& t, Size_t i, Args... args) {return at(t.at(i), args...);}"
    ],
    "prefix": "make_vector"
  },
  "../include/utility/powm1.hpp": {
    "body": [
      "inline auto powm1(auto x)",
      "  { return x % 2 ? -1 : +1; }"
    ],
    "prefix": "powm1"
  },
  "../include/utility/vending_machine.hpp": {
    "body": [
      "template < class Value >",
      "struct vending_machine{",
      "  Value i;",
      "  vending_machine(Value i) : i(i){}",
      "  auto issue() { return i++; }",
      "  auto peek() const { return i; }",
      "};",
      "template < class Value >",
      "auto make_vending_machine(Value i)",
      "  { return vending_machine< Value >(i); }"
    ],
    "prefix": "vending_machine"
  },
  "../snippets/algorithms/binary_serch.hpp": {
    "body": [
      "${1:int} ok = ${2:0}, ng = ${3:inf}, md;",
      "while (abs(ok - ng) > 1) {",
      "  md = (ok + ng) >> 1;",
      "  if (${4:ck(md)}) ok = md;",
      "  else ng = md;",
      "}"
    ],
    "prefix": "binary_serch"
  },
  "../snippets/algorithms/dfs1.hpp": {
    "body": [
      "fix ([&](auto dfs, int crr, int p) -> void {",
      "  for (auto const& nxt : graph.at(crr)) {",
      "    if (nxt == p) continue;",
      "    dfs(nxt, crr);",
      "  }",
      "})(${1:root}, $1);"
    ],
    "prefix": "dfs1"
  },
  "../snippets/algorithms/dfs2.hpp": {
    "body": [
      "fix ([&](auto dfs, int crr) -> void {",
      "  ckd.at(crr) = true;",
      "  for (auto const& nxt : graph.at(crr)) {",
      "    if (ckd.at(nxt)) continue;",
      "    dfs(nxt);",
      "  }",
      "})(${1:root});"
    ],
    "prefix": "dfs2"
  },
  "../snippets/algorithms/lis.hpp": {
    "body": [
      "std::vector<${1:int}> lis;",
      "for (auto crr : ${2:name}) {",
      "  auto lb = std::lower_bound(lis.begin(), lis.end(), crr);",
      "  if (lb == lis.end()) lis.push_back(crr);",
      "  else *lb = crr;",
      "}"
    ],
    "prefix": "lis"
  },
  "../snippets/algorithms/shakutori.hpp": {
    "body": [
      "/* init crr, ret */",
      "for (int l = 0, r = 0; l < n; l++) {",
      "  if (r <= l) {",
      "    r = l;",
      "    /* re-init crr */;",
      "  }",
      "  for (; r < n; r++) {",
      "    if (/* cannot push r */) break;",
      "    /* push r */;",
      "  }",
      "  ret += r - l;",
      "  /* pop l */",
      "}"
    ],
    "prefix": "shakutori"
  },
  "../snippets/code_fragments/all.hpp": {
    "body": [
      "${1:name}.begin(), $1.end()"
    ],
    "prefix": "all"
  },
  "../snippets/code_fragments/didj.hpp": {
    "body": [
      "int d${1:i}[4] = {-1, +1, 0, 0};",
      "int d${2:j}[4] = {0, 0, -1, +1};"
    ],
    "prefix": "didj"
  },
  "../snippets/code_fragments/err.hpp": {
    "body": [
      "void err() { std::cout << $1 << std::endl; exit(0); }",
      "#define require(exp) do { if (!(exp)) { err(); } } while(false)"
    ],
    "prefix": "err"
  },
  "../snippets/code_fragments/lambda.hpp": {
    "body": [
      "auto ${1:name} = [&] ($2)",
      "{",
      "  $0",
      "};"
    ],
    "prefix": "lambda"
  },
  "../snippets/debug/bug.hpp": {
    "body": [
      "/* ↓ 消し忘れないで！！！ ↓ */",
      "$0",
      "/* ↑ いや振りじゃないから ↑ */"
    ],
    "prefix": "bug"
  },
  "../snippets/debug/check.hpp": {
    "body": [
      "std::cout << \"/\" << ${1:crr} << std::endl;",
      "std::cout << \"\\\\\\\\\" << ${1:crr} << std::endl;"
    ],
    "prefix": "check"
  },
  "../snippets/debug/ndbg.hpp": {
    "body": [
      "std::cout << \"$0\" << std::endl;"
    ],
    "prefix": "ndbg"
  },
  "../snippets/debug/new_line.hpp": {
    "body": [
      "{ // debug",
      "  std::cout << std::endl;",
      "} //"
    ],
    "prefix": "new_line"
  },
  "../snippets/io/1sin.hpp": {
    "body": [
      "${1:int} $2; std::cin >> $2;"
    ],
    "prefix": "1sin"
  },
  "../snippets/io/2sin.hpp": {
    "body": [
      "${1:int} $2, $3; std::cin >> $2 >> $3;"
    ],
    "prefix": "2sin"
  },
  "../snippets/io/3sin.hpp": {
    "body": [
      "${1:int} $2, $3, $4;",
      "std::cin >> $2 >> $3 >> $4;"
    ],
    "prefix": "3sin"
  },
  "../snippets/io/4sin.hpp": {
    "body": [
      "${1:int} $2, $3, $4, $5;",
      "std::cin >> $2 >> $3 >> $4 >> $5;"
    ],
    "prefix": "4sin"
  },
  "../snippets/io/5sin.hpp": {
    "body": [
      "${1:int} $2, $3, $4, $5, $6;",
      "std::cin >> $2 >> $3 >> $4 >> $5 >> $6;"
    ],
    "prefix": "5sin"
  },
  "../snippets/io/sout.hpp": {
    "body": [
      "std::cout << $0 << std::endl;"
    ],
    "prefix": "sout"
  },
  "../snippets/io/tin.hpp": {
    "body": [
      "${1:int} ${2:tmp};",
      "std::cin >> $2;",
      "$0;"
    ],
    "prefix": "tin"
  }
}