{
	"all": {
		"prefix": "all",
		"body": [
			"${1:おなまえ}.begin(), $1.end()"
		],
		"description": "none"
	},
	"bug": {
		"prefix": "bug",
		"body": [
			"/* ↓ 消し忘れないで！！！ ↓ */",
			"$0 // お願い！！",
			"/* ↑ いや振りじゃないから ↑ */"
		],
		"description": "none"
	},
	"chmax": {
		"prefix": "chmax",
		"body": [
			"template<typename T1, typename T2>",
			"inline bool chmax (T1& a, T2 b) {",
			"\tif (a < b) {",
			"\t\ta = b;",
			"\t\treturn true;",
			"\t}",
			"\treturn false;",
			"}"
		],
		"description": "none"
	},
	"chmin": {
		"prefix": "chmin",
		"body": [
			"template<typename T1, typename T2>",
			"inline bool chmin (T1& a, T2 b) {",
			"\tif (a > b) {",
			"\t\ta = b;",
			"\t\treturn true;",
			"\t}",
			"\treturn false;",
			"}"
		],
		"description": "none"
	},
	"didj": {
		"prefix": "didj",
		"body": [
			"int d${1:i}[4] = {-1, +1, 0, 0};",
			"int d${2:j}[4] = {0, 0, -1, +1};"
		],
		"description": "none"
	},
	"fors": {
		"prefix": "fors",
		"body": [
			"for (int ${1:i} = ${2:0}; ${1:i} < ${3:n}; ${1:i}++) {",
			"\t$0",
			"}"
		],
		"description": "none"
	},
	"for const": {
		"prefix": "for const",
		"body": [
			"for (auto const & ${1:e}: ${2:おなまえ}) {",
			"\t$0",
			"}"
		],
		"description": "none"
	},
	"for iterator": {
		"prefix": "for iterator",
		"body": [
			"for (auto ${1:it} = ${2:おなまえ}.begin(); $1 != $2.end(); it++) {",
			"\t$0",
			"}"
		],
		"description": "none"
	},
	"for range": {
		"prefix": "for range",
		"body": [
			"for (auto const& ${1:e} : ${2:name}) {",
			"\t$0",
			"}"
		],
		"description": "none"
	},
	"for reverse": {
		"prefix": "for reverse",
		"body": [
			"for (int ${1:i} = ${2:n - 1}; $1 >= ${3:0}; $1--) {",
			"\t$0",
			"}"
		],
		"description": "none"
	},
	"lower bound": {
		"prefix": "lower bound",
		"body": [
			"lower_bound(${1:おなまえ}.begin(), ${1:おなまえ}.end(), ${2:きじゅんち});"
		],
		"description": "none"
	},
	"mdcal": {
		"prefix": "mdcal",
		"body": [
			"constexpr int md = ${1:1e9 + 7};",
			"inline void add(int &a, int b) {",
			"\ta += b;",
			"\tif (a >= md) a -= md;",
			"}",
			"inline void sub(int &a, int b) {",
			"\ta -= b;",
			"\tif (a < 0) a += md;",
			"}",
			"inline int mul(int a, int b) {",
			"\treturn (int)((long long)a * b % md);",
			"}",
			"inline int power(int a, long long b) {",
			"\tint res = 1;",
			"\twhile (b > 0) {",
			"\t\tif (b & 1) {",
			"\t\t\tres = mul(res, a);",
			"\t\t\tb--;",
			"\t\t}",
			"\t\ta = mul(a, a);",
			"\t\tb >>= 1;",
			"\t}",
			"\treturn res;",
			"}",
			"inline int inv(int a) {",
			"\ta %= md;",
			"\tif(a < 0) a += md;",
			"\tint b = md, u = 0, v = 1;",
			"\twhile (a) {",
			"\t\tint t = b / a;",
			"\t\tb -= a * t; swap(a, b);",
			"\t\tu -= v * t; swap(u, v);",
			"\t}",
			"\tassert(b == 1);",
			"\tif(u < 0) u += md;",
			"\treturn u;",
			"}"
		],
		"description": "none"
	},
	"pair": {
		"prefix": "pair",
		"body": [
			"pair<${1:int}, ${2:int}> ${3:おなまえ}(${4:0}, ${5:0})$0;"
		],
		"description": "none"
	},
	"reverse": {
		"prefix": "reverse",
		"body": [
			"reverse(${1:おなまえ}.begin(), ${1:おなまえ}.end());"
		],
		"description": "none"
	},
	"reverse priority queue": {
		"prefix": "reverse priority queue",
		"body": [
			"priority_queue<",
			"\t${1:pair<int, int>},",
			"\tvector<$1>,",
			"\tgreater<$1>",
			"> ${2:que};",
			"$2.emplace($0);"
		],
		"description": "none"
	},
	"sort": {
		"prefix": "sort",
		"body": [
			"sort(${1:おなまえ}.begin(), ${1:おなまえ}.end());"
		],
		"description": "none"
	},
	"sort reverse": {
		"prefix": "sort reverse",
		"body": [
			"sort(${1:おなまえ}.begin(), ${1:おなまえ}.end(), greater<${2:int}>());"
		],
		"description": "none"
	},
	"stemp": {
		"prefix": "stemp",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"int main() {",
			"\t$0",
			"\treturn 0;",
			"}"
		],
		"description": "none"
	},
	"upper": {
		"prefix": "upper",
		"body": [
			"upper(${1:おなまえ}.begin(), ${1:おなまえ}.end(), ${2:きじゅんち});"
		],
		"description": "none"
	},
	"vec": {
		"prefix": "vec",
		"body": [
			"vector<${1:int}> ${2:おなまえ}(${3:n}, ${4:0})$0;"
		],
		"description": "none"
	},
	"vecpair": {
		"prefix": "vecpair",
		"body": [
			"vector<pair<${1:int}, ${2:int}>> ${3:おなまえ}(${4:n}, {${5:0}, ${6:0}})$0;"
		],
		"description": "none"
	},
	"vecvec": {
		"prefix": "vecvec",
		"body": [
			"vector<vector<${1:int}>> ${2:おなまえ}(${3:h}, vector<$1>(${4:w}, ${5:0}))$0;"
		],
		"description": "none"
	},
	"vecvecpair": {
		"prefix": "vecvecpair",
		"body": [
			"vector<vector<pair<${1:int}, ${2:int}>>> ${3:おなまえ}(${4:h}, vector<pair<${1:int}, ${2:int}>>(${5:w}, {${6:0}, ${7:0}}))$0;"
		],
		"description": "none"
	},
	"binary indexed tree": {
		"prefix": "binary indexed tree",
		"body": [
			"template <typename T>",
			"class binary_indexed_tree {",
			"\tint sz;",
			"\tvector<T> tr;",
			"\tfunction<T(T, T)> o;",
			"\tfunction<T(T, T)> dif;",
			"\tT id;",
			"\tpublic:",
			"\t\tbinary_indexed_tree (",
			"\t\t\tint n",
			"\t\t, function<T(T, T) > o = [](int a, int b) {return a + b;}",
			"\t\t, function<T(T, T) > dif = [](int a, int b) {return a - b;}",
			"\t\t, T id = 0",
			"\t\t)",
			"\t\t: sz(n)",
			"\t\t, tr(n, id)",
			"\t\t, o(o)",
			"\t\t, dif(dif)",
			"\t\t, id(id)",
			"\t\t{",
			"\t\t}",
			"\t\tT query (int l, int r) {",
			"\t\t\tassert(0 <= l && l <= r && r <= sz);",
			"\t\t\tif (l == 0) {",
			"\t\t\t\tr--;",
			"\t\t\t\tT ret = 0;",
			"\t\t\t\tfor (; r >= 0; r &= r + 1, r--) ret = o(ret, tr[r]);",
			"\t\t\t\treturn ret;",
			"\t\t\t}",
			"\t\t\treturn dif(query(0, r), query(0, l));",
			"\t\t}",
			"\t\tvoid add (int i, T x) {",
			"\t\t\tfor (; i < sz; i |= i + 1) tr[i] = o(tr[i], x);",
			"\t\t}",
			"\t\tvoid print() {",
			"\t\t\tcout << \"bit: \";",
			"\t\t\tfor (int i = 0; i < sz; i++) {",
			"\t\t\t\tcout << query(i, i + 1);",
			"\t\t\t\tif (i == sz - 1) break;",
			"\t\t\t\tcout << ' ';",
			"\t\t\t}",
			"\t\t\tcout << endl;",
			"\t\t}",
			"};"
		],
		"description": "none"
	},
	"disjoint set": {
		"prefix": "disjoint set",
		"body": [
			"struct disjoint_set {",
			"\tint n;",
			"\tvector<int> prt;",
			"\tdisjoint_set (int n)",
			"\t\t: n(n)",
			"\t\t, prt(n, -1)",
			"\t{}",
			"\tbool is_root (int x) {return prt[x] < 0;}",
			"\tint size (int x) {return prt[find(x)];}",
			"\tbool equiv (int x, int y) {return find(x) == find(y);}",
			"\tint find (int x) {",
			"\t\tif (is_root(x)) return x;",
			"\t\telse return prt[x] = find(prt[x]);",
			"\t}",
			"\tbool unite (int x, int y) {",
			"\t\tx = find(x);",
			"\t\ty = find(y);",
			"\t\tif (x == y) return false;",
			"\t\tif (size(x) < size(y)) swap(x, y);",
			"\t\tprt[x] += prt[y];",
			"\t\tprt[y] = x;",
			"\t\treturn true;",
			"\t}",
			"};"
		],
		"description": "none"
	},
	"lazy segment tree": {
		"prefix": "lazy segment tree",
		"body": [
			"template<typename T, typename U>",
			"struct range_minimum_query {",
			"\tconst T id;",
			"\tconst function<T(T, T)> merge_function;",
			"\tconst function<void(U&)> twice;",
			"\tconst function<U(U)> half;",
			"\trange_minimum_query(T id):",
			"\t\tid(id),",
			"\t\tmerge_function ([](T a, T b) {return min(a, b);}),",
			"\t\ttwice ([](U& a) {}),",
			"\t\thalf ([](U a) {return a;})",
			"\t\t{",
			"\t\t}",
			"};",
			"template<typename T, typename U>",
			"struct range_maximum_query {",
			"\tconst T id;",
			"\tconst function<T(T, T)> merge_function;",
			"\tconst function<void(U&)> twice;",
			"\tconst function<U(U)> half;",
			"\trange_maximum_query(T id):",
			"\t\tid(id),",
			"\t\tmerge_function ([](T a, T b) {return max(a, b);}),",
			"\t\ttwice ([](U& a) {}),",
			"\t\thalf ([](U a) {return a;})",
			"\t\t{",
			"\t\t}",
			"};",
			"template<typename T, typename U>",
			"struct range_sum_query {",
			"\tconst T id;",
			"\tconst function<T(T, T)> merge_function;",
			"\tconst function<void(U&)> twice;",
			"\tconst function<U(U)> half;",
			"\trange_sum_query(T id = 0):",
			"\t\tid(id),",
			"\t\tmerge_function ([](T a, T b) {return a + b;}),",
			"\t\ttwice ([](U& a) {a *= 2;}),",
			"\t\thalf ([](U a) {return a / 2;})",
			"\t\t{",
			"\t\t}",
			"};",
			"template<typename T, typename U>",
			"struct range_update_query {",
			"\t\tconst U id;",
			"\t\tconst function<void(T&, U)> action;",
			"\t\tconst function<void(U&, U)> composition;",
			"\tpublic:",
			"\t\trange_update_query(U id = 0):",
			"\t\t\tid(id),",
			"\t\t\taction ([](T& a, U b) {a = b;}),",
			"\t\t\tcomposition ([](U& a, U b) {a = b;})",
			"\t\t\t{",
			"\t\t\t}",
			"};",
			"template<typename T, typename U>",
			"struct range_add_query {",
			"\t\tconst U id;",
			"\t\tconst function<void(T&, U)> action;",
			"\t\tconst function<void(U&, U)> composition;",
			"\tpublic:",
			"\t\trange_add_query(U id = 0):",
			"\t\t\tid(id),",
			"\t\t\taction ([](T& a, U b) {a += b;}),",
			"\t\t\tcomposition ([](U& a, U b) {a += b;})",
			"\t\t\t{",
			"\t\t\t}",
			"};",
			"template<typename T, typename U>",
			"class segment_tree {",
			"\tint sz;",
			"\tint Sz;",
			"\tint ht;",
			"\tvector<T> seg;",
			"\tvector<U> act;",
			"\tvector<bool> has_act;",
			"\tconst function<T(T, T)> o;",
			"\tconst function<void(T&, U)> oo;",
			"\tconst function<void(U&, U)> ooo;",
			"\tconst function<void(U&)> twice;",
			"\tconst function<U(U)> half;",
			"\tconst T tid;",
			"\tconst U uid;",
			"\t",
			"\tpublic:",
			"\t\tsegment_tree(",
			"\t\t\t\tint n,",
			"\t\t\t\tconst function<T(T, T)> merge_function,",
			"\t\t\t\tconst function<void(T&, U)> action,",
			"\t\t\t\tconst function<void(U&, U)> composition,",
			"\t\t\t\tconst function<void(U&)> twice,",
			"\t\t\t\tconst function<U(U)> half,",
			"\t\t\t\tconst T seg_id,",
			"\t\t\t\tconst U act_id",
			"\t\t\t)",
			"\t\t\t\t: o(merge_function)",
			"\t\t\t\t, oo(action)",
			"\t\t\t\t, ooo(composition)",
			"\t\t\t\t, twice(twice)",
			"\t\t\t\t, half(half)",
			"\t\t\t\t, tid(seg_id)",
			"\t\t\t\t, uid(act_id)",
			"\t\t\t{",
			"\t\t\t\tht = 1, sz = 1;",
			"\t\t\t\twhile(sz < n) ht++, sz <<= 1;",
			"\t\t\t\tSz = sz << 1;",
			"\t\t\t\tseg.assign(Sz, tid);",
			"\t\t\t\tact.resize(Sz, act_id);",
			"\t\t\t\thas_act.assign(Sz, false);",
			"\t\t\t}",
			"\t\t",
			"\t\tsegment_tree(",
			"\t\t\t\tconst vector<T>& data,",
			"\t\t\t\tconst function<T(T, T)> merge_function,",
			"\t\t\t\tconst function<void(T&, U)> action,",
			"\t\t\t\tconst function<void(U&, U)> composition,",
			"\t\t\t\tconst function<void(U&)> twice,",
			"\t\t\t\tconst function<U(U)> half,",
			"\t\t\t\tconst T seg_id,",
			"\t\t\t\tconst U act_id",
			"\t\t\t)",
			"\t\t\t\t: segment_tree(",
			"\t\t\t\t\t\tdata.size(),",
			"\t\t\t\t\t\tmerge_function,",
			"\t\t\t\t\t\taction,",
			"\t\t\t\t\t\tcomposition,",
			"\t\t\t\t\t\ttwice,",
			"\t\t\t\t\t\thalf,",
			"\t\t\t\t\t\tseg_id,",
			"\t\t\t\t\t\tact_id",
			"\t\t\t\t\t)",
			"\t\t\t{",
			"\t\t\t\tcopy(data.begin(), data.end(), seg.begin() + sz);",
			"\t\t\t\tfor (int i = sz - 1; i >= 1; i--) seg[i] = o(seg[i << 1], seg[(i << 1) + 1]);",
			"\t\t\t}",
			"\t\t",
			"\t\ttemplate<typename V, typename M, typename A>",
			"\t\tsegment_tree(",
			"\t\t\t\tconst V n_or_v,",
			"\t\t\t\tconst M& merge_instance,",
			"\t\t\t\tconst A& action_instance",
			"\t\t\t)",
			"\t\t\t\t: segment_tree(",
			"\t\t\t\t\tn_or_v,",
			"\t\t\t\t\tmerge_instance.merge_function,",
			"\t\t\t\t\taction_instance.action,",
			"\t\t\t\t\taction_instance.composition,",
			"\t\t\t\t\tmerge_instance.twice,",
			"\t\t\t\t\tmerge_instance.half,",
			"\t\t\t\t\tmerge_instance.id,",
			"\t\t\t\t\taction_instance.id",
			"\t\t\t\t)",
			"\t\t\t{",
			"\t\t\t}",
			"\t\t",
			"\t\tinline int lft (int i) {return i << 1;}",
			"\t\tinline int rgt (int i) {return (i << 1) + 1;}",
			"\t\tinline int upp (int i) {return i >> 1;}",
			"",
			"\t\tinline void propagate (",
			"\t\t\t\tint k,",
			"\t\t\t\tint L,",
			"\t\t\t\tint R",
			"\t\t\t)",
			"\t\t\t{",
			"\t\t\t\tif (has_act[k]) {",
			"\t\t\t\t\too(seg[k], act[k]);",
			"\t\t\t\t\tif (k < sz) {",
			"\t\t\t\t\t\tooo(act[lft(k)], half(act[k]));",
			"\t\t\t\t\t\tooo(act[rgt(k)], half(act[k]));",
			"\t\t\t\t\t\thas_act[lft(k)] = has_act[rgt(k)] = true;",
			"\t\t\t\t\t}",
			"\t\t\t\t\tact[k] = uid, has_act[k] = false;",
			"\t\t\t\t}",
			"\t\t\t}",
			"",
			"\t\tvoid update (",
			"\t\t\t\tint l,",
			"\t\t\t\tint r,",
			"\t\t\t\tT x,",
			"\t\t\t\tint k = 1,",
			"\t\t\t\tint L = 0,",
			"\t\t\t\tint R = -1",
			"\t\t\t)",
			"\t\t\t{",
			"\t\t\t\tif (R == -1) R = sz;",
			"\t\t\t\tif (k == 1) for (int i = 0; i < ht - 1; i++) twice(x);",
			"\t\t\t\tpropagate(k, L, R);",
			"\t\t\t\tif (R <= l || r <= L) return;",
			"\t\t\t\tif (l <= L && R <= r) {",
			"\t\t\t\t\tooo(act[k], x), has_act[k] = true;",
			"\t\t\t\t\tpropagate(k, L, R);",
			"\t\t\t\t} else {",
			"\t\t\t\t\tint C = (L + R) >> 1;",
			"\t\t\t\t\tupdate(l, r, half(x), lft(k), L, C);",
			"\t\t\t\t\tupdate(l, r, half(x), rgt(k), C, R);",
			"\t\t\t\t\tseg[k] = o(seg[lft(k)], seg[rgt(k)]);",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t",
			"\t\tT find (",
			"\t\t\t\tint l,",
			"\t\t\t\tint r,",
			"\t\t\t\tint k = 1,",
			"\t\t\t\tint L = 0,",
			"\t\t\t\tint R = -1",
			"\t\t\t)",
			"\t\t\t{",
			"\t\t\t\tif (R == -1) R = sz;",
			"\t\t\t\tpropagate(k, L, R);",
			"\t\t\t\tif (R <= l || r <= L) return tid;",
			"\t\t\t\tif (l <= L && R <= r) {",
			"\t\t\t\t\tpropagate(k, L, R);",
			"\t\t\t\t\treturn seg[k];",
			"\t\t\t\t} else {",
			"\t\t\t\t\tint C = (L + R) >> 1;",
			"\t\t\t\t\tT lv = find(l, r, lft(k), L, C);",
			"\t\t\t\t\tT rv = find(l, r, rgt(k), C, R);",
			"\t\t\t\t\tseg[k] = o(seg[lft(k)], seg[rgt(k)]);",
			"\t\t\t\t\treturn o(lv, rv);",
			"\t\t\t\t}",
			"\t\t\t}",
			"",
			"\t\tvoid print(int w = 4) {",
			"\t\t\tfor (int i(1), last(2), output_size(w << ht); last <= Sz; last <<= 1, output_size >>= 1) {",
			"\t\t\t\tfor (; i < last; i++) {",
			"\t\t\t\t\tcout << right << setw(w);",
			"\t\t\t\t\tcout << (seg[i] != tid ? to_string(seg[i]) : \"\");",
			"\t\t\t\t\tcout << setw(2) <<\t\"<\";",
			"\t\t\t\t\tcout << left << setw(output_size - w - 2);",
			"\t\t\t\t\tcout << (has_act[i] ? to_string(act[i]) : \"\");",
			"\t\t\t\t}",
			"\t\t\t\tcout << endl;",
			"\t\t\t}",
			"\t\t}",
			"};"
		],
		"description": "none"
	},
	"potential disjoint set": {
		"prefix": "potential disjoint set",
		"body": [
			"class potential_disjoint_set {",
			"\tpublic:",
			"\tvector<int> rank, prt, ptl;",
			"\tpotential_disjoint_set (int size) {",
			"\t\trank.resize(size);",
			"\t\tprt.resize(size);",
			"\t\tptl.resize(size);",
			"\t\tfor (int i = 0; i < size; i++) {",
			"\t\t\tprt[i] = i;",
			"\t\t\trank[i] = 0;",
			"\t\t\tptl[i] = 0;",
			"\t\t}",
			"\t}",
			"\tint find (int x) {",
			"\t\tif (x == prt[x]){",
			"\t\t\treturn x;",
			"\t\t} else {",
			"\t\t\tint r = find(prt[x]);",
			"\t\t\tptl[x] += ptl[prt[x]];",
			"\t\t\treturn prt[x] = r;",
			"\t\t}",
			"\t}",
			"\tbool is_equiv (int x, int y) {",
			"\t\treturn find(x) == find(y);",
			"\t}",
			"\tbool unite (int x, int y, int w) {",
			"\t\tif (find(x) == find(y)) {",
			"\t\t\treturn false;",
			"\t\t}",
			"\t\tw += ptl[x];",
			"\t\tw -= ptl[y];",
			"\t\tx = find(x);",
			"\t\ty = find(y);",
			"\t\tif (rank[x] < rank[y]) {",
			"\t\t\tswap(x, y);",
			"\t\t\tw *= -1;",
			"\t\t}",
			"\t\tprt[y] = x;",
			"\t\tptl[y] = w;",
			"\t\tif (rank[x] == rank[y]) {",
			"\t\t\trank[x]++;",
			"\t\t}",
			"\t\treturn true;",
			"\t}",
			"\tint diff (int x, int y) {",
			"\t\tfind(x);",
			"\t\tfind(y);",
			"\t\treturn ptl[y] - ptl[x];",
			"\t}",
			"};"
		],
		"description": "none"
	},
	"segment tree": {
		"prefix": "segment tree",
		"body": [
			"template< typename T >",
			"class segment_tree {",
			"\tint sz;",
			"\tvector<T> seg;",
			"\tconst function<T(T, T)> o;",
			"\tconst T id;",
			"\tpublic:",
			"\t\tsegment_tree(int n, const function<T(T, T)> o, const T id)",
			"\t\t\t: o(o)",
			"\t\t\t, id(id)",
			"\t\t{",
			"\t\t\tsz = 1;",
			"\t\t\twhile(sz < n) sz <<= 1;",
			"\t\t\tseg.assign(2 * sz, id);",
			"\t\t}",
			"\t\tvoid update(int k, const T &x) {",
			"\t\t\tk += sz;",
			"\t\t\tseg[k] = x;",
			"\t\t\twhile(k >>= 1) {",
			"\t\t\t\tseg[k] = o(seg[2 * k], seg[2 * k + 1]);",
			"\t\t\t}",
			"\t\t}",
			"\t\tT find(int l, int r) {",
			"\t\t\tT L = id, R = id;",
			"\t\t\tfor(l += sz, r += sz; l < r; l >>= 1, r >>= 1) {",
			"\t\t\t\tif(l & 1) L = o(L, seg[l++]);",
			"\t\t\t\tif(r & 1) R = o(seg[--r], R);",
			"\t\t\t}",
			"\t\t\treturn o(L, R);",
			"\t\t}",
			"\t\tT operator[](const int &k) const {",
			"\t\t\treturn seg[k + sz];",
			"\t\t}",
			"\t\tvoid print() {",
			"\t\t\tcout << \"segment_tree:\" << endl;",
			"\t\t\tint crr = 1;",
			"\t\t\tfor (int p = sz; p; p >>= 1) {",
			"\t\t\t\tfor (int i = 0; i < sz; i++) {",
			"\t\t\t\t\tcout",
			"\t\t\t\t\t\t\t<< setw(12)",
			"\t\t\t\t\t\t\t<< (i % p == 0 ? to_string(seg[crr++]) : \"\")",
			"\t\t\t\t\t\t\t<< (i < sz - 1 ? \"\" : \"\\n\");",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t\tcout << endl;",
			"\t\t}",
			"};"
		],
		"description": "none"
	},
	"sparse table": {
		"prefix": "sparse table",
		"body": [
			"template <typename T>",
			"class sparse_table {",
			"\tint sz, ht;",
			"\tvector<int> dpt;",
			"\tvector<vector<T>> dat;",
			"\tconst function<T(T, T)> o;",
			"\tconst T id;",
			"",
			"public:",
			"\tsparse_table (vector<T> v, function<T(T, T)> o, T id)",
			"\t\t: sz(v.size())",
			"\t\t, ht(1)",
			"\t\t, o(o)",
			"\t\t, id(id)",
			"\t{",
			"\t\twhile ((1 << ht) <= sz) ht++;",
			"\t\tdpt.assign(sz + 1, 0);",
			"\t\tdat.assign(ht, v);",
			"\t\tfor (int j = 2; j <= sz; j++) dpt[j] = dpt[j >> 1] + 1;",
			"\t\tfor (int i(1), p(1); i < ht; i++, p <<= 1) {",
			"\t\t\tfor (int j = 0; j < sz; j++) {",
			"\t\t\t\tdat[i][j] = o(dat[i - 1][j], dat[i - 1][min(j + p, sz - 1)]);",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"\tT find (int l, int r) {",
			"\t\tassert(0 <= l && l <= r && r <= sz);",
			"\t\tif(l == r) return id;",
			"\t\tint i = dpt[r - l];",
			"\t\treturn o(dat[i][l], dat[i][r - (1 << i)]);",
			"\t}",
			"\tvoid print () {",
			"\t\tfor (int i = 0; i < ht; i++) {",
			"\t\t\tfor (int j = 0; j < sz; j++) {",
			"\t\t\t\tcout << setw(4) << dat[i][j] << (j < sz - 1 ? ' ' : '\\n');",
			"\t\t\t}",
			"\t\t}",
			"\t\tcout << flush;",
			"\t}",
			"};"
		],
		"description": "none"
	},
	"-pdbg": {
		"prefix": "-pdbg",
		"body": [
			"cout << \"(\" << ${1:おなまえ}${2:.}first << \", \" <<\\t$1$2second << \")\";"
		],
		"description": "none"
	},
	"-ppdbg": {
		"prefix": "-ppdbg",
		"body": [
			"cout << \"(\" << get<0>(${1:*it}) << \", \" << get<1>($1) << \", \" << get<2>($1) << \")\";"
		],
		"description": "none"
	},
	"-sdbg": {
		"prefix": "-sdbg",
		"body": [
			"cout << ${1:おなまえ};"
		],
		"description": "none"
	},
	"1dbg": {
		"prefix": "1dbg",
		"body": [
			"{ // debug",
			"\tcout << \"${1:a} = \" << $1 << endl;",
			"} //"
		],
		"description": "none"
	},
	"1prompt": {
		"prefix": "1prompt",
		"body": [
			"cout << \"${2:a} > \";",
			"${1:int} $2;",
			"cin >> $2;"
		],
		"description": "none"
	},
	"2dbg": {
		"prefix": "2dbg",
		"body": [
			"{ // debug",
			"\tcout",
			"\t\t<< \"${1:a} = \" << $1 << \", \"",
			"\t\t<< \"${2:b} = \" << $2",
			"\t\t<< endl;",
			"} //"
		],
		"description": "none"
	},
	"2prpmpt": {
		"prefix": "2prpmpt",
		"body": [
			"cout << \"${2:a}, ${3:b} > \";",
			"${1:int} $2, $3;",
			"cin >> $2 >> $3;"
		],
		"description": "none"
	},
	"3dbg": {
		"prefix": "3dbg",
		"body": [
			"{ // debug",
			"\tcout",
			"\t\t<< \"${1:a} = \" << $1 << \", \"",
			"\t\t<< \"${2:b} = \" << $2 << \", \"",
			"\t\t<< \"${3:c} = \" << $3",
			"\t\t<< endl;",
			"} //"
		],
		"description": "none"
	},
	"3prompt": {
		"prefix": "3prompt",
		"body": [
			"cout << \"${2:a}, ${3:b}, ${4:c} > \";",
			"${1:int} $2, $3, $4;",
			"cin >> $2 >> $3 >> $4;"
		],
		"description": "none"
	},
	"check": {
		"prefix": "check",
		"body": [
			"printf(\"/%d\\n\", ${1:crr});",
			"printf(\"\\\\\\\\%d\\n\", ${1:crr});"
		],
		"description": "none"
	},
	"interval debug": {
		"prefix": "interval debug",
		"body": [
			"{ // debug",
			"\tcout",
			"\t\t<< \"[\" << $1 << \", \" << $2 << \",)\" << endl;",
			"} //"
		],
		"description": "none"
	},
	"map debug": {
		"prefix": "map debug",
		"body": [
			"{ // debug",
			"\tfor (auto ${2:it} = ${1:mp}.begin(); $2 != $1.end(); $2++) {",
			"\t\tcout << \"mp[\";",
			"\t\tcout << $0$2->first;",
			"\t\tcout << \"] = \";",
			"\t\tcout << $2->second;",
			"\t\tcout << \"\" << (next($2) == $1.end() ? \"\\n\" : \", \");",
			"\t}",
			"} //"
		],
		"description": "none"
	},
	"ndbg": {
		"prefix": "ndbg",
		"body": [
			"cout << \"$0\" << endl;"
		],
		"description": "none"
	},
	"new line": {
		"prefix": "new line",
		"body": [
			"{ // debug",
			"\tcout << endl;",
			"} //"
		],
		"description": "none"
	},
	"pdbg": {
		"prefix": "pdbg",
		"body": [
			"{ // debug",
			"\tcout << \"${1:おなまえ} = (\" << $1${2:.}first << \", \" <<\t$1$2second << \")\" << endl;",
			"} //"
		],
		"description": "none"
	},
	"vdbg": {
		"prefix": "vdbg",
		"body": [
			"{ // debug",
			"\tcout << \"${1:おなまえ}: \";",
			"\tfor (auto ${2:it} = $1.begin(); $2 != $1.end(); $2++) {",
			"\t\t${3:cout << *it;}",
			"\t\tcout << (next($2) == $1.end() ? \"\\n\" : \", \");",
			"\t}",
			"\tcout << endl;",
			"} //"
		],
		"description": "none"
	},
	"vpdebug": {
		"prefix": "vpdebug",
		"body": [
			"{ // debug",
			"\tcout << \"${1:おなまえ}: \";",
			"\tfor (auto $2 = $1.begin(); $2 != $1.end(); $2++) {",
			"\t\tcout << \"(\";",
			"\t\tcout << $2->first;",
			"\t\tcout << \", \";",
			"\t\tcout << $2->second;",
			"\t\tcout << \")\" << (next($2) == $1.end() ? \"\\n\" : \", \");",
			"\t}",
			"\tcout << endl;",
			"} //"
		],
		"description": "none"
	},
	"vvdbg": {
		"prefix": "vvdbg",
		"body": [
			"{ // debug",
			"\tcout << \"--------------------------------------\" << endl;",
			"\tcout << setw(${5:5}) << left << \"$1\";",
			"\tfor (int ${2:i} = 0; $2 < (int)${1:おなまえ}.size(); $2++) {",
			"\t\tif ($2 != 0) cout << setw($5) << \" \";",
			"\t\tcout << \"$2 = \" << setw(2) << right << $2 << \": \";",
			"\t\tfor (int ${3:j} = 0; $3 < (int)$1[$2].size(); $3++) {",
			"\t\t\tcout << setw(${4:4}) << right << $1[$2][$3];",
			"\t\t\tif ($3 != (int)$1[$2].size() - 1) cout << \" \";",
			"\t\t}",
			"\t\tcout << endl;",
			"\t}",
			"\tcout << \"--------------------------------------\" << endl;",
			"} //"
		],
		"description": "none"
	},
	"bellman ford": {
		"prefix": "bellman ford",
		"body": [
			"template<typename T>",
			"struct bellman_ford {",
			"\tusing edge_type = tuple<T, int, int>;",
			"\tconst int n;",
			"\tconst int r;",
			"\tconst vector<edge_type>& edg;",
			"\tconst T inf;",
			"\tbool flg;",
			"\tvector<long long> dst;",
			"\tbellman_ford (",
			"\t\t\tint n,",
			"\t\t\tint root,",
			"\t\t\tconst vector<edge_type>& edg,",
			"\t\t\tconst T inf",
			"\t\t) :",
			"\t\tn(n),",
			"\t\tr(root),",
			"\t\tedg(edg),",
			"\t\tinf(inf),",
			"\t\tflg(false),",
			"\t\tdst(n, inf)",
			"\t\t{",
			"\t\t\tdst[r] = 0;",
			"\t\t\tfor (int q = n; q--;) {",
			"\t\t\t\tflg = false;",
			"\t\t\t\tfor (auto const& e : edg) {",
			"\t\t\t\t\tT d; int s, t; tie(d, s, t) = e;",
			"\t\t\t\t\tif (dst[s] == inf) continue;",
			"\t\t\t\t\tif (chmin(dst[t], dst[s] + d)) flg = true;",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t}",
			"\tbool has_negative_cycle () const {return flg;}",
			"};"
		],
		"description": "none"
	},
	"depth": {
		"prefix": "depth",
		"body": [
			"class calculate_depths {",
			"\tconst int n, r;",
			"\tvector<int> dpt;",
			"\tconst vector<vector<int>> grh;",
			"",
			"\tvoid dfs (",
			"\t\t\tconst vector<vector<int>>& grh,",
			"\t\t\tvector<int>& dpt,",
			"\t\t\tint crr, int prt",
			"\t\t) {",
			"\t\t\tfor (int const& nxt : grh[crr]) {",
			"\t\t\t\tif (nxt == prt) continue;",
			"\t\t\t\tdpt[nxt] = dpt[crr] + 1;",
			"\t\t\t\tdfs(grh, dpt, nxt, crr);",
			"\t\t\t}",
			"\t\t}",
			"",
			"\tpublic:",
			"\t\tcalculate_depths (",
			"\t\t\t\tconst vector<vector<int>>& grh,",
			"\t\t\t\tconst int root",
			"\t\t\t) :",
			"\t\t\tn(grh.size()), r(root),",
			"\t\t\tdpt([&](){",
			"\t\t\t\t\tvector<int> ret(n, 0);",
			"\t\t\t\t\tdfs(grh, ret, r, r);",
			"\t\t\t\t\treturn ret;",
			"\t\t\t\t}()),",
			"\t\t\tgrh(grh)",
			"\t\t\t{",
			"\t\t\t}",
			"",
			"\t\tint depth (int x) const {return dpt[x];}",
			"};"
		],
		"description": "none"
	},
	"dfs1": {
		"prefix": "dfs1",
		"body": [
			"void ${1:dfs} (",
			"\tvector<vector<int>>& grh,",
			"\tint crr = ${2:0},",
			"\tint prt = ${2:0}",
			") {",
			"\tfor (int nxt : grh[crr]) if (nxt != prt) {",
			"\t\t$1(grh, nxt, crr);",
			"\t}",
			"}"
		],
		"description": "none"
	},
	"dfs2": {
		"prefix": "dfs2",
		"body": [
			"void ${1:dfs} (",
			"\tvector<vector<int>>& grh,",
			"\tvector<int>& ckd,",
			"\tint crr = ${2:0}",
			") {",
			"\tckd[crr] = true;",
			"\tfor (int nxt : grh[crr]) if (!ckd[nxt]) {",
			"\t\t$1(grh, ckd, crr);",
			"\t}",
			"}"
		],
		"description": "none"
	},
	"diameter": {
		"prefix": "diameter",
		"body": [
			"class calculate_diameter {",
			"\tconst int n;",
			"\tconst vector<vector<pair<T, int>>>& grh;",
			"\tint max_dpt;",
			"\tint far_0, far_1;",
			"",
			"\tvoid dfs (",
			"\t\tint crr",
			"\t, int prt",
			"\t, T dpt",
			"\t, int& far",
			"\t) {",
			"\t\tif (chmax(max_dpt, dpt)) far = crr;",
			"\t\tfor (auto const& e : grh[crr]) {",
			"\t\t\tT w; int nxt; tie(w, nxt) = e;",
			"\t\t\tif (nxt == prt) continue;",
			"\t\t\tdfs(nxt, crr, dpt + w, far);",
			"\t\t}",
			"\t}",
			"",
			"\tpublic:",
			"\t\tcalculate_diameter(",
			"\t\t\t\tvector<vector<pair<T, int>>>& grh",
			"\t\t\t) :",
			"\t\t\tn(grh.size()),",
			"\t\t\tgrh(grh),",
			"\t\t\tmax_dpt(0),",
			"\t\t\tfar_0(0), far_1(0)",
			"\t\t\t{",
			"\t\t\t\tdfs(0, 0, 0, far_0);",
			"\t\t\t\tdfs(far_0, far_0, 0, far_1);",
			"\t\t\t}",
			"",
			"\t\tT diameter () const {return max_dpt;}",
			"\t\tauto extremal () const -> pair<int, int> {return {min(far_0, far_1), max(far_0, far_1)};}",
			"};"
		],
		"description": "none"
	},
	"dijkstra": {
		"prefix": "dijkstra",
		"body": [
			"template <typename T>",
			"struct dijkstra {",
			"\tconst int n;",
			"\tconst int r;",
			"\tconst T inf;",
			"\tconst vector<vector<pair<T, int>>>& grh;",
			"\tvector<T> dst;",
			"\tdijkstra (",
			"\t\t\tconst vector<vector<pair<T, int>>>& grh,",
			"\t\t\tconst int root,",
			"\t\t\tconst T inf",
			"\t\t) :",
			"\t\tn(grh.size()),",
			"\t\tr(root),",
			"\t\tinf(inf),",
			"\t\tgrh(grh),",
			"\t\tdst(n, inf)",
			"\t\t{",
			"\t\t\tpriority_queue<",
			"\t\t\t\tpair<T, int>,",
			"\t\t\t\tvector<pair<T, int>>,",
			"\t\t\t\tgreater<pair<T, int>>",
			"\t\t\t> que;",
			"\t\t\tque.emplace(0, r);",
			"\t\t\twhile (!que.empty()) {",
			"\t\t\t\tT crd; int crr;",
			"\t\t\t\ttie(crd, crr) = que.top(), que.pop();",
			"\t\t\t\tif (!chmin(dst[crr], crd)) continue;",
			"\t\t\t\tfor (auto e : grh[crr]) {",
			"\t\t\t\t\tT w; int nxt; tie(w, nxt) = e;",
			"\t\t\t\t\tT nxd = crd + w;",
			"\t\t\t\t\tif (dst[nxt] > nxd) que.emplace(nxd, nxt);",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t}",
			"};"
		],
		"description": "none"
	},
	"floyd warshall": {
		"prefix": "floyd warshall",
		"body": [
			"template<typename T1, typename T2>",
			"inline bool chmin (T1& a, T2 b) {",
			"\tif (a > b) {",
			"\t\ta = b;",
			"\t\treturn true;",
			"\t}",
			"\treturn false;",
			"}",
			"template<typename T>",
			"struct floyd_warshall {",
			"\tconst int n;",
			"\tconst T inf;",
			"\tvector<vector<T>> dst;",
			"\tfloyd_warshall (",
			"\t\t\tvector<vector<T>> adj,",
			"\t\t\tconst T inf",
			"\t\t) :",
			"\t\tn(adj.size()),",
			"\t\tinf(inf),",
			"\t\tdst(adj)",
			"\t\t{",
			"\t\t\tfor (int k = 0; k < n; k++) {",
			"\t\t\t\tfor (int i = 0; i < n; i++) {",
			"\t\t\t\t\tfor (int j = 0; j < n; j++) {",
			"\t\t\t\t\t\tif (dst[i][k] != inf && dst[k][j] != inf)",
			"\t\t\t\t\t\t\tchmin(dst[i][j], dst[i][k] + dst[k][j]);",
			"\t\t\t\t\t}",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t}",
			"\tconst bool has_negative_cycle () {",
			"\t\tfor (int i = 0; i < n; i++) if (dst[i][i] < 0) return true;",
			"\t\treturn false;",
			"\t}",
			"};"
		],
		"description": "none"
	},
	"grid bfs": {
		"prefix": "grid bfs",
		"body": [
			"vector<vector<${1:long long}>> dst(h, vector<$1>(w, ${4:-1}));",
			"queue<pair<int, int>> que;",
			"dst[${2:si}][${3:sj}] = 0, que.emplace($2, $3);",
			"while (!que.empty()) {",
			"\tint cri, crj;",
			"\ttie(cri, crj) = que.front(), que.pop();",
			"\tfor (int k = 0; k < 4; k++) {",
			"\t\tint nxi = cri + di[k];",
			"\t\tint nxj = crj + dj[k];",
			"\t\tif (",
			"\t\t\t\t0 <= nxi && nxi < h &&",
			"\t\t\t\t0 <= nxj && nxj <= w &&",
			"\t\t\t\tdst[nxi][nxj] == $4 &&",
			"\t\t\t\t!grd[nxi][nxj]",
			"\t\t\t) dst[nxi][nxj] = dst[cri][crj] + 1, que.emplace(nxi, nxj);",
			"\t}",
			"}"
		],
		"description": "none"
	},
	"heights": {
		"prefix": "heights",
		"body": [
			"template<typename T>",
			"class calculate_heights {",
			"\tconst int n;",
			"\tconst vector<vector<pair<T, int>>>& grh;",
			"\tvector<T> dp, ep;",
			"",
			"\tvoid dfs (",
			"\t\t\tint crr = 0,",
			"\t\t\tint prt = 0",
			"\t\t) {",
			"\t\t\tfor (auto const& e : grh[crr]) {",
			"\t\t\t\tT w; int nxt; tie(w, nxt) = e;",
			"\t\t\t\tif (nxt == prt) continue;",
			"\t\t\t\tdfs(nxt, crr);",
			"\t\t\t\tchmax(dp[crr], dp[nxt] + w);",
			"\t\t\t}",
			"\t\t}",
			"",
			"\tvoid efs (",
			"\t\t\tint crr = 0,",
			"\t\t\tint prt = 0",
			"\t\t) {",
			"\t\t\tvector<T> cld = {ep[crr]};",
			"\t\t\tfor (auto const& e : grh[crr]) {",
			"\t\t\t\tT w; int nxt; tie(w, nxt) = e;",
			"\t\t\t\tif (nxt == prt) continue;",
			"\t\t\t\tcld.push_back(dp[nxt] + w);",
			"\t\t\t}",
			"\t\t\tsort(cld.begin(), cld.end(), greater<T>());",
			"\t\t\tfor (auto const& e : grh[crr]) {",
			"\t\t\t\tT w; int nxt; tie(w, nxt) = e;",
			"\t\t\t\tif (nxt == prt) continue;",
			"\t\t\t\tep[nxt] = dp[nxt] + w == cld[0] ?",
			"\t\t\t\t\t\tcld[1] + w : cld[0] + w;",
			"\t\t\t}",
			"\t\t\tfor (auto const& e : grh[crr]) {",
			"\t\t\t\tT w; int nxt; tie(w, nxt) = e;",
			"\t\t\t\tif (nxt == prt) continue;",
			"\t\t\t\tefs(nxt, crr);",
			"\t\t\t}",
			"\t\t\tchmax(dp[crr], ep[crr]);",
			"\t\t}",
			"",
			"\tpublic:",
			"\t\tcalculate_heights(",
			"\t\t\t\tvector<vector<pair<T, int>>>& grh",
			"\t\t\t) :",
			"\t\t\tn(grh.size()),",
			"\t\t\tgrh(grh),",
			"\t\t\tdp(n, 0),",
			"\t\t\tep(n, 0)",
			"\t\t\t{",
			"\t\t\t\tdfs();",
			"\t\t\t\tefs();",
			"\t\t\t}",
			"\t\t",
			"\t\tauto heights () const -> const vector<T>& {return dp;}",
			"\t\tauto height (int i) const -> const T {return dp[i];}",
			"};"
		],
		"description": "none"
	},
	"inner dfs1": {
		"prefix": "inner dfs1",
		"body": [
			"\tvoid dfs (",
			"\t\t\tint crr = 0,",
			"\t\t\tint prt = 0",
			"\t\t) {",
			"\t\t\tfor (int const& nxt : grh[crr]) {",
			"\t\t\t\t${2:T} w; int nxt; tie(w, nxt) = e;",
			"\t\t\t\tif (nxt == prt) continue;",
			"\t\t\t\tdfs(nxt, crr);",
			"\t\t\t\tchmax(dp[crr], dp[nxt] + w);",
			"\t\t\t}",
			"\t\t}"
		],
		"description": "none"
	},
	"kruskal": {
		"prefix": "kruskal",
		"body": [
			"template<typename T>",
			"struct kruskal {",
			"\tusing edge_type = tuple<T, int, int>;",
			"\tconst int n;",
			"\tvector<edge_type> edg;",
			"\tvector<edge_type> mst;",
			"\tT weight_of_mst;",
			"\tkruskal (",
			"\t\t\tint n,",
			"\t\t\tvector<edge_type> edg",
			"\t\t) :",
			"\t\tn(n),",
			"\t\tedg(edg),",
			"\t\tmst(n - 1),",
			"\t\tweight_of_mst(0)",
			"\t\t{",
			"\t\t\tsort(edg.begin(), edg.end());",
			"\t\t\tdisjoint_set djs(n);",
			"\t\t\tint cnt = 0;",
			"\t\t\tfor (auto e : edg) {",
			"\t\t\t\tT w; int s, t; tie(w, s, t) = e;",
			"\t\t\t\tif (djs.unite(s, t)) {",
			"\t\t\t\t\tweight_of_mst += w;",
			"\t\t\t\t\tmst[cnt] = {w, s, t};",
			"\t\t\t\t\tif (++cnt == n - 1) break;",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t\tif (cnt < n - 1) assert(false);",
			"\t\t}\t\t",
			"};"
		],
		"description": "none"
	},
	"least common ancestor": {
		"prefix": "least common ancestor",
		"body": [
			"class least_common_ancestor {",
			"\tconst int n, r;",
			"\tint ht;",
			"\tvector<int> dpt;",
			"\tvector<vector<int>> prt;",
			"\tconst vector<vector<int>> grh;",
			"",
			"\tvoid dfs (",
			"\t\t\tconst vector<vector<int>>& grh,",
			"\t\t\tvector<int>& dpt,",
			"\t\t\tint crr, int prt",
			"\t\t) {",
			"\t\t\tfor (int const& nxt : grh[crr]) {",
			"\t\t\t\tif (nxt == prt) continue;",
			"\t\t\t\tdpt[nxt] = dpt[crr] + 1;",
			"\t\t\t\tdfs(grh, dpt, nxt, crr);",
			"\t\t\t}",
			"\t\t}",
			"\t\tvoid climb (int& x, int b) const {",
			"\t\t\tfor (int i = 0; b; i++, b >>= 1) {",
			"\t\t\t\tif (b & 1) x = prt[i][x];",
			"\t\t\t}",
			"\t\t}",
			"",
			"\tpublic:",
			"\t\tleast_common_ancestor (",
			"\t\t\t\tconst vector<vector<int>>& grh,",
			"\t\t\t\tconst vector<int>& direct_prt,",
			"\t\t\t\tconst int root",
			"\t\t\t) :",
			"\t\t\tn(direct_prt.size()), r(root),",
			"\t\t\tht([&, i = 0]() mutable {",
			"\t\t\t\t\tfor (int p = 1; p < n; p <<= 1) i++;",
			"\t\t\t\t\treturn i;",
			"\t\t\t\t}()),",
			"\t\t\tdpt([&](){",
			"\t\t\t\t\tvector<int> ret(n, 0);",
			"\t\t\t\t\tdfs(grh, ret, r, r);",
			"\t\t\t\t\treturn ret;",
			"\t\t\t\t}()),",
			"\t\t\tprt([&](){",
			"\t\t\t\t\tvector<vector<int>> ret(ht, direct_prt);",
			"\t\t\t\t\tfor (int i = 1; i < ht; i++) {",
			"\t\t\t\t\t\tfor (int j = 0; j < n; j++) {",
			"\t\t\t\t\t\t\tprt[i][j] = prt[i - 1][prt[i - 1][j]];",
			"\t\t\t\t\t\t}",
			"\t\t\t\t\t}",
			"\t\t\t\t\treturn ret;",
			"\t\t\t\t}()),",
			"\t\t\tgrh(grh)",
			"\t\t\t{",
			"\t\t\t}",
			"",
			"\t\tint higher_prt (int x, int b) const {climb(x, b); return x;}",
			"\t\tint depth (int x) const {return dpt[x];}",
			"\t\tint lca (int x, int y) {",
			"\t\t\tif (dpt[x] < dpt[y]) climb(y, dpt[y] - dpt[x]);",
			"\t\t\telse if (dpt[y] < dpt[x]) climb(x, dpt[x] - dpt[y]);",
			"\t\t\tif (x == y) return x;",
			"\t\t\tfor (int i = ht - 1; i >= 0; i--) {",
			"\t\t\t\tif (prt[i][x] != prt[i][y]) {",
			"\t\t\t\t\tx = prt[i][x];",
			"\t\t\t\t\ty = prt[i][y];",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t\treturn prt[0][x];",
			"\t\t}",
			"};"
		],
		"description": "none"
	},
	"low link tree": {
		"prefix": "low link tree",
		"body": [
			"struct low_link_tree {",
			"\tconst int n;",
			"\tconst int r = 0;",
			"\tint tmr = 0;",
			"\tvector<int> ord;",
			"\tvector<int> low;",
			"\tset<int> art;",
			"\tset<pair<int, int>> bdg;",
			"\tvector<vector<int>> grh;",
			"public:",
			"\tlow_link_tree (",
			"\t\tvector<vector<int>> const& grh,",
			"\t\tconst int root",
			"\t)",
			"\t: n(grh.size())",
			"\t, r(root)",
			"\t, ord(n, -1)",
			"\t, low(n, -1)",
			"\t, grh(grh)",
			"\t{",
			"\t\tdfs(r, r);",
			"\t}",
			"\tvoid dfs (",
			"\t\tint crr",
			"\t,\tint prt",
			"\t) {",
			"\t\tint cnt = 0;",
			"\t\tord[crr] = low[crr] = tmr++;",
			"\t\tfor (int nxt : grh[crr]) {",
			"\t\t\tif (ord[nxt] == -1) {",
			"\t\t\t\tcnt++;",
			"\t\t\t\tdfs(nxt, crr);",
			"\t\t\t\tchmin(low[crr], low[nxt]);",
			"\t\t\t\tif (crr != r && ord[crr] <= low[nxt]) art.insert(crr);",
			"\t\t\t\tif (ord[crr] < low[nxt]) bdg.emplace(min(crr, nxt), max(crr, nxt));",
			"\t\t\t}",
			"\t\t\tif (nxt != prt) chmin(low[crr], ord[nxt]);",
			"\t\t}",
			"\t\tif (crr == r && cnt > 1) art.insert(crr);",
			"\t}",
			"};"
		],
		"description": "none"
	},
	"prim": {
		"prefix": "prim",
		"body": [
			"template <typename T>",
			"struct prim {",
			"\tconst int n;",
			"\tvector<vector<pair<T, int>>> grh;",
			"\tT weight_of_mst;",
			"\tprim (",
			"\t\t\tvector<vector<pair<T, int>>> grh",
			"\t\t) :",
			"\t\tn(grh.size()),",
			"\t\tgrh(grh),",
			"\t\tweight_of_mst(0)",
			"\t\t{",
			"\t\t\tvector<bool> ckd(n, false);",
			"\t\t\tpriority_queue<",
			"\t\t\t\tpair<T, int>,",
			"\t\t\t\tvector<pair<T, int>>,",
			"\t\t\t\tgreater<pair<T, int>>",
			"\t\t\t> que;",
			"\t\t\tque.emplace(0, 0);",
			"\t\t\twhile (!que.empty()) {",
			"\t\t\t\tT w; int t;",
			"\t\t\t\ttie(w, t) = que.top(), que.pop();",
			"\t\t\t\tif (ckd[t]) continue;",
			"\t\t\t\tweight_of_mst += w, ckd[t] = true;",
			"\t\t\t\tfor (auto p : grh[t]) que.push(p);",
			"\t\t\t}",
			"\t\t}",
			"};"
		],
		"description": "none"
	},
	"topological sort 1": {
		"prefix": "topological sort 1",
		"body": [
			"class topological_sort {",
			"\tconst int n;",
			"\tconst vector<vector<int>>& grh;",
			"\tvector<int> srd;",
			"\tvector<int> ckd;",
			"\tbool flg;",
			"",
			"\tbool dfs (int crr) {",
			"\t\tif (ckd[crr] == 1) return true;",
			"\t\tif (ckd[crr] == 2) return false;",
			"\t\tbool ret = false;",
			"\t\tckd[crr] = 1;",
			"\t\tfor (int nxt : grh[crr]) {",
			"\t\t\tret |= dfs(nxt);",
			"\t\t}",
			"\t\tckd[crr] = 2;",
			"\t\tsrd.insert(srd.begin(), crr);",
			"\t\treturn ret;",
			"\t}",
			"",
			"\tpublic:",
			"\t\ttopological_sort (",
			"\t\t\t\tconst vector<vector<int>>& grh",
			"\t\t\t) :",
			"\t\t\tn(grh.size()),",
			"\t\t\tgrh(grh),",
			"\t\t\tsrd(),",
			"\t\t\tckd(n, 0),",
			"\t\t\tflg(false)",
			"\t\t\t{",
			"\t\t\t\tfor (int i = 0; i < n; i++) {",
			"\t\t\t\t\tflg |= (ckd[i] == 0 && dfs(i));",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\tbool has_cycle () {return flg;}",
			"\t\tauto sorted() const -> const vector<int>& {return srd;} ",
			"};"
		],
		"description": "none"
	},
	"topological sort 2": {
		"prefix": "topological sort 2",
		"body": [
			"struct topological_sort {",
			"\tconst int n;",
			"\tconst vector<vector<int>>& grh;",
			"\tvector<int> sorted;",
			"\tvector<int> ckd;",
			"\tbool flg;",
			"\ttopological_sort (",
			"\t\t\tconst vector<vector<int>>& grh",
			"\t\t) :",
			"\t\tn(grh.size()),",
			"\t\tgrh(grh),",
			"\t\tsorted(),",
			"\t\tckd(n, 0),",
			"\t\tflg(false)",
			"\t\t{",
			"\t\t\tfor (int i = 0; i < n; i++) {",
			"\t\t\t\tflg |= (ckd[i] == 0 && dfs(i));",
			"\t\t\t}",
			"\t\t}",
			"\tbool dfs (int crr) {",
			"\t\tif (ckd[crr] == 1) return true;",
			"\t\tif (ckd[crr] == 2) return false;",
			"\t\tbool ret = false;",
			"\t\tckd[crr] = 1;",
			"\t\tfor (int nxt : grh[crr]) {",
			"\t\t\tret |= dfs(nxt);",
			"\t\t}",
			"\t\tckd[crr] = 2;",
			"\t\tsorted.insert(sorted.begin(), crr);",
			"\t\treturn ret;",
			"\t}",
			"\tbool has_cycle () {return flg;}",
			"};"
		],
		"description": "none"
	},
	"binary serch": {
		"prefix": "binary serch",
		"body": [
			"${1:int} ${2:ok}(${3:0}), ${4:ng}(${5:inf}), md;",
			"while (${4:ng} - ${2:ok} > 1) {",
			"\tmd = (${2:ok} + ${4:ng}) >> 1;",
			"\tif (${6:ck(md)}) ok = md;",
			"\telse ng = md;",
			"}"
		],
		"description": "none"
	},
	"lis": {
		"prefix": "lis",
		"body": [
			"vector<${1:int}> lis;",
			"for (auto crr : ${2:おなまえ}) {",
			"\tauto lb = lower_bound(lis.begin(), lis.end(), crr);",
			"\tif (lb == lis.end()) lis.push_back(crr);",
			"\telse *lb = crr;",
			"}"
		],
		"description": "none"
	},
	"shakutori": {
		"prefix": "shakutori",
		"body": [
			"int l(0), r(0);",
			"for (; l < ${1:n}; l++) {",
			"\twhile (r < n && ${2:/*[l, r + 1)が妥当*/}) {",
			"\t\tr++;",
			"\t\t${3:/*[l, r + 1)を訪問*/};",
			"\t}",
			"}"
		],
		"description": "none"
	},
	"factorials": {
		"prefix": "factorials",
		"body": [
			"struct factorials {",
			"\tconst int sz;",
			"\tvector<int> fct, fnv;",
			"\tfactorials (int n)",
			"\t\t: sz(n)",
			"\t\t, fct(n, 1)",
			"\t\t, fnv(n, 1)",
			"\t\t{",
			"\t\t\tfor (int i = 1; i < n; i++) fct[i] = mul(fct[i - 1], i);",
			"\t\t\tfnv[n - 1] = inv(fct[n - 1]);",
			"\t\t\tfor (int i = n - 1; i >= 1; i--) fnv[i - 1] = mul(fnv[i], i);",
			"\t\t}",
			"\tinline int binom (int n, int k) {",
			"\t\tassert(0 <= k && k <= n && n < sz);",
			"\t\treturn mul(fct[n], mul(fnv[k], fnv[n - k]));",
			"\t}",
			"};"
		],
		"description": "none"
	},
	"factorize": {
		"prefix": "factorize",
		"body": [
			"auto factorize (",
			"\tint x",
			") -> map<int, int>",
			"{",
			"\tmap<int, int> mp;",
			"\tfor (int p = 2; p * p <= x; p++) {",
			"\t\twhile (!(x % p)) {",
			"\t\t\tmp[p]++;",
			"\t\t\tx /= p;",
			"\t\t}",
			"\t}",
			"\tif (x != 1) mp[x] = 1;",
			"\treturn map;",
			"}"
		],
		"description": "none"
	},
	"gcd": {
		"prefix": "gcd",
		"body": [
			"template<typename T>",
			"T gcd (T a, T b) {",
			"\tif (a < 0) a = -a;",
			"\tif (b < 0) b = -b;",
			"\tif (a < b) swap(a, b);",
			"\twhile (b) {",
			"\t\ta %= b;",
			"\t\tswap(a, b);",
			"\t}",
			"\treturn a;",
			"}"
		],
		"description": "none"
	},
	"sieve of eratosthenes": {
		"prefix": "sieve of eratosthenes",
		"body": [
			"struct sieve_of_eratosthenes {",
			"\tvector<bool> is_prime;",
			"\tvector<int> prime_numbers;",
			"\tvector<vector<int>> prime_divisors;",
			"\tvector<vector<int>> divisors;",
			"\tsieve_of_eratosthenes(int n)",
			"\t\t: is_prime(vector<bool>(n))",
			"\t\t, prime_numbers(vector<int>(0))",
			"\t\t, prime_divisors(vector<vector<int>>(n))",
			"\t\t, divisors(vector<vector<int>>(n))",
			"\t{",
			"\t\tfor (int i = 1; i < n; i++) {",
			"\t\t\tif (is_prime[i] = divisors[i].size() == 1) prime_numbers.push_back(i);",
			"\t\t\tfor (int j = i; j < n; j += i) {",
			"\t\t\t\tdivisors[j].push_back(i);",
			"\t\t\t\tif (is_prime[i]) prime_divisors[j].push_back(i);",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"\tauto factorize (",
			"\t\tint x ",
			"\t) -> map<int, int> ",
			"\t{",
			"\t\tmap<int, int> mp;",
			"\t\tfor (int p : prime_numbers) {",
			"\t\t\twhile (!(x % p)) {",
			"\t\t\t\tmp[p]++;",
			"\t\t\t\tx /= p;",
			"\t\t\t}",
			"\t\t\tif (x == 1 || p * p > x) break;",
			"\t\t}",
			"\t\tif (x != 1) mp[x] = 1;",
			"\t\treturn mp;",
			"\t}",
			"};"
		],
		"description": "none"
	},
	"2sin": {
		"prefix": "2sin",
		"body": [
			"${1:int} $2, $3;",
			"cin >> $2 >> $3;"
		],
		"description": "none"
	},
	"3sin": {
		"prefix": "3sin",
		"body": [
			"${1:int} $2, $3, $4;",
			"cin >> $2 >> $3 >> $4;"
		],
		"description": "none"
	},
	"4sin": {
		"prefix": "4sin",
		"body": [
			"${1:sin} $2, $3, $4, $5;",
			"cin >> $2 >> $3 >> $4 >> $5;"
		],
		"description": "none"
	},
	"adjacency input": {
		"prefix": "adjacency input",
		"body": [
			"int ${1:n}, ${2:m};",
			"cin >> $1 >> $2;",
			"constexpr ${3:long long} inf = 1LL << 60;",
			"vector<vector<$3>> adj(n, vector<$3>(n, inf));",
			"for (int i = 0; i < $1; i++) adj[i][i] = 0;",
			"for (int i = 0; i < m; i++) {",
			"\t$3 d; int s, t;",
			"\tcin >> s >> t >> d;",
			"\tchmin(adj[s][t], d);",
			"}"
		],
		"description": "none"
	},
	"edge input": {
		"prefix": "edge input",
		"body": [
			"int ${1:n}, ${2:m};",
			"cin >> $1 >> $2;",
			"vector<tuple<${3:long long}, int, int>> edg($2);",
			"for (int i = 0; i < m; i++) {",
			"\t$3 d;",
			"\tint s, t;",
			"\tcin >> s >> t >> d;",
			"\tedg[i] = decltype(edg)::value_type(d, ${4:--}s, $4t);",
			"}"
		],
		"description": "none"
	},
	"err": {
		"prefix": "err",
		"body": [
			"void err() {",
			"\tcout << $0 << endl;",
			"\texit(0);",
			"}"
		],
		"description": "none"
	},
	"graph input": {
		"prefix": "graph input",
		"body": [
			"vector<vector<int>> grh(${1:n});",
			"for (int i = 0; i < ${2:m}; i++) {",
			"\tint s, t;",
			"\tcin >> s >> t;",
			"\tgrh[${3:--}s].push_back($3t);",
			"\tgrh[t].push_back(t);",
			"}"
		],
		"description": "none"
	},
	"graph pair input": {
		"prefix": "graph pair input",
		"body": [
			"vector<vector<pair<${3:long long}, int>>> grh(${1:n});",
			"for (int i = 0; i < ${2:m}; i++) {",
			"\tint s, t; $3 d;",
			"\tcin >> s >> t >> d;",
			"\tgrh[${4:--}s].emplace_back(d, $4t);",
			"\tgrh[t].emplace_back(s, t);",
			"}"
		],
		"description": "none"
	},
	"grid input": {
		"prefix": "grid input",
		"body": [
			"int ${1:h}, ${2:w}, ${3:si}, ${4:sj}, ${5:gi}, ${6:gj};",
			"cin >> $1 >> $2 >> $3 >> $4 >> $5 >> $6;",
			"$3--, $4--, $5--, $6--;",
			"vector<vector<int>> ${7:grd}($1, vector<int>($2));",
			"for (int i = 0; i < $1; i++) {",
			"\tfor (int j = 0; j < $2; j++) {",
			"\t\tchar c;",
			"\t\tcin >> c;",
			"\t\t$7[i][j] = c == '#';",
			"\t}",
			"}"
		],
		"description": "none"
	},
	"optional value": {
		"prefix": "optional value",
		"body": [
			"(${1:dst[i]} == ${2:inf} ? \"${3:INF}\" : to_string($1))"
		],
		"description": "none"
	},
	"sout": {
		"prefix": "sout",
		"body": [
			"cout << $0 << endl;"
		],
		"description": "none"
	},
	"space or newline": {
		"prefix": "space or newline",
		"body": [
			"(${1:i} == ${2:n - 1} ? \" \" : \"\\n\")"
		],
		"description": "none"
	},
	"ternary": {
		"prefix": "ternary",
		"body": [
			"($1 ? $2 : $3)"
		],
		"description": "none"
	},
	"tin": {
		"prefix": "tin",
		"body": [
			"${1:int} ${2:tmp};",
			"cin >> $2;",
			"$0;"
		],
		"description": "none"
	},
	"this_is_to_be_deleted": "foo"
}
