{
	"all": {
		"prefix": "all",
		"body": [
			"${1:おなまえ}.begin(), $1.end()"
		],
		"description": "none"
	},
	"cmn": {
		"prefix": "cmn",
		"body": [
			"template<typename T1, typename T2>",
			"inline bool cmn (T1& a, T2 b) {",
			"\tif (a > b) {",
			"\t\ta = b;",
			"\t\treturn true;",
			"\t}",
			"\treturn false;",
			"}"
		],
		"description": "none"
	},
	"cmx": {
		"prefix": "cmx",
		"body": [
			"template<typename T1, typename T2>",
			"inline bool cmx (T1& a, T2 b) {",
			"\tif (a < b) {",
			"\t\ta = b;",
			"\t\treturn true;",
			"\t}",
			"\treturn false;",
			"}"
		],
		"description": "none"
	},
	"didj": {
		"prefix": "didj",
		"body": [
			"int d${1:i}[4] = {-1, +1, 0, 0};",
			"int d${2:j}[4] = {0, 0, -1, +1};"
		],
		"description": "none"
	},
	"fixed point": {
		"prefix": "fixed point",
		"body": [
			"template<typename T>",
			"class fixed_point : T {",
			"\tpublic:",
			"\t\texplicit constexpr fixed_point (",
			"\t\t\t\tT&& t",
			"\t\t\t) noexcept",
			"\t\t\t: T(forward<T>(t))",
			"\t\t\t{",
			"\t\t\t}",
			"\t\ttemplate<typename... Args>",
			"\t\tconstexpr decltype(auto)",
			"\t\toperator()(",
			"\t\t\t\tArgs&&... args",
			"\t\t\t) const",
			"\t\t\t{",
			"\t\t\t\treturn T::operator()(*this, forward<Args>(args)...);",
			"\t\t\t}",
			"};",
			"template<typename T>",
			"static inline constexpr decltype(auto)",
			"\tmake_fixed_point (T&& t) noexcept {",
			"\t\treturn fixed_point<T>{forward<T>(t)};",
			"\t}"
		],
		"description": "none"
	},
	"fors": {
		"prefix": "fors",
		"body": [
			"for (int ${1:i} = ${2:0}; ${1:i} < ${3:n}; ${1:i}++) {",
			"\t$0",
			"}"
		],
		"description": "none"
	},
	"for const": {
		"prefix": "for const",
		"body": [
			"for (auto const & ${1:e}: ${2:おなまえ}) {",
			"\t$0",
			"}"
		],
		"description": "none"
	},
	"for iterator": {
		"prefix": "for iterator",
		"body": [
			"for (auto ${1:it} = ${2:おなまえ}.begin(); $1 != $2.end(); it++) {",
			"\t$0",
			"}"
		],
		"description": "none"
	},
	"for range": {
		"prefix": "for range",
		"body": [
			"for (auto const& ${1:e} : ${2:name}) {",
			"\t$0",
			"}"
		],
		"description": "none"
	},
	"for reverse": {
		"prefix": "for reverse",
		"body": [
			"for (int ${1:i} = ${2:n - 1}; $1 >= ${3:0}; $1--) {",
			"\t$0",
			"}"
		],
		"description": "none"
	},
	"inf": {
		"prefix": "inf",
		"body": [
			"constexpr int inf = 1 << 30;"
		],
		"description": "none"
	},
	"interval dp": {
		"prefix": "interval dp",
		"body": [
			"for (int d = 1; d <= ${1:n}; d++) {",
			"\tfor (int l = 0, r = d; r <= $1; l++, r++) {",
			"\t\t$0",
			"\t}",
			"}"
		],
		"description": "none"
	},
	"long inf": {
		"prefix": "long inf",
		"body": [
			"constexpr long long inf = 1LL << 60;"
		],
		"description": "none"
	},
	"lower bound": {
		"prefix": "lower bound",
		"body": [
			"lower_bound(${1:おなまえ}.begin(), ${1:おなまえ}.end(), ${2:きじゅんち});"
		],
		"description": "none"
	},
	"make fixed point": {
		"prefix": "make fixed point",
		"body": [
			"make_fixed_point ([&](auto dfs, int crr, int prt) -> void {",
			"\tfor (auto const& nxt : ctr[crr]) if (nxt != prt) {",
			"\t\tdfs(nxt, crr);",
			"\t}",
			"})(${1:0}, ${1:0});"
		],
		"description": "none"
	},
	"pair": {
		"prefix": "pair",
		"body": [
			"pair<${1:int}, ${2:int}> ${3:おなまえ}(${4:0}, ${5:0})$0;"
		],
		"description": "none"
	},
	"reverse": {
		"prefix": "reverse",
		"body": [
			"reverse(${1:おなまえ}.begin(), ${1:おなまえ}.end());"
		],
		"description": "none"
	},
	"reverse priority queue": {
		"prefix": "reverse priority queue",
		"body": [
			"priority_queue<",
			"\t${1:pair<int, int>},",
			"\tvector<$1>,",
			"\tgreater<$1>",
			"> ${2:que};",
			"$2.emplace($0);"
		],
		"description": "none"
	},
	"sort": {
		"prefix": "sort",
		"body": [
			"sort(${1:おなまえ}.begin(), ${1:おなまえ}.end());"
		],
		"description": "none"
	},
	"sort reverse": {
		"prefix": "sort reverse",
		"body": [
			"sort(${1:おなまえ}.begin(), ${1:おなまえ}.end(), greater<${2:int}>());"
		],
		"description": "none"
	},
	"stemp": {
		"prefix": "stemp",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"int main() {",
			"\tcin.tie(0); cin.sync_with_stdio(false);",
			"\t$0",
			"\treturn 0;",
			"}"
		],
		"description": "none"
	},
	"upper bound": {
		"prefix": "upper bound",
		"body": [
			"upper_bound(${1:おなまえ}.begin(), ${1:おなまえ}.end(), ${2:きじゅんち});"
		],
		"description": "none"
	},
	"vec": {
		"prefix": "vec",
		"body": [
			"vector<${1:int}> ${2:おなまえ}(${3:n}, ${4:0})$0;"
		],
		"description": "none"
	},
	"vecpair": {
		"prefix": "vecpair",
		"body": [
			"vector<pair<${1:int}, ${2:int}>> ${3:おなまえ}(${4:n}, {${5:0}, ${6:0}})$0;"
		],
		"description": "none"
	},
	"vecvec": {
		"prefix": "vecvec",
		"body": [
			"vector<vector<${1:int}>> ${2:おなまえ}(${3:h}, vector<$1>(${4:w}, ${5:0}))$0;"
		],
		"description": "none"
	},
	"vecvecpair": {
		"prefix": "vecvecpair",
		"body": [
			"vector<vector<pair<${1:int}, ${2:int}>>> ${3:おなまえ}(${4:h}, vector<pair<${1:int}, ${2:int}>>(${5:w}, {${6:0}, ${7:0}}))$0;"
		],
		"description": "none"
	},
	"binary indexed tree": {
		"prefix": "binary indexed tree",
		"body": [
			"template <typename T>",
			"class binary_indexed_tree {",
			"\tint sz;",
			"\tvector<T> tr;",
			"\tfunction<T(T, T)> o;",
			"\tfunction<T(T, T)> dif;",
			"\tT id;",
			"\tpublic:",
			"\t\tbinary_indexed_tree (",
			"\t\t\tint n",
			"\t\t, function<T(T, T) > o = [](int a, int b) {return a + b;}",
			"\t\t, function<T(T, T) > dif = [](int a, int b) {return a - b;}",
			"\t\t, T id = 0",
			"\t\t)",
			"\t\t: sz(n)",
			"\t\t, tr(n, id)",
			"\t\t, o(o)",
			"\t\t, dif(dif)",
			"\t\t, id(id)",
			"\t\t{",
			"\t\t}",
			"\t\tT query (int l, int r) {",
			"\t\t\tassert(0 <= l && l <= r && r <= sz);",
			"\t\t\tif (l == 0) {",
			"\t\t\t\tr--;",
			"\t\t\t\tT ret = 0;",
			"\t\t\t\tfor (; r >= 0; r &= r + 1, r--) ret = o(ret, tr[r]);",
			"\t\t\t\treturn ret;",
			"\t\t\t}",
			"\t\t\treturn dif(query(0, r), query(0, l));",
			"\t\t}",
			"\t\tvoid add (int i, T x) {",
			"\t\t\tfor (; i < sz; i |= i + 1) tr[i] = o(tr[i], x);",
			"\t\t}",
			"\t\tvoid print() {",
			"\t\t\tcout << \"bit: \";",
			"\t\t\tfor (int i = 0; i < sz; i++) {",
			"\t\t\t\tcout << query(i, i + 1);",
			"\t\t\t\tif (i == sz - 1) break;",
			"\t\t\t\tcout << ' ';",
			"\t\t\t}",
			"\t\t\tcout << endl;",
			"\t\t}",
			"};"
		],
		"description": "none"
	},
	"compressed segment tree": {
		"prefix": "compressed segment tree",
		"body": [
			"template<typename T, typename U>",
			"class compressed_segment_tree {",
			"\tconst vector<T> a;",
			"\tconst size_t sz, Sz;",
			"\tvector<U> seg;",
			"\tconst function<U(U, U)> o;",
			"\tconst U id;",
			"\tinline auto find (T k) const {",
			"\t\tauto it = lower_bound(a.begin(), a.end(), k);",
			"\t\tassert(it != a.end() && *it == k);",
			"\t\treturn it - a.begin() + sz;",
			"\t}",
			"\tpublic:",
			"\t\tcompressed_segment_tree (",
			"\t\t\t\tconst vector<T> a,",
			"\t\t\t\tconst function<U(U, U)> o,",
			"\t\t\t\tconst U id",
			"\t\t\t) :",
			"\t\t\ta(a),",
			"\t\t\tsz([&](){",
			"\t\t\t\t\tsize_t ret = 1;",
			"\t\t\t\t\tfor (; ret < a.size(); ret <<= 1) {}",
			"\t\t\t\t\treturn ret;",
			"\t\t\t\t}()),",
			"\t\t\tSz(sz << 1),",
			"\t\t\tseg(Sz, id),",
			"\t\t\to(o),",
			"\t\t\tid(id)",
			"\t\t\t{",
			"\t\t\t}",
			"\t\tvoid update (T x, const U& y) {",
			"\t\t\tauto k = find(x);",
			"\t\t\tseg[k] = y;",
			"\t\t\twhile(k >>= 1) {",
			"\t\t\t\tseg[k] = o(seg[2 * k], seg[2 * k + 1]);",
			"\t\t\t}",
			"\t\t}",
			"\t\tvoid add (T x, const U& y) {",
			"\t\t\tupdate(x, at(x) + y);",
			"\t\t}",
			"\t\tU query (T l, T r) {",
			"\t\t\tl = lower_bound(a.begin(), a.end(), l) - a.begin();",
			"\t\t\tr = lower_bound(a.begin(), a.end(), r) - a.begin();",
			"\t\t\tU L = id, R = id;",
			"\t\t\tfor(l += sz, r += sz; l < r; l >>= 1, r >>= 1) {",
			"\t\t\t\tif(l & 1) L = o(L, seg[l++]);",
			"\t\t\t\tif(r & 1) R = o(seg[--r], R);",
			"\t\t\t}",
			"\t\t\treturn o(L, R);",
			"\t\t}",
			"\t\tU at (T x) const {",
			"\t\t\treturn seg[find(x)];",
			"\t\t}",
			"\t\tvoid print () const {",
			"\t\t\tint n = a.size();",
			"\t\t\tcout << setw(4) << \"----\"; for (int i = 0; i < n; i++) cout << setw(4) << \"----\" ; cout << endl;",
			"\t\t\tcout << setw(4) << \"\"; for (auto const& e : a) cout << setw(4) << e; cout << endl;",
			"\t\t\tcout << setw(4) << \"----\"; for (int i = 0; i < n; i++) cout << setw(4) << \"----\" ; cout << endl;",
			"\t\t\tcout << setw(4) << \"val\"; for (auto const& e : a) cout << setw(4) << at(e); cout << endl;",
			"\t\t\tcout << setw(4) << \"----\"; for (int i = 0; i < n; i++) cout << setw(4) << \"----\" ; cout << endl;",
			"\t\t}",
			"};"
		],
		"description": "none"
	},
	"disjoint set": {
		"prefix": "disjoint set",
		"body": [
			"struct disjoint_set {",
			"\tint n;",
			"\tvector<int> prt;",
			"\tdisjoint_set (int n)",
			"\t\t: n(n)",
			"\t\t, prt(n, -1)",
			"\t{}",
			"\tbool is_root (int x) {return prt[x] < 0;}",
			"\tint size (int x) {return -prt[find(x)];}",
			"\tbool equiv (int x, int y) {return find(x) == find(y);}",
			"\tint find (int x) {",
			"\t\tif (is_root(x)) return x;",
			"\t\telse return prt[x] = find(prt[x]);",
			"\t}",
			"\tbool unite (int x, int y) {",
			"\t\tx = find(x);",
			"\t\ty = find(y);",
			"\t\tif (x == y) return false;",
			"\t\tif (size(x) < size(y)) swap(x, y);",
			"\t\tprt[x] += prt[y];",
			"\t\tprt[y] = x;",
			"\t\treturn true;",
			"\t}",
			"};"
		],
		"description": "none"
	},
	"disjoint sparse table": {
		"prefix": "disjoint sparse table",
		"body": [
			"template <typename T>",
			"class disjoint_sparse_table {",
			"\tconst int n, ht;",
			"\tconst vector<int> msb;",
			"\tconst function<T(T, T)> o;",
			"\tconst vector<vector<T>> tab;",
			"\tpublic:",
			"\t\tdisjoint_sparse_table (",
			"\t\t\t\tconst vector<T> a,",
			"\t\t\t\tconst function<T(T, T)> o",
			"\t\t\t) :",
			"\t\t\tn(a.size()),",
			"\t\t\tht([&](){",
			"\t\t\t\t\tint ret = 1;",
			"\t\t\t\t\tfor (int b = 2; b < n; b <<= 1) ret++;",
			"\t\t\t\t\treturn ret;",
			"\t\t\t\t}()),",
			"\t\t\tmsb([&](){",
			"\t\t\t\t\tint N = 1 << ht;",
			"\t\t\t\t\tauto ret = vector<int>(N, 0); ret[0] = -1;",
			"\t\t\t\t\tfor (int i = 2; i < N; i++) ret[i] = ret[i >> 1] + 1;",
			"\t\t\t\t\treturn ret;",
			"\t\t\t\t}()),",
			"\t\t\to(o),",
			"\t\t\ttab([&](){",
			"\t\t\t\t\tauto ret = vector<vector<T>>(ht, a);",
			"\t\t\t\t\tfor (int i = 1; i < ht; i++) {",
			"\t\t\t\t\t\tint p = 1 << i; int P = p << 1;",
			"\t\t\t\t\t\tfor (int s = 0; s < n; s += P) {",
			"\t\t\t\t\t\t\tint t = min(s + p, n);",
			"\t\t\t\t\t\t\tfor (int j = t - 2; j >= s; j--) ret[i][j] = o(a[j], ret[i][j + 1]);",
			"\t\t\t\t\t\t\tfor (int j = t + 1; j < min(s + P, n); j++) ret[i][j] = o(ret[i][j - 1], a[j]);",
			"\t\t\t\t\t\t}",
			"\t\t\t\t\t}",
			"\t\t\t\t\treturn ret;",
			"\t\t\t\t}())",
			"\t\t\t{",
			"\t\t\t}",
			"\t\tauto query (",
			"\t\t\t\tint l,",
			"\t\t\t\tint r",
			"\t\t\t) -> T",
			"\t\t\t{",
			"\t\t\t\tassert(l <= --r);",
			"\t\t\t\tint m = msb[l ^ r];",
			"\t\t\t\treturn m == -1 ? tab[0][l] : o(tab[m][l], tab[m][r]);",
			"\t\t\t}",
			"};"
		],
		"description": "none"
	},
	"lazy segment tree": {
		"prefix": "lazy segment tree",
		"body": [
			"template<typename T, typename U>",
			"struct range_minimum_query {",
			"\tconst T id;",
			"\tconst function<T(T, T)> merge_function;",
			"\tconst function<void(U&)> twice;",
			"\tconst function<U(U)> half;",
			"\trange_minimum_query(T id):",
			"\t\tid(id),",
			"\t\tmerge_function ([](T a, T b) {return min(a, b);}),",
			"\t\ttwice ([](U& a) {}),",
			"\t\thalf ([](U a) {return a;})",
			"\t\t{",
			"\t\t}",
			"};",
			"template<typename T, typename U>",
			"struct range_maximum_query {",
			"\tconst T id;",
			"\tconst function<T(T, T)> merge_function;",
			"\tconst function<void(U&)> twice;",
			"\tconst function<U(U)> half;",
			"\trange_maximum_query(T id):",
			"\t\tid(id),",
			"\t\tmerge_function ([](T a, T b) {return max(a, b);}),",
			"\t\ttwice ([](U& a) {}),",
			"\t\thalf ([](U a) {return a;})",
			"\t\t{",
			"\t\t}",
			"};",
			"template<typename T, typename U>",
			"struct range_sum_query {",
			"\tconst T id;",
			"\tconst function<T(T, T)> merge_function;",
			"\tconst function<void(U&)> twice;",
			"\tconst function<U(U)> half;",
			"\trange_sum_query(T id = 0):",
			"\t\tid(id),",
			"\t\tmerge_function ([](T a, T b) {return a + b;}),",
			"\t\ttwice ([](U& a) {a *= 2;}),",
			"\t\thalf ([](U a) {return a / 2;})",
			"\t\t{",
			"\t\t}",
			"};",
			"template<typename T, typename U>",
			"struct range_update_query {",
			"\t\tconst U id;",
			"\t\tconst function<void(T&, U)> action;",
			"\t\tconst function<void(U&, U)> composition;",
			"\tpublic:",
			"\t\trange_update_query(U id = 0):",
			"\t\t\tid(id),",
			"\t\t\taction ([](T& a, U b) {a = b;}),",
			"\t\t\tcomposition ([](U& a, U b) {a = b;})",
			"\t\t\t{",
			"\t\t\t}",
			"};",
			"template<typename T, typename U>",
			"struct range_add_query {",
			"\t\tconst U id;",
			"\t\tconst function<void(T&, U)> action;",
			"\t\tconst function<void(U&, U)> composition;",
			"\tpublic:",
			"\t\trange_add_query(U id = 0):",
			"\t\t\tid(id),",
			"\t\t\taction ([](T& a, U b) {a += b;}),",
			"\t\t\tcomposition ([](U& a, U b) {a += b;})",
			"\t\t\t{",
			"\t\t\t}",
			"};",
			"template<typename T, typename U>",
			"class segment_tree {",
			"\tint sz;",
			"\tint Sz;",
			"\tint ht;",
			"\tvector<T> seg;",
			"\tvector<U> act;",
			"\tvector<bool> has_act;",
			"\tconst function<T(T, T)> o;",
			"\tconst function<void(T&, U)> oo;",
			"\tconst function<void(U&, U)> ooo;",
			"\tconst function<void(U&)> twice;",
			"\tconst function<U(U)> half;",
			"\tconst T tid;",
			"\tconst U uid;",
			"\t",
			"\tpublic:",
			"\t\tsegment_tree(",
			"\t\t\t\tint n,",
			"\t\t\t\tconst function<T(T, T)> merge_function,",
			"\t\t\t\tconst function<void(T&, U)> action,",
			"\t\t\t\tconst function<void(U&, U)> composition,",
			"\t\t\t\tconst function<void(U&)> twice,",
			"\t\t\t\tconst function<U(U)> half,",
			"\t\t\t\tconst T seg_id,",
			"\t\t\t\tconst U act_id",
			"\t\t\t)",
			"\t\t\t\t: o(merge_function)",
			"\t\t\t\t, oo(action)",
			"\t\t\t\t, ooo(composition)",
			"\t\t\t\t, twice(twice)",
			"\t\t\t\t, half(half)",
			"\t\t\t\t, tid(seg_id)",
			"\t\t\t\t, uid(act_id)",
			"\t\t\t{",
			"\t\t\t\tht = 1, sz = 1;",
			"\t\t\t\twhile(sz < n) ht++, sz <<= 1;",
			"\t\t\t\tSz = sz << 1;",
			"\t\t\t\tseg.assign(Sz, tid);",
			"\t\t\t\tact.resize(Sz, act_id);",
			"\t\t\t\thas_act.assign(Sz, false);",
			"\t\t\t}",
			"\t\t",
			"\t\tsegment_tree(",
			"\t\t\t\tconst vector<T>& data,",
			"\t\t\t\tconst function<T(T, T)> merge_function,",
			"\t\t\t\tconst function<void(T&, U)> action,",
			"\t\t\t\tconst function<void(U&, U)> composition,",
			"\t\t\t\tconst function<void(U&)> twice,",
			"\t\t\t\tconst function<U(U)> half,",
			"\t\t\t\tconst T seg_id,",
			"\t\t\t\tconst U act_id",
			"\t\t\t)",
			"\t\t\t\t: segment_tree(",
			"\t\t\t\t\t\tdata.size(),",
			"\t\t\t\t\t\tmerge_function,",
			"\t\t\t\t\t\taction,",
			"\t\t\t\t\t\tcomposition,",
			"\t\t\t\t\t\ttwice,",
			"\t\t\t\t\t\thalf,",
			"\t\t\t\t\t\tseg_id,",
			"\t\t\t\t\t\tact_id",
			"\t\t\t\t\t)",
			"\t\t\t{",
			"\t\t\t\tcopy(data.begin(), data.end(), seg.begin() + sz);",
			"\t\t\t\tfor (int i = sz - 1; i >= 1; i--) seg[i] = o(seg[i << 1], seg[(i << 1) + 1]);",
			"\t\t\t}",
			"\t\t",
			"\t\ttemplate<typename V, typename M, typename A>",
			"\t\tsegment_tree(",
			"\t\t\t\tconst V n_or_v,",
			"\t\t\t\tconst M& merge_instance,",
			"\t\t\t\tconst A& action_instance",
			"\t\t\t)",
			"\t\t\t\t: segment_tree(",
			"\t\t\t\t\tn_or_v,",
			"\t\t\t\t\tmerge_instance.merge_function,",
			"\t\t\t\t\taction_instance.action,",
			"\t\t\t\t\taction_instance.composition,",
			"\t\t\t\t\tmerge_instance.twice,",
			"\t\t\t\t\tmerge_instance.half,",
			"\t\t\t\t\tmerge_instance.id,",
			"\t\t\t\t\taction_instance.id",
			"\t\t\t\t)",
			"\t\t\t{",
			"\t\t\t}",
			"\t\t",
			"\t\tinline int lft (int i) {return i << 1;}",
			"\t\tinline int rgt (int i) {return (i << 1) + 1;}",
			"\t\tinline int upp (int i) {return i >> 1;}",
			"",
			"\t\tinline void propagate (",
			"\t\t\t\tint k,",
			"\t\t\t\tint L,",
			"\t\t\t\tint R",
			"\t\t\t)",
			"\t\t\t{",
			"\t\t\t\tif (has_act[k]) {",
			"\t\t\t\t\too(seg[k], act[k]);",
			"\t\t\t\t\tif (k < sz) {",
			"\t\t\t\t\t\tooo(act[lft(k)], half(act[k]));",
			"\t\t\t\t\t\tooo(act[rgt(k)], half(act[k]));",
			"\t\t\t\t\t\thas_act[lft(k)] = has_act[rgt(k)] = true;",
			"\t\t\t\t\t}",
			"\t\t\t\t\tact[k] = uid, has_act[k] = false;",
			"\t\t\t\t}",
			"\t\t\t}",
			"",
			"\t\tvoid update (",
			"\t\t\t\tint l,",
			"\t\t\t\tint r,",
			"\t\t\t\tT x,",
			"\t\t\t\tint k = 1,",
			"\t\t\t\tint L = 0,",
			"\t\t\t\tint R = -1",
			"\t\t\t)",
			"\t\t\t{",
			"\t\t\t\tif (R == -1) R = sz;",
			"\t\t\t\tif (k == 1) for (int i = 0; i < ht - 1; i++) twice(x);",
			"\t\t\t\tpropagate(k, L, R);",
			"\t\t\t\tif (R <= l || r <= L) return;",
			"\t\t\t\tif (l <= L && R <= r) {",
			"\t\t\t\t\tooo(act[k], x), has_act[k] = true;",
			"\t\t\t\t\tpropagate(k, L, R);",
			"\t\t\t\t} else {",
			"\t\t\t\t\tint C = (L + R) >> 1;",
			"\t\t\t\t\tupdate(l, r, half(x), lft(k), L, C);",
			"\t\t\t\t\tupdate(l, r, half(x), rgt(k), C, R);",
			"\t\t\t\t\tseg[k] = o(seg[lft(k)], seg[rgt(k)]);",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t",
			"\t\tT find (",
			"\t\t\t\tint l,",
			"\t\t\t\tint r,",
			"\t\t\t\tint k = 1,",
			"\t\t\t\tint L = 0,",
			"\t\t\t\tint R = -1",
			"\t\t\t)",
			"\t\t\t{",
			"\t\t\t\tif (R == -1) R = sz;",
			"\t\t\t\tpropagate(k, L, R);",
			"\t\t\t\tif (R <= l || r <= L) return tid;",
			"\t\t\t\tif (l <= L && R <= r) {",
			"\t\t\t\t\tpropagate(k, L, R);",
			"\t\t\t\t\treturn seg[k];",
			"\t\t\t\t} else {",
			"\t\t\t\t\tint C = (L + R) >> 1;",
			"\t\t\t\t\tT lv = find(l, r, lft(k), L, C);",
			"\t\t\t\t\tT rv = find(l, r, rgt(k), C, R);",
			"\t\t\t\t\tseg[k] = o(seg[lft(k)], seg[rgt(k)]);",
			"\t\t\t\t\treturn o(lv, rv);",
			"\t\t\t\t}",
			"\t\t\t}",
			"",
			"\t\tvoid print(int w = 4) {",
			"\t\t\tfor (int i(1), last(2), output_size(w << ht); last <= Sz; last <<= 1, output_size >>= 1) {",
			"\t\t\t\tfor (; i < last; i++) {",
			"\t\t\t\t\tcout << right << setw(w);",
			"\t\t\t\t\tcout << (seg[i] != tid ? to_string(seg[i]) : \"\");",
			"\t\t\t\t\tcout << setw(2) <<\t\"<\";",
			"\t\t\t\t\tcout << left << setw(output_size - w - 2);",
			"\t\t\t\t\tcout << (has_act[i] ? to_string(act[i]) : \"\");",
			"\t\t\t\t}",
			"\t\t\t\tcout << endl;",
			"\t\t\t}",
			"\t\t}",
			"};"
		],
		"description": "none"
	},
	"potential disjoint set": {
		"prefix": "potential disjoint set",
		"body": [
			"class potential_disjoint_set {",
			"\tpublic:",
			"\tvector<int> rank, prt, ptl;",
			"\tpotential_disjoint_set (int size) {",
			"\t\trank.resize(size);",
			"\t\tprt.resize(size);",
			"\t\tptl.resize(size);",
			"\t\tfor (int i = 0; i < size; i++) {",
			"\t\t\tprt[i] = i;",
			"\t\t\trank[i] = 0;",
			"\t\t\tptl[i] = 0;",
			"\t\t}",
			"\t}",
			"\tint find (int x) {",
			"\t\tif (x == prt[x]){",
			"\t\t\treturn x;",
			"\t\t} else {",
			"\t\t\tint r = find(prt[x]);",
			"\t\t\tptl[x] += ptl[prt[x]];",
			"\t\t\treturn prt[x] = r;",
			"\t\t}",
			"\t}",
			"\tbool is_equiv (int x, int y) {",
			"\t\treturn find(x) == find(y);",
			"\t}",
			"\tbool unite (int x, int y, int w) {",
			"\t\tif (find(x) == find(y)) {",
			"\t\t\treturn false;",
			"\t\t}",
			"\t\tw += ptl[x];",
			"\t\tw -= ptl[y];",
			"\t\tx = find(x);",
			"\t\ty = find(y);",
			"\t\tif (rank[x] < rank[y]) {",
			"\t\t\tswap(x, y);",
			"\t\t\tw *= -1;",
			"\t\t}",
			"\t\tprt[y] = x;",
			"\t\tptl[y] = w;",
			"\t\tif (rank[x] == rank[y]) {",
			"\t\t\trank[x]++;",
			"\t\t}",
			"\t\treturn true;",
			"\t}",
			"\tint diff (int x, int y) {",
			"\t\tfind(x);",
			"\t\tfind(y);",
			"\t\treturn ptl[y] - ptl[x];",
			"\t}",
			"};"
		],
		"description": "none"
	},
	"segment tree": {
		"prefix": "segment tree",
		"body": [
			"template<typename T>",
			"class segment_tree {",
			"\tconst size_t n, sz, Sz;",
			"\tvector<T> seg;",
			"\tconst function<T(T, T)> o;",
			"\tconst T id;",
			"\tpublic:",
			"\t\tsegment_tree (",
			"\t\t\t\tconst size_t n,",
			"\t\t\t\tconst function<T(T, T)> o,",
			"\t\t\t\tconst T id",
			"\t\t\t) :",
			"\t\t\tn(n),",
			"\t\t\tsz([&](){",
			"\t\t\t\t\tsize_t p = 1;",
			"\t\t\t\t\tfor (; p < n; p <<= 1) {}",
			"\t\t\t\t\treturn p;",
			"\t\t\t\t}()),",
			"\t\t\tSz(sz << 1),",
			"\t\t\tseg(Sz, id),",
			"\t\t\to(o),",
			"\t\t\tid(id)",
			"\t\t\t{",
			"\t\t\t}",
			"\t\tvoid update (size_t k, const T& x) {",
			"\t\t\tk += sz;",
			"\t\t\tseg[k] = x;",
			"\t\t\twhile(k >>= 1) {",
			"\t\t\t\tseg[k] = o(seg[2 * k], seg[2 * k + 1]);",
			"\t\t\t}",
			"\t\t}",
			"\t\tvoid add (size_t x, const T& y) {",
			"\t\t\tupdate(x, at(x) + y);",
			"\t\t}",
			"\t\tT query (size_t l, size_t r) {",
			"\t\t\tT L = id, R = id;",
			"\t\t\tfor(l += sz, r += sz; l < r; l >>= 1, r >>= 1) {",
			"\t\t\t\tif(l & 1) L = o(L, seg[l++]);",
			"\t\t\t\tif(r & 1) R = o(seg[--r], R);",
			"\t\t\t}",
			"\t\t\treturn o(L, R);",
			"\t\t}",
			"\t\tT at (const size_t &x) const {",
			"\t\t\treturn seg[x + sz];",
			"\t\t}",
			"\t\tvoid print() {",
			"\t\t\tcout << setw(4) << \"----\"; for (int i = 0; i < n; i++) cout << setw(4) << \"----\" ; cout << endl;",
			"\t\t\tcout << setw(4) << \"\"; for (int i = 0; i < n; i++) cout << setw(4) << i; cout << endl;",
			"\t\t\tcout << setw(4) << \"----\"; for (int i = 0; i < n; i++) cout << setw(4) << \"----\" ; cout << endl;",
			"\t\t\tcout << setw(4) << \"val\"; for (int i = 0; i < n; i++) cout << setw(4) << seg[i + sz]; cout << endl;",
			"\t\t\tcout << setw(4) << \"----\"; for (int i = 0; i < n; i++) cout << setw(4) << \"----\" ; cout << endl;",
			"\t\t}",
			"};"
		],
		"description": "none"
	},
	"sparse table": {
		"prefix": "sparse table",
		"body": [
			"template <typename T>",
			"class sparse_table {",
			"\tconst int n, ht;",
			"\tconst vector<int> msb;",
			"\tconst function<T(T, T)> o;",
			"\tconst vector<vector<T>> tab;",
			"\tpublic:",
			"\t\tsparse_table (",
			"\t\t\t\tvector<T> a,",
			"\t\t\t\tfunction<T(T, T)> o",
			"\t\t\t) :",
			"\t\t\tn(a.size()),",
			"\t\t\tht([&](){",
			"\t\t\t\t\tint ret = 1;",
			"\t\t\t\t\tfor (int b = 2; b < n; b <<= 1) ret++;",
			"\t\t\t\t\treturn ret;",
			"\t\t\t\t}()),",
			"\t\t\tmsb([&](){",
			"\t\t\t\t\tint N = 1 << ht;",
			"\t\t\t\t\tauto ret = vector<int>(N, 0); ret[0] = -1;",
			"\t\t\t\t\tfor (int i = 2; i < N; i++) ret[i] = ret[i >> 1] + 1;",
			"\t\t\t\t\treturn ret;",
			"\t\t\t\t}()),",
			"\t\t\to(o),",
			"\t\t\ttab([&](){",
			"\t\t\t\t\tauto ret = vector<vector<T>>(ht, a);",
			"\t\t\t\t\tfor (int i = 1, p = 1; i < ht; i++, p <<= 1) {",
			"\t\t\t\t\t\tfor (int j = 0; j < n; j++) {",
			"\t\t\t\t\t\t\tret[i][j] = o(ret[i - 1][j], ret[i - 1][min(j + p, n - 1)]);",
			"\t\t\t\t\t\t}",
			"\t\t\t\t\t}",
			"\t\t\t\t\treturn ret;",
			"\t\t\t\t}())",
			"\t\t\t{",
			"\t\t\t}",
			"\t\tauto query (",
			"\t\t\t\tint l,",
			"\t\t\t\tint r",
			"\t\t\t) -> T",
			"\t\t\t{",
			"\t\t\t\tassert(0 <= l && l < r && r <= n);",
			"\t\t\t\tint i = msb[r - l];",
			"\t\t\t\treturn o(tab[i][l], tab[i][r - (1 << i)]);",
			"\t\t\t}",
			"};"
		],
		"description": "none"
	},
	"-pdbg": {
		"prefix": "-pdbg",
		"body": [
			"cout << \"(\" << ${1:おなまえ}${2:->}first << \", \" << $1$2second << \")\";"
		],
		"description": "none"
	},
	"-ppdbg": {
		"prefix": "-ppdbg",
		"body": [
			"cout << \"(\" << get<0>(${1:*it}) << \", \" << get<1>($1) << \", \" << get<2>($1) << \")\";"
		],
		"description": "none"
	},
	"-sdbg": {
		"prefix": "-sdbg",
		"body": [
			"cout << ${1:おなまえ};"
		],
		"description": "none"
	},
	"1dbg": {
		"prefix": "1dbg",
		"body": [
			"{ // debug",
			"\tcout << \"${1:a} = \" << $1 << endl;",
			"} //"
		],
		"description": "none"
	},
	"1prompt": {
		"prefix": "1prompt",
		"body": [
			"cout << \"${2:a} > \";",
			"${1:int} $2;",
			"cin >> $2;"
		],
		"description": "none"
	},
	"1vdebug": {
		"prefix": "1vdebug",
		"body": [
			"{ // debug",
			"\tint n = 0;",
			"\tif (n < (int)${1:name}.size()) n = $1.size();",
			"\tcout << setw(4) << \"----\"; for (int i = 0; i < n; i++) cout << setw(4) << \"----\" ; cout << endl;",
			"\tcout << setw(4) << \"\"; for (int i = 0; i < n; i++) cout << setw(4) << i; cout << endl;",
			"\tcout << setw(4) << \"----\"; for (int i = 0; i < n; i++) cout << setw(4) << \"----\" ; cout << endl;",
			"\tcout << setw(4) << \"$1\"; for (auto const& e : $1) cout << setw(4) << e; cout << endl;",
			"\tcout << setw(4) << \"----\"; for (int i = 0; i < n; i++) cout << setw(4) << \"----\" ; cout << endl;",
			"} //"
		],
		"description": "none"
	},
	"2dbg": {
		"prefix": "2dbg",
		"body": [
			"{ // debug",
			"\tcout",
			"\t\t<< \"${1:a} = \" << $1 << \", \"",
			"\t\t<< \"${2:b} = \" << $2",
			"\t\t<< endl;",
			"} //"
		],
		"description": "none"
	},
	"2prpmpt": {
		"prefix": "2prpmpt",
		"body": [
			"cout << \"${2:a}, ${3:b} > \";",
			"${1:int} $2, $3;",
			"cin >> $2 >> $3;"
		],
		"description": "none"
	},
	"2vdebug": {
		"prefix": "2vdebug",
		"body": [
			"{ // debug",
			"\tint n = 0;",
			"\tif (n < (int)${1:name}.size()) n = $1.size();",
			"\tif (n < (int)${2:name}.size()) n = $2.size();",
			"\tcout << setw(4) << \"----\"; for (int i = 0; i < n; i++) cout << setw(4) << \"----\" ; cout << endl;",
			"\tcout << setw(4) << \"\"; for (int i = 0; i < n; i++) cout << setw(4) << i; cout << endl;",
			"\tcout << setw(4) << \"----\"; for (int i = 0; i < n; i++) cout << setw(4) << \"----\" ; cout << endl;",
			"\tcout << setw(4) << \"$1\"; for (auto const& e : $1) cout << setw(4) << e; cout << endl;",
			"\tcout << setw(4) << \"$2\"; for (auto const& e : $2) cout << setw(4) << e; cout << endl;",
			"\tcout << setw(4) << \"----\"; for (int i = 0; i < n; i++) cout << setw(4) << \"----\" ; cout << endl;",
			"} //"
		],
		"description": "none"
	},
	"3dbg": {
		"prefix": "3dbg",
		"body": [
			"{ // debug",
			"\tcout",
			"\t\t<< \"${1:a} = \" << $1 << \", \"",
			"\t\t<< \"${2:b} = \" << $2 << \", \"",
			"\t\t<< \"${3:c} = \" << $3",
			"\t\t<< endl;",
			"} //"
		],
		"description": "none"
	},
	"3prompt": {
		"prefix": "3prompt",
		"body": [
			"cout << \"${2:a}, ${3:b}, ${4:c} > \";",
			"${1:int} $2, $3, $4;",
			"cin >> $2 >> $3 >> $4;"
		],
		"description": "none"
	},
	"3vdebug": {
		"prefix": "3vdebug",
		"body": [
			"{ // debug",
			"\tint n = 0;",
			"\tif (n < (int)${1:name}.size()) n = $1.size();",
			"\tif (n < (int)${2:name}.size()) n = $2.size();",
			"\tif (n < (int)${3:name}.size()) n = $3.size();",
			"\tcout << setw(4) << \"----\"; for (int i = 0; i < n; i++) cout << setw(4) << \"----\" ; cout << endl;",
			"\tcout << setw(4) << \"\"; for (int i = 0; i < n; i++) cout << setw(4) << i; cout << endl;",
			"\tcout << setw(4) << \"----\"; for (int i = 0; i < n; i++) cout << setw(4) << \"----\" ; cout << endl;",
			"\tcout << setw(4) << \"$1\"; for (auto const& e : $1) cout << setw(4) << e; cout << endl;",
			"\tcout << setw(4) << \"$2\"; for (auto const& e : $2) cout << setw(4) << e; cout << endl;",
			"\tcout << setw(4) << \"$3\"; for (auto const& e : $3) cout << setw(4) << e; cout << endl;",
			"\tcout << setw(4) << \"----\"; for (int i = 0; i < n; i++) cout << setw(4) << \"----\" ; cout << endl;",
			"} //"
		],
		"description": "none"
	},
	"4dbg": {
		"prefix": "4dbg",
		"body": [
			"{ // debug",
			"\tcout",
			"\t\t<< \"${1:a} = \" << $1 << \", \"",
			"\t\t<< \"${2:b} = \" << $2 << \", \"",
			"\t\t<< \"${3:c} = \" << $3 << \", \"",
			"\t\t<< \"${4:d} = \" << $4",
			"\t\t<< endl;",
			"} //"
		],
		"description": "none"
	},
	"4vdebug": {
		"prefix": "4vdebug",
		"body": [
			"{ // debug",
			"\tint n = 0;",
			"\tif (n < (int)${1:name}.size()) n = $1.size();",
			"\tif (n < (int)${2:name}.size()) n = $2.size();",
			"\tif (n < (int)${3:name}.size()) n = $3.size();",
			"\tcout << setw(4) << \"----\"; for (int i = 0; i < n; i++) cout << setw(4) << \"----\" ; cout << endl;",
			"\tcout << setw(4) << \"\"; for (int i = 0; i < n; i++) cout << setw(4) << i; cout << endl;",
			"\tcout << setw(4) << \"----\"; for (int i = 0; i < n; i++) cout << setw(4) << \"----\" ; cout << endl;",
			"\tcout << setw(4) << \"$1\"; for (auto const& e : $1) cout << setw(4) << e; cout << endl;",
			"\tcout << setw(4) << \"$2\"; for (auto const& e : $2) cout << setw(4) << e; cout << endl;",
			"\tcout << setw(4) << \"$3\"; for (auto const& e : $3) cout << setw(4) << e; cout << endl;",
			"\tcout << setw(4) << \"$4\"; for (auto const& e : $4) cout << setw(4) << e; cout << endl;",
			"\tcout << setw(4) << \"----\"; for (int i = 0; i < n; i++) cout << setw(4) << \"----\" ; cout << endl;",
			"} //"
		],
		"description": "none"
	},
	"bug": {
		"prefix": "bug",
		"body": [
			"/* ↓ 消し忘れないで！！！ ↓ */",
			"$0",
			"/* ↑ いや振りじゃないから ↑ */"
		],
		"description": "none"
	},
	"check": {
		"prefix": "check",
		"body": [
			"printf(\"/%d\\n\", ${1:crr});",
			"printf(\"\\\\\\\\%d\\n\", ${1:crr});"
		],
		"description": "none"
	},
	"interval debug": {
		"prefix": "interval debug",
		"body": [
			"{ // debug",
			"\tcout",
			"\t\t<< \"[\" << $1 << \", \" << $2 << \")\" << endl;",
			"} //"
		],
		"description": "none"
	},
	"map debug": {
		"prefix": "map debug",
		"body": [
			"{ // debug",
			"\tfor (auto ${2:it} = ${1:mp}.begin(); $2 != $1.end(); $2++) {",
			"\t\tcout << \"mp[\";",
			"\t\tcout << $0$2->first;",
			"\t\tcout << \"] = \";",
			"\t\tcout << $2->second;",
			"\t\tcout << \"\" << (next($2) == $1.end() ? \"\\n\" : \", \");",
			"\t}",
			"} //"
		],
		"description": "none"
	},
	"ndbg": {
		"prefix": "ndbg",
		"body": [
			"cout << \"$0\" << endl;"
		],
		"description": "none"
	},
	"new line": {
		"prefix": "new line",
		"body": [
			"{ // debug",
			"\tcout << endl;",
			"} //"
		],
		"description": "none"
	},
	"pdbg": {
		"prefix": "pdbg",
		"body": [
			"{ // debug",
			"\tcout << \"${1:おなまえ} = (\" << $1${2:.}first << \", \" <<\t$1$2second << \")\" << endl;",
			"} //"
		],
		"description": "none"
	},
	"vpdebug": {
		"prefix": "vpdebug",
		"body": [
			"{ // debug",
			"\tcout << \"${1:name}: \";",
			"\tfor (auto ${2:it} = $1.begin(); $2 != $1.end(); $2++) {",
			"\t\tcout << \"(\";",
			"\t\tcout << $2->first;",
			"\t\tcout << \", \";",
			"\t\tcout << $2->second;",
			"\t\tcout << \")\" << (next($2) == $1.end() ? \"\\n\" : \", \");",
			"\t}",
			"\tcout << endl;",
			"} //"
		],
		"description": "none"
	},
	"vvdbg": {
		"prefix": "vvdbg",
		"body": [
			"{ // debug",
			"\tint h = ${1:name}.size(); int w = 0;",
			"\tint name_length = ${2:3}; int output_length = ${3:4};",
			"\tfor (int i = 0; i < h; i++) if (w < (int)$1[i].size()) w = $1[i].size();",
			"\tcout << string(name_length, '-') << \"--\";",
			"\tfor (int j = 0; j < w; j++) cout << setw(${3:output length}) << \"----\";",
			"\tcout << endl;",
			"\tcout << setw(name_length) << right << \"$1\" << \"| \";",
			"\tfor (int j = 0; j < w; j++) cout << setw(output_length) << right <<\tj;",
			"\tcout << endl;",
			"\tcout << string(name_length, '-') << \"+-\";",
			"\tfor (int j = 0; j < w; j++) cout << string(output_length, '-');",
			"\tcout << endl;",
			"\tfor (int i = 0; i < h; i++) {",
			"\t\tcout << setw(name_length) << right << i << \"| \";",
			"\t\tfor (auto const& e : $1[i]) cout << setw(output_length) << right << (e == ${4:0} ? \"0\" : to_string(e));",
			"\t\tcout << endl;",
			"\t}",
			"\tcout << string(name_length, '-') << \"--\";",
			"\tfor (int j = 0; j < w; j++) cout << string(output_length, '-');",
			"\tcout << endl;",
			"} //"
		],
		"description": "none"
	},
	"convolution": {
		"prefix": "convolution",
		"body": [
			"template<typename T>",
			"class convolution {",
			"\tconst T id;",
			"\tconst function<void(T&, T)> add;",
			"\tconst function<T(T, T)> mul;",
			"\tpublic:",
			"\t\tconvolution (",
			"\t\t\t\tT id,",
			"\t\t\t\tfunction<void(T&, T)> add,",
			"\t\t\t\tfunction<T(T, T)> mul",
			"\t\t\t) :",
			"\t\t\tid(id),",
			"\t\t\tadd(add),",
			"\t\t\tmul(mul)",
			"\t\t\t{",
			"\t\t\t}",
			"\t\tauto operator () (",
			"\t\t\t\tvector<T> a,",
			"\t\t\t\tvector<T> b",
			"\t\t\t) -> vector<T>",
			"\t\t\t{",
			"\t\t\t\tint l = a.size();",
			"\t\t\t\tint m = b.size();",
			"\t\t\t\tint n = l + m - 1;",
			"\t\t\t\tassert(l && m);",
			"\t\t\t\tvector<T> c(n, id);",
			"\t\t\t\tfor (int i = 0; i < l; i++) {",
			"\t\t\t\t\tfor (int j = 0; j < m; j++) {",
			"\t\t\t\t\t\tadd(c[i + j], mul(a[i], b[j]));",
			"\t\t\t\t\t}",
			"\t\t\t\t}",
			"\t\t\t\treturn c;",
			"\t\t\t}",
			"};",
			"convolution<${1:long long}> cnv(",
			"\t\t${2:id},",
			"\t\t${3:add},",
			"\t\t${4:mul}",
			"\t);",
			"\t"
		],
		"description": "none"
	},
	"bellman ford": {
		"prefix": "bellman ford",
		"body": [
			"template<typename T>",
			"struct bellman_ford {",
			"\tusing edge_type = tuple<T, int, int>;",
			"\tconst int n;",
			"\tconst int r;",
			"\tconst vector<edge_type>& edg;",
			"\tconst T inf;",
			"\tbool flg;",
			"\tvector<long long> dst;",
			"\tbellman_ford (",
			"\t\t\tint n,",
			"\t\t\tint root,",
			"\t\t\tconst vector<edge_type>& edg,",
			"\t\t\tconst T inf",
			"\t\t) :",
			"\t\tn(n),",
			"\t\tr(root),",
			"\t\tedg(edg),",
			"\t\tinf(inf),",
			"\t\tflg(false),",
			"\t\tdst(n, inf)",
			"\t\t{",
			"\t\t\tdst[r] = 0;",
			"\t\t\tfor (int q = n; q--;) {",
			"\t\t\t\tflg = false;",
			"\t\t\t\tfor (auto const& e : edg) {",
			"\t\t\t\t\tT d; int s, t; tie(d, s, t) = e;",
			"\t\t\t\t\tif (dst[s] == inf) continue;",
			"\t\t\t\t\tif (chmin(dst[t], dst[s] + d)) flg = true;",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t}",
			"\tbool has_negative_cycle () const {return flg;}",
			"};"
		],
		"description": "none"
	},
	"centroid tree": {
		"prefix": "centroid tree",
		"body": [
			"class centroid_tree {",
			"\tconst int n;",
			"\tconst vector<vector<int>> grh;",
			"\tvector<bool> ckd;",
			"\tvector<vector<int>> ctr;",
			"\tqueue<tuple<int, int, int>> que;",
			"\tint rt = -1;",
			"\tvoid build ()",
			"\t\t{",
			"\t\t\tvector<int> sz(n);",
			"\t\t\tque.emplace(-1, 0, n);",
			"\t\t\twhile (!que.empty()) {",
			"\t\t\t\tint prv_ctr, start, bkt; tie(prv_ctr, start, bkt) = que.front(); que.pop();",
			"\t\t\t\tint new_ctr = -1;",
			"\t\t\t\tmake_fixed_point ([&](auto dfs, int crr, int prt) -> void {",
			"\t\t\t\t\t\tsz[crr] = 1;",
			"\t\t\t\t\t\tfor (auto const& nxt : grh[crr]) if (nxt != prt && !ckd[nxt]) {",
			"\t\t\t\t\t\t\tdfs(nxt, crr); if (new_ctr != -1) return;",
			"\t\t\t\t\t\t\tsz[crr] += sz[nxt];",
			"\t\t\t\t\t\t}",
			"\t\t\t\t\t\tif (sz[crr] * 2 >= bkt) {",
			"\t\t\t\t\t\t\tfor (auto const& nxt : grh[crr]) if (!ckd[nxt]) {",
			"\t\t\t\t\t\t\t\tif (nxt != prt) que.emplace(crr, nxt, sz[nxt]);",
			"\t\t\t\t\t\t\t\telse que.emplace(crr, nxt, bkt - sz[crr]);",
			"\t\t\t\t\t\t\t}",
			"\t\t\t\t\t\t\tckd[crr] = true;",
			"\t\t\t\t\t\t\tnew_ctr = crr;",
			"\t\t\t\t\t\t}",
			"\t\t\t\t\t})(start, start);",
			"\t\t\t\tif (prv_ctr == -1) rt = new_ctr;",
			"\t\t\t\telse ctr[prv_ctr].push_back(new_ctr);",
			"\t\t\t}",
			"\t\t}",
			"\tpublic:",
			"\t\tcentroid_tree (",
			"\t\t\t\tvector<vector<int>> grh",
			"\t\t\t) :",
			"\t\t\tn(grh.size()),",
			"\t\t\tgrh(grh), ckd(n, false),",
			"\t\t\tctr(n)",
			"\t\t\t{",
			"\t\t\t\tbuild();",
			"\t\t\t}",
			"\t\tauto const centroid () const {return rt;}",
			"\t\tauto const& result () const {return ctr;}",
			"\t\tauto const& operator [] (int i) const {return ctr[i];}",
			"\t\tauto const size () const {return n;}",
			"};"
		],
		"description": "none"
	},
	"depth": {
		"prefix": "depth",
		"body": [
			"class centroid_tree {",
			"\tconst int n;",
			"\tconst vector<vector<int>> grh;",
			"\tvector<bool> ckd;",
			"\tvector<int> prt, dpt;",
			"\tvector<vector<int>> cld, acs, dst, sct;",
			"\tqueue<tuple<int, int, int>> que;",
			"\tint whole_ctr = -1;",
			"",
			"\tint dfs (",
			"\t\t\tconst int crr,",
			"\t\t\tconst int prv,",
			"\t\t\tconst int bkt,",
			"\t\t\tvector<int>& sz",
			"\t\t)",
			"\t\t{",
			"\t\t\tfor (auto const& nxt : grh[crr]) if (nxt != prv && !ckd[nxt]) {",
			"\t\t\t\tint x = dfs(nxt, crr, bkt, sz); if (x != -1) return x;",
			"\t\t\t\tsz[crr] += sz[nxt];",
			"\t\t\t}",
			"\t\t\tif (sz[crr] * 2 >= bkt) {",
			"\t\t\t\tfor (auto const& nxt : grh[crr]) if (nxt != prv && !ckd[nxt]) {",
			"\t\t\t\t\tque.emplace(crr, nxt, sz[nxt]);",
			"\t\t\t\t}",
			"\t\t\t\tif (!ckd[prv]) {",
			"\t\t\t\t\tque.emplace(crr, prv, bkt - sz[crr]);",
			"\t\t\t\t}",
			"\t\t\t\tckd[crr] = true;",
			"\t\t\t\treturn crr;",
			"\t\t\t}",
			"\t\t\treturn -1;",
			"\t\t}",
			"\t",
			"\tvoid build_centroid_tree ()",
			"\t\t{",
			"\t\t\tque.emplace(-1, 0, n);",
			"\t\t\twhile (!que.empty()) {",
			"\t\t\t\tint u, rt, bkt; tie(u, rt, bkt) = que.front(); que.pop();",
			"\t\t\t\tvector<int> sz(n, 1);",
			"\t\t\t\tint l = dfs(rt, rt, bkt, sz);",
			"\t\t\t\tif (u == -1) {",
			"\t\t\t\t\twhole_ctr = l;",
			"\t\t\t\t\tprt[l] = l;",
			"\t\t\t\t\tdpt[l] = 0;",
			"\t\t\t\t} else if (u != l) {",
			"\t\t\t\t\tcld[u].push_back(l);",
			"\t\t\t\t\tprt[l] = u;",
			"\t\t\t\t\tdpt[l] = dpt[u] + 1;",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t}",
			"\t",
			"\tvoid efs (",
			"\t\t\tconst int rt,",
			"\t\t\tconst int rt_dpt,",
			"\t\t\tint crr,",
			"\t\t\tint prv",
			"\t\t)",
			"\t\t{",
			"\t\t\tfor (auto const& nxt : grh[crr]) if (nxt != prv && dpt[nxt] > rt_dpt) {",
			"\t\t\t\tdst[nxt][dpt[nxt] - rt_dpt] = dst[crr][dpt[crr] - rt_dpt] + 1;",
			"\t\t\t\tefs(rt, rt_dpt, nxt, crr);",
			"\t\t\t}",
			"\t\t}",
			"\t",
			"\tvoid calc_dst ()",
			"\t\t{",
			"\t\t\tfor (int i = 0; i < n; i++) {",
			"\t\t\t\tacs[i].resize(dpt[i] + 1);",
			"\t\t\t\tdst[i].resize(dpt[i] + 1);",
			"\t\t\t}",
			"\t\t\tfor (int rt = 0; rt < n; rt++) {",
			"\t\t\t\tefs(rt, dpt[rt], rt, rt);",
			"\t\t\t}",
			"\t\t}",
			"\t",
			"\tint ancestor (",
			"\t\t\tint x,",
			"\t\t\tint i",
			"\t\t)",
			"\t\t{",
			"\t\t\tassert (0 <= i && i <= dpt[x]);",
			"\t\t\twhile (i--) {",
			"\t\t\t\tx = prt[x];",
			"\t\t\t}",
			"\t\t\treturn x;",
			"\t\t}",
			"\t",
			"\tvoid calc_sct ()",
			"\t\t{",
			"\t\t\tfor (int x = 0; x < n; x++) {",
			"\t\t\t\tfor (int i = 0; i < dpt[x]; i++) {",
			"\t\t\t\t\tint a = ancestor(x, i);",
			"\t\t\t\t\tint d = dst[x][i + 1];",
			"\t\t\t\t\t{ // debug",
			"\t\t\t\t\t\tcout",
			"\t\t\t\t\t\t\t<< \"x = \" << x << \", \"",
			"\t\t\t\t\t\t\t<< \"a = \" << a << \", \"",
			"\t\t\t\t\t\t\t<< \"d = \" << d",
			"\t\t\t\t\t\t\t<< endl;",
			"\t\t\t\t\t} //",
			"\t\t\t\t\tif ((int)sct[a].size() < d) sct[a].resize(d + 1, 0);",
			"\t\t\t\t\tsct[a][d]++;",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t}",
			"\t",
			"\tvoid build ()",
			"\t\t{",
			"\t\t\tbuild_centroid_tree();",
			"\t\t\tcalc_dst();",
			"\t\t\tcalc_sct();",
			"\t\t}",
			"",
			"\tpublic:",
			"\t\tcentroid_tree (",
			"\t\t\t\tvector<vector<int>> grh",
			"\t\t\t) :",
			"\t\t\tn(grh.size()),",
			"\t\t\tgrh(grh), ckd(n, false),",
			"\t\t\tprt(n), dpt(n),",
			"\t\t\tcld(n), acs(n), dst(n), sct(n)",
			"\t\t\t{",
			"\t\t\t\tbuild();",
			"\t\t\t\t{ // debug",
			"\t\t\t\t\tcout << \"--------------------------------------\" << endl;",
			"\t\t\t\t\tcout << setw(5) << left << \"sct\";",
			"\t\t\t\t\tfor (int i = 0; i < (int)sct.size(); i++) {",
			"\t\t\t\t\t\tif (i != 0) cout << setw(5) << \" \";",
			"\t\t\t\t\t\tcout << \"i = \" << setw(2) << right << i << \": \";",
			"\t\t\t\t\t\tfor (int j = 0; j < (int)sct[i].size(); j++) {",
			"\t\t\t\t\t\t\tcout << setw(4) << right << sct[i][j];",
			"\t\t\t\t\t\t\tif (j != (int)sct[i].size() - 1) cout << \" \";",
			"\t\t\t\t\t\t}",
			"\t\t\t\t\t\tcout << endl;",
			"\t\t\t\t\t}",
			"\t\t\t\t\tcout << \"--------------------------------------\" << endl;",
			"\t\t\t\t} //",
			"\t\t\t}",
			"\t\t",
			"\t\tauto const& child (",
			"\t\t\t\tint x",
			"\t\t\t) const",
			"\t\t\t{",
			"\t\t\t\treturn cld[x];",
			"\t\t\t}",
			"",
			"\t\tauto const& parent (",
			"\t\t\t\tint x",
			"\t\t\t) const",
			"\t\t\t{",
			"\t\t\t\treturn prt[x];",
			"\t\t\t}",
			"",
			"\t\tauto const& depth (",
			"\t\t\t\tint x",
			"\t\t\t) const",
			"\t\t\t{",
			"\t\t\t\treturn dpt[x];",
			"\t\t\t}",
			"",
			"\t\tauto const& centroid (",
			"\t\t\t\tconst int x",
			"\t\t\t) const",
			"\t\t\t{",
			"\t\t\t\treturn whole_ctr;",
			"\t\t\t}",
			"};"
		],
		"description": "none"
	},
	"dfs1": {
		"prefix": "dfs1",
		"body": [
			"void ${1:dfs} (",
			"\t\tconst vector<vector<int>>& grh,",
			"\t\tint crr = ${2:0},",
			"\t\tint prt = ${2:0}",
			"\t) {",
			"\t\tfor (int nxt : grh[crr]) if (nxt != prt) {",
			"\t\t\t$1(grh, nxt, crr);",
			"\t\t}",
			"\t}"
		],
		"description": "none"
	},
	"dfs2": {
		"prefix": "dfs2",
		"body": [
			"void ${1:dfs} (",
			"\tconst vector<vector<int>>& grh,",
			"\tvector<int>& ckd,",
			"\tint crr = ${2:0}",
			") {",
			"\tckd[crr] = true;",
			"\tfor (int nxt : grh[crr]) if (!ckd[nxt]) {",
			"\t\t$1(grh, ckd, crr);",
			"\t}",
			"}"
		],
		"description": "none"
	},
	"diameter": {
		"prefix": "diameter",
		"body": [
			"template<typename T>",
			"class calculate_diameter {",
			"\tconst int n;",
			"\tconst vector<vector<pair<T, int>>>& grh;",
			"\tint max_dpt;",
			"\tint far_0, far_1;",
			"",
			"\t\tvoid dfs (",
			"\t\t\t\tint crr,",
			"\t\t\t\tint prt,",
			"\t\t\t\tT dpt,",
			"\t\t\t\tint& far",
			"\t\t\t) {",
			"\t\t\t\tif (chmax(max_dpt, dpt)) far = crr;",
			"\t\t\t\tfor (auto const& e : grh[crr]) {",
			"\t\t\t\t\tT w; int nxt; tie(w, nxt) = e;",
			"\t\t\t\t\tif (nxt == prt) continue;",
			"\t\t\t\t\tdfs(nxt, crr, dpt + w, far);",
			"\t\t\t\t}",
			"\t\t\t}",
			"",
			"\tpublic:",
			"\t\tcalculate_diameter(",
			"\t\t\t\tvector<vector<pair<T, int>>>& grh",
			"\t\t\t) :",
			"\t\t\tn(grh.size()),",
			"\t\t\tgrh(grh),",
			"\t\t\tmax_dpt(0),",
			"\t\t\tfar_0(0), far_1(0)",
			"\t\t\t{",
			"\t\t\t\tdfs(0, 0, 0, far_0);",
			"\t\t\t\tdfs(far_0, far_0, 0, far_1);",
			"\t\t\t}",
			"",
			"\t\tT diameter () const {return max_dpt;}",
			"\t\tauto extremal () const -> pair<int, int> {return {min(far_0, far_1), max(far_0, far_1)};}",
			"};"
		],
		"description": "none"
	},
	"dijkstra": {
		"prefix": "dijkstra",
		"body": [
			"template<typename T>",
			"static inline constexpr decltype(auto)",
			"\tmake_fixed_point (T&& t) noexcept {",
			"\t\treturn fixed_point<T>{forward<T>(t)};",
			"\t}",
			"template <typename T>",
			"class dijkstra {",
			"\tconst int n;",
			"\tconst int r;",
			"\tconst T inf;",
			"\tconst vector<vector<pair<T, int>>>& grh;",
			"\tvector<T> dst;",
			"\tpublic:",
			"\t\tdijkstra (",
			"\t\t\t\tconst vector<vector<pair<T, int>>>& grh,",
			"\t\t\t\tconst int root,",
			"\t\t\t\tconst T inf",
			"\t\t\t) :",
			"\t\t\tn(grh.size()),",
			"\t\t\tr(root),",
			"\t\t\tinf(inf),",
			"\t\t\tgrh(grh),",
			"\t\t\tdst(n, inf)",
			"\t\t\t{",
			"\t\t\t\tpriority_queue<",
			"\t\t\t\t\tpair<T, int>,",
			"\t\t\t\t\tvector<pair<T, int>>,",
			"\t\t\t\t\tgreater<pair<T, int>>",
			"\t\t\t\t> que;",
			"\t\t\t\tque.emplace(0, r);",
			"\t\t\t\twhile (!que.empty()) {",
			"\t\t\t\t\tT crd; int crr;",
			"\t\t\t\t\ttie(crd, crr) = que.top(), que.pop();",
			"\t\t\t\t\tif (!cmn(dst[crr], crd)) continue;",
			"\t\t\t\t\tfor (auto e : grh[crr]) {",
			"\t\t\t\t\t\tT w; int nxt; tie(w, nxt) = e;",
			"\t\t\t\t\t\tT nxd = crd + w;",
			"\t\t\t\t\t\tif (dst[nxt] > nxd) que.emplace(nxd, nxt);",
			"\t\t\t\t\t}",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\tauto result () const {return dst;}",
			"};"
		],
		"description": "none"
	},
	"floyd warshall": {
		"prefix": "floyd warshall",
		"body": [
			"template<typename T1, typename T2>",
			"inline bool chmin (T1& a, T2 b) {",
			"\tif (a > b) {",
			"\t\ta = b;",
			"\t\treturn true;",
			"\t}",
			"\treturn false;",
			"}",
			"template<typename T>",
			"struct floyd_warshall {",
			"\tconst int n;",
			"\tconst T inf;",
			"\tvector<vector<T>> dst;",
			"\tfloyd_warshall (",
			"\t\t\tvector<vector<T>> adj,",
			"\t\t\tconst T inf",
			"\t\t) :",
			"\t\tn(adj.size()),",
			"\t\tinf(inf),",
			"\t\tdst(adj)",
			"\t\t{",
			"\t\t\tfor (int k = 0; k < n; k++) {",
			"\t\t\t\tfor (int i = 0; i < n; i++) {",
			"\t\t\t\t\tfor (int j = 0; j < n; j++) {",
			"\t\t\t\t\t\tif (dst[i][k] != inf && dst[k][j] != inf)",
			"\t\t\t\t\t\t\tchmin(dst[i][j], dst[i][k] + dst[k][j]);",
			"\t\t\t\t\t}",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t}",
			"\tconst bool has_negative_cycle () {",
			"\t\tfor (int i = 0; i < n; i++) if (dst[i][i] < 0) return true;",
			"\t\treturn false;",
			"\t}",
			"};"
		],
		"description": "none"
	},
	"grid bfs": {
		"prefix": "grid bfs",
		"body": [
			"vector<vector<${1:long long}>> dst(h, vector<$1>(w, ${4:-1}));",
			"queue<pair<int, int>> que;",
			"dst[${2:si}][${3:sj}] = 0, que.emplace($2, $3);",
			"while (!que.empty()) {",
			"\tint cri, crj;",
			"\ttie(cri, crj) = que.front(), que.pop();",
			"\tfor (int k = 0; k < 4; k++) {",
			"\t\tint nxi = cri + di[k];",
			"\t\tint nxj = crj + dj[k];",
			"\t\tif (",
			"\t\t\t\t0 <= nxi && nxi < h &&",
			"\t\t\t\t0 <= nxj && nxj <= w &&",
			"\t\t\t\tdst[nxi][nxj] == $4 &&",
			"\t\t\t\t!grd[nxi][nxj]",
			"\t\t\t) dst[nxi][nxj] = dst[cri][crj] + 1, que.emplace(nxi, nxj);",
			"\t}",
			"}"
		],
		"description": "none"
	},
	"heights": {
		"prefix": "heights",
		"body": [
			"template<typename T>",
			"class calculate_heights {",
			"\tconst int n;",
			"\tconst vector<vector<pair<T, int>>>& grh;",
			"\tvector<T> dp, ep;",
			"",
			"\tvoid dfs (",
			"\t\t\tint crr = 0,",
			"\t\t\tint prt = 0",
			"\t\t) {",
			"\t\t\tfor (auto const& e : grh[crr]) {",
			"\t\t\t\tT w; int nxt; tie(w, nxt) = e;",
			"\t\t\t\tif (nxt == prt) continue;",
			"\t\t\t\tdfs(nxt, crr);",
			"\t\t\t\tchmax(dp[crr], dp[nxt] + w);",
			"\t\t\t}",
			"\t\t}",
			"",
			"\tvoid efs (",
			"\t\t\tint crr = 0,",
			"\t\t\tint prt = 0",
			"\t\t) {",
			"\t\t\tvector<T> cld = {ep[crr]};",
			"\t\t\tfor (auto const& e : grh[crr]) {",
			"\t\t\t\tT w; int nxt; tie(w, nxt) = e;",
			"\t\t\t\tif (nxt == prt) continue;",
			"\t\t\t\tcld.push_back(dp[nxt] + w);",
			"\t\t\t}",
			"\t\t\tsort(cld.begin(), cld.end(), greater<T>());",
			"\t\t\tfor (auto const& e : grh[crr]) {",
			"\t\t\t\tT w; int nxt; tie(w, nxt) = e;",
			"\t\t\t\tif (nxt == prt) continue;",
			"\t\t\t\tep[nxt] = dp[nxt] + w == cld[0] ?",
			"\t\t\t\t\t\tcld[1] + w : cld[0] + w;",
			"\t\t\t}",
			"\t\t\tfor (auto const& e : grh[crr]) {",
			"\t\t\t\tT w; int nxt; tie(w, nxt) = e;",
			"\t\t\t\tif (nxt == prt) continue;",
			"\t\t\t\tefs(nxt, crr);",
			"\t\t\t}",
			"\t\t\tchmax(dp[crr], ep[crr]);",
			"\t\t}",
			"",
			"\tpublic:",
			"\t\tcalculate_heights(",
			"\t\t\t\tvector<vector<pair<T, int>>>& grh",
			"\t\t\t) :",
			"\t\t\tn(grh.size()),",
			"\t\t\tgrh(grh),",
			"\t\t\tdp(n, 0),",
			"\t\t\tep(n, 0)",
			"\t\t\t{",
			"\t\t\t\tdfs();",
			"\t\t\t\tefs();",
			"\t\t\t}",
			"\t\t",
			"\t\tauto operator[] (int i) const -> const T {return dp[i];}",
			"};"
		],
		"description": "none"
	},
	"inner dfs1": {
		"prefix": "inner dfs1",
		"body": [
			"\tvoid dfs (",
			"\t\t\tint crr = 0,",
			"\t\t\tint prt = 0",
			"\t\t) {",
			"\t\t\tfor (int const& nxt : grh[crr]) {",
			"\t\t\t\t${2:T} w; int nxt; tie(w, nxt) = e;",
			"\t\t\t\tif (nxt == prt) continue;",
			"\t\t\t\tdfs(nxt, crr);",
			"\t\t\t\tchmax(dp[crr], dp[nxt] + w);",
			"\t\t\t}",
			"\t\t}"
		],
		"description": "none"
	},
	"kruskal": {
		"prefix": "kruskal",
		"body": [
			"template<typename T>",
			"struct kruskal {",
			"\tusing edge_type = tuple<T, int, int>;",
			"\tconst int n;",
			"\tvector<edge_type> edg;",
			"\tvector<edge_type> mst;",
			"\tT weight_of_mst;",
			"\tkruskal (",
			"\t\t\tint n,",
			"\t\t\tvector<edge_type> edg",
			"\t\t) :",
			"\t\tn(n),",
			"\t\tedg(edg),",
			"\t\tmst(n - 1),",
			"\t\tweight_of_mst(0)",
			"\t\t{",
			"\t\t\tsort(edg.begin(), edg.end());",
			"\t\t\tdisjoint_set djs(n);",
			"\t\t\tint cnt = 0;",
			"\t\t\tfor (auto e : edg) {",
			"\t\t\t\tT w; int s, t; tie(w, s, t) = e;",
			"\t\t\t\tif (djs.unite(s, t)) {",
			"\t\t\t\t\tweight_of_mst += w;",
			"\t\t\t\t\tmst[cnt] = {w, s, t};",
			"\t\t\t\t\tif (++cnt == n - 1) break;",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t\tif (cnt < n - 1) assert(false);",
			"\t\t}\t\t",
			"};"
		],
		"description": "none"
	},
	"least common ancestor": {
		"prefix": "least common ancestor",
		"body": [
			"class least_common_ancestor {",
			"\tconst int n, r;",
			"\tint ht;",
			"\tvector<int> dpt;",
			"\tvector<vector<int>> prt;",
			"\tconst vector<vector<int>> grh;",
			"",
			"\tvoid dfs (",
			"\t\t\tconst vector<vector<int>>& grh,",
			"\t\t\tvector<int>& dpt,",
			"\t\t\tint crr, int prt",
			"\t\t) {",
			"\t\t\tfor (int const& nxt : grh[crr]) {",
			"\t\t\t\tif (nxt == prt) continue;",
			"\t\t\t\tdpt[nxt] = dpt[crr] + 1;",
			"\t\t\t\tdfs(grh, dpt, nxt, crr);",
			"\t\t\t}",
			"\t\t}",
			"\t\tvoid climb (int& x, int b) const {",
			"\t\t\tfor (int i = 0; b; i++, b >>= 1) {",
			"\t\t\t\tif (b & 1) x = prt[i][x];",
			"\t\t\t}",
			"\t\t}",
			"",
			"\tpublic:",
			"\t\tleast_common_ancestor (",
			"\t\t\t\tconst vector<vector<int>>& grh,",
			"\t\t\t\tconst vector<int>& direct_prt,",
			"\t\t\t\tconst int root",
			"\t\t\t) :",
			"\t\t\tn(direct_prt.size()), r(root),",
			"\t\t\tht([&, i = 0]() mutable {",
			"\t\t\t\t\tfor (int p = 1; p < n; p <<= 1) i++;",
			"\t\t\t\t\treturn i;",
			"\t\t\t\t}()),",
			"\t\t\tdpt([&](){",
			"\t\t\t\t\tvector<int> ret(n, 0);",
			"\t\t\t\t\tdfs(grh, ret, r, r);",
			"\t\t\t\t\treturn ret;",
			"\t\t\t\t}()),",
			"\t\t\tprt([&](){",
			"\t\t\t\t\tvector<vector<int>> ret(ht, direct_prt);",
			"\t\t\t\t\tfor (int i = 1; i < ht; i++) {",
			"\t\t\t\t\t\tfor (int j = 0; j < n; j++) {",
			"\t\t\t\t\t\t\tprt[i][j] = prt[i - 1][prt[i - 1][j]];",
			"\t\t\t\t\t\t}",
			"\t\t\t\t\t}",
			"\t\t\t\t\treturn ret;",
			"\t\t\t\t}()),",
			"\t\t\tgrh(grh)",
			"\t\t\t{",
			"\t\t\t}",
			"",
			"\t\tint higher_prt (int x, int b) const {climb(x, b); return x;}",
			"\t\tint depth (int x) const {return dpt[x];}",
			"\t\tint lca (int x, int y) {",
			"\t\t\tif (dpt[x] < dpt[y]) climb(y, dpt[y] - dpt[x]);",
			"\t\t\telse if (dpt[y] < dpt[x]) climb(x, dpt[x] - dpt[y]);",
			"\t\t\tif (x == y) return x;",
			"\t\t\tfor (int i = ht - 1; i >= 0; i--) {",
			"\t\t\t\tif (prt[i][x] != prt[i][y]) {",
			"\t\t\t\t\tx = prt[i][x];",
			"\t\t\t\t\ty = prt[i][y];",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t\treturn prt[0][x];",
			"\t\t}",
			"};"
		],
		"description": "none"
	},
	"low link tree": {
		"prefix": "low link tree",
		"body": [
			"struct low_link_tree {",
			"\tconst int n;",
			"\tconst int r = 0;",
			"\tint tmr = 0;",
			"\tvector<int> ord;",
			"\tvector<int> low;",
			"\tset<int> art;",
			"\tset<pair<int, int>> bdg;",
			"\tvector<vector<int>> grh;",
			"public:",
			"\tlow_link_tree (",
			"\t\tvector<vector<int>> const& grh,",
			"\t\tconst int root",
			"\t)",
			"\t: n(grh.size())",
			"\t, r(root)",
			"\t, ord(n, -1)",
			"\t, low(n, -1)",
			"\t, grh(grh)",
			"\t{",
			"\t\tdfs(r, r);",
			"\t}",
			"\tvoid dfs (",
			"\t\tint crr",
			"\t,\tint prt",
			"\t) {",
			"\t\tint cnt = 0;",
			"\t\tord[crr] = low[crr] = tmr++;",
			"\t\tfor (int nxt : grh[crr]) {",
			"\t\t\tif (ord[nxt] == -1) {",
			"\t\t\t\tcnt++;",
			"\t\t\t\tdfs(nxt, crr);",
			"\t\t\t\tchmin(low[crr], low[nxt]);",
			"\t\t\t\tif (crr != r && ord[crr] <= low[nxt]) art.insert(crr);",
			"\t\t\t\tif (ord[crr] < low[nxt]) bdg.emplace(min(crr, nxt), max(crr, nxt));",
			"\t\t\t}",
			"\t\t\tif (nxt != prt) chmin(low[crr], ord[nxt]);",
			"\t\t}",
			"\t\tif (crr == r && cnt > 1) art.insert(crr);",
			"\t}",
			"};"
		],
		"description": "none"
	},
	"prim": {
		"prefix": "prim",
		"body": [
			"template <typename T>",
			"struct prim {",
			"\tconst int n;",
			"\tvector<vector<pair<T, int>>> grh;",
			"\tT weight_of_mst;",
			"\tprim (",
			"\t\t\tvector<vector<pair<T, int>>> grh",
			"\t\t) :",
			"\t\tn(grh.size()),",
			"\t\tgrh(grh),",
			"\t\tweight_of_mst(0)",
			"\t\t{",
			"\t\t\tvector<bool> ckd(n, false);",
			"\t\t\tpriority_queue<",
			"\t\t\t\tpair<T, int>,",
			"\t\t\t\tvector<pair<T, int>>,",
			"\t\t\t\tgreater<pair<T, int>>",
			"\t\t\t> que;",
			"\t\t\tque.emplace(0, 0);",
			"\t\t\twhile (!que.empty()) {",
			"\t\t\t\tT w; int t;",
			"\t\t\t\ttie(w, t) = que.top(), que.pop();",
			"\t\t\t\tif (ckd[t]) continue;",
			"\t\t\t\tweight_of_mst += w, ckd[t] = true;",
			"\t\t\t\tfor (auto p : grh[t]) que.push(p);",
			"\t\t\t}",
			"\t\t}",
			"};"
		],
		"description": "none"
	},
	"topological sort 1": {
		"prefix": "topological sort 1",
		"body": [
			"class topological_sort {",
			"\tconst int n;",
			"\tconst vector<vector<int>>& grh;",
			"\tvector<int> srd;",
			"\tvector<int> ckd;",
			"\tbool flg;",
			"",
			"\tbool dfs (int crr) {",
			"\t\tif (ckd[crr] == 1) return true;",
			"\t\tif (ckd[crr] == 2) return false;",
			"\t\tbool ret = false;",
			"\t\tckd[crr] = 1;",
			"\t\tfor (int nxt : grh[crr]) {",
			"\t\t\tret |= dfs(nxt);",
			"\t\t}",
			"\t\tckd[crr] = 2;",
			"\t\tsrd.insert(srd.begin(), crr);",
			"\t\treturn ret;",
			"\t}",
			"",
			"\tpublic:",
			"\t\ttopological_sort (",
			"\t\t\t\tconst vector<vector<int>>& grh",
			"\t\t\t) :",
			"\t\t\tn(grh.size()),",
			"\t\t\tgrh(grh),",
			"\t\t\tsrd(),",
			"\t\t\tckd(n, 0),",
			"\t\t\tflg(",
			"\t\t\t\t\t[&](){",
			"\t\t\t\t\t\tbool ret = false;",
			"\t\t\t\t\t\tfor (int i = 0; i < n; i++) {",
			"\t\t\t\t\t\t\tflg |= (ckd[i] == 0 && dfs(i));",
			"\t\t\t\t\t\t}",
			"\t\t\t\t\t\treturn ret;",
			"\t\t\t\t\t}()",
			"\t\t\t\t)",
			"\t\t\t{",
			"\t\t\t}",
			"\t\tbool has_cycle () {return flg;}",
			"\t\tauto sorted() const -> const vector<int>& {return srd;}",
			"\t\tauto operator [] (int i) const -> int {return srd[i];}",
			"};"
		],
		"description": "none"
	},
	"topological sort 2": {
		"prefix": "topological sort 2",
		"body": [
			"// none (tail)"
		],
		"description": "none"
	},
	"binary serch": {
		"prefix": "binary serch",
		"body": [
			"${1:int} ${2:ok} = ${3:0}, ${4:ng} = ${5:inf}, md;",
			"while (${4:ng} - ${2:ok} > 1) {",
			"\tmd = (${2:ok} + ${4:ng}) >> 1;",
			"\tif (${6:ck(md)}) ok = md;",
			"\telse ng = md;",
			"}"
		],
		"description": "none"
	},
	"lis": {
		"prefix": "lis",
		"body": [
			"vector<${1:int}> lis;",
			"for (auto crr : ${2:おなまえ}) {",
			"\tauto lb = lower_bound(lis.begin(), lis.end(), crr);",
			"\tif (lb == lis.end()) lis.push_back(crr);",
			"\telse *lb = crr;",
			"}"
		],
		"description": "none"
	},
	"run length encoding": {
		"prefix": "run length encoding",
		"body": [
			"template<typename T>",
			"class run_length_encoding {",
			"\tvector<pair<int, T>> rle;",
			"\tpublic:",
			"\t\trun_length_encoding(",
			"\t\t\t\tvector<T> input",
			"\t\t\t) :",
			"\t\t\trle(0)",
			"\t\t\t{",
			"\t\t\t\tint cnt = 0;",
			"\t\t\t\tfor (auto it = input.begin(); it != input.end(); it++) {",
			"\t\t\t\t\tauto jt = next(it); cnt++;",
			"\t\t\t\t\tif (jt == input.end() || *it != *jt) {",
			"\t\t\t\t\t\trle.emplace_back(cnt, *it);",
			"\t\t\t\t\t\tcnt = 0;",
			"\t\t\t\t\t}",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\tauto const& code () const {return rle;}",
			"};"
		],
		"description": "none"
	},
	"slide minimum": {
		"prefix": "slide minimum",
		"body": [
			"template <typename T, class Compare = less<T>>",
			"class slide_minimum {",
			"\tpublic:",
			"\tconst vector<T> a;",
			"\tCompare cmp;",
			"\tdeque<int> que;",
			"\tint l, r;",
			"\t\tslide_minimum(",
			"\t\t\t\tconst vector<T>& a",
			"\t\t\t) :",
			"\t\t\ta(a), cmp(Compare()), l(0), r(0)",
			"\t\t\t{",
			"\t\t\t}",
			"\t\tinline void luc () {",
			"\t\t\tif (que.front() == l++) {",
			"\t\t\t\tque.pop_front();",
			"\t\t\t}",
			"\t\t}",
			"\t\tinline void ruc () {",
			"\t\t\twhile (!que.empty() && !cmp(a[que.back()], a[r])) {",
			"\t\t\t\tque.pop_back();",
			"\t\t\t}",
			"\t\t\tque.push_back(r++);",
			"\t\t}",
			"\t\tinline auto query () const -> T {",
			"\t\t\tassert(!que.empty());",
			"\t\t\treturn a[que.front()];",
			"\t\t}",
			"\t\tinline auto query_index () const -> int {",
			"\t\t\tassert(!que.empty());",
			"\t\t\treturn que.front();",
			"\t\t}",
			"};"
		],
		"description": "none"
	},
	"sliing window": {
		"prefix": "sliing window",
		"body": [
			"int l = 0, r = 0;",
			"for (; l < ${1:n}; l++) {",
			"\twhile (r < n && ${2:/*valid ? [l, r + 1)*/}) {",
			"\t\tr++;",
			"\t\t${3:/*visit : [l, r + 1)*/};",
			"\t}",
			"}"
		],
		"description": "none"
	},
	"gauss jordan int": {
		"prefix": "gauss jordan int",
		"body": [
			"class gauss_jordan {",
			"\tconst int h, w;",
			"\tint rk;",
			"\tvector<int> stk;",
			"\tvector<int> p;",
			"\tvector<int> a;",
			"\tpublic:",
			"\t\tgauss_jordan (",
			"\t\t\t\tconst vector<int> input_matrix,",
			"\t\t\t\tconst int bit_max",
			"\t\t\t) :",
			"\t\t\th(bit_max), w(input_matrix.size()), rk(0),",
			"\t\t\tstk([&](){",
			"\t\t\t\t\tvector<int> ret(h);",
			"\t\t\t\t\tfor (int i = 0; i < h; i++) ret[i] = i;",
			"\t\t\t\t\treturn ret;",
			"\t\t\t\t}()),",
			"\t\t\tp([&](){",
			"\t\t\t\t\tvector<int> ret(h); ",
			"\t\t\t\t\tfor (int i = 0, val = 1; i < h; i++, val <<= 1) ret[i] = val;",
			"\t\t\t\t\treturn ret;",
			"\t\t\t\t}()),",
			"\t\t\ta(input_matrix)",
			"\t\t\t{",
			"\t\t\t\tfor (int j = 0; j < w; j++) {",
			"\t\t\t\t\tfor (auto it = stk.begin(); it != stk.end(); it++) {",
			"\t\t\t\t\t\tint pvt = *it;",
			"\t\t\t\t\t\tif ((a[j] >> pvt) & 1) {",
			"\t\t\t\t\t\t\tstk.erase(it); rk++;",
			"\t\t\t\t\t\t\tint spr = a[j] ^ (1 << pvt);",
			"\t\t\t\t\t\t\tfor (int i = 0; i < h; i++) if ((p[i] >> pvt) & 1) p[i] ^= spr;",
			"\t\t\t\t\t\t\tfor (int k = j; k < w; k++) if ((a[k] >> pvt) & 1) a[k] ^= spr;",
			"\t\t\t\t\t\t\tbreak;",
			"\t\t\t\t\t\t}",
			"\t\t\t\t\t}",
			"\t\t\t\t\tif (stk.empty()) break;",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\tinline int translate (int y) const {",
			"\t\t\tint z = 0;",
			"\t\t\tfor (int i = 0; i < h; i++) if ((y >> i) & 1) {",
			"\t\t\t\tz ^= p[i];",
			"\t\t\t}",
			"\t\t\treturn z;",
			"\t\t}",
			"\t\tint rank () const {return rk;}",
			"\t\tauto result () const {return a;}",
			"\t\tbool solvable (int y) const {",
			"\t\t\tif (y >> h) return false;",
			"\t\t\tint acm = accumulate(a.begin(), a.end(), 0, [](int x, int y){return x | y;});",
			"\t\t\tint z = translate(y);",
			"\t\t\treturn !(~acm & z);",
			"\t\t}",
			"};"
		],
		"description": "none"
	},
	"factorials": {
		"prefix": "factorials",
		"body": [
			"struct factorials {",
			"\tconst int sz;",
			"\tvector<int> fct, fnv;",
			"\tfactorials (int n)",
			"\t\t: sz(n)",
			"\t\t, fct(n, 1)",
			"\t\t, fnv(n, 1)",
			"\t\t{",
			"\t\t\tfor (int i = 1; i < n; i++) fct[i] = mul(fct[i - 1], i);",
			"\t\t\tfnv[n - 1] = inv(fct[n - 1]);",
			"\t\t\tfor (int i = n - 1; i >= 1; i--) fnv[i - 1] = mul(fnv[i], i);",
			"\t\t}",
			"\tinline int binom (int n, int k) {",
			"\t\tassert(0 <= k && k <= n && n < sz);",
			"\t\treturn mul(fct[n], mul(fnv[k], fnv[n - k]));",
			"\t}",
			"};"
		],
		"description": "none"
	},
	"factorize": {
		"prefix": "factorize",
		"body": [
			"class factorize {",
			"\tint x;",
			"\tmap<int, int> mp;",
			"\tvector<int> pdv;",
			"\tvector<int> pdv_m;",
			"",
			"\tpublic:",
			"\t\tfactorize(",
			"\t\t\t\tconst int x",
			"\t\t\t) :",
			"\t\t\tx(x), mp(), pdv()",
			"\t\t\t{",
			"\t\t\t\tfor (int p = 2; p * p <= x; p++) {",
			"\t\t\t\t\twhile (!(x % p)) {",
			"\t\t\t\t\t\tmp[p]++;",
			"\t\t\t\t\t\tpdv.push_back(p);",
			"\t\t\t\t\t\tx /= p;",
			"\t\t\t\t\t}",
			"\t\t\t\t}",
			"\t\t\t\tif (x != 1) mp[x] = 1;",
			"\t\t\t\tpdv.push_back(x);",
			"\t\t\t\tpdv_m = pdv.resize(unique(pdv.begin(), pdv.end()) - pdv.begin());",
			"\t\t\t}",
			"\t\t",
			"\t\tconst auto& factorize () const {return pdv;}",
			"\t\tconst auto& prime_divisors () const {return pdv_m;}",
			"\t\tconst auto& multiplicities () const {return mp;}",
			"}"
		],
		"description": "none"
	},
	"gcd": {
		"prefix": "gcd",
		"body": [
			"template<typename T>",
			"T gcd (T a, T b) {",
			"\tif (a < 0) a = -a;",
			"\tif (b < 0) b = -b;",
			"\tif (a < b) swap(a, b);",
			"\twhile (b) {",
			"\t\ta %= b;",
			"\t\tswap(a, b);",
			"\t}",
			"\treturn a;",
			"}"
		],
		"description": "none"
	},
	"mdcal": {
		"prefix": "mdcal",
		"body": [
			"constexpr int md = ${1:1e9 + 7};",
			"inline void mad (int &a, int b) {",
			"\ta += b; if (a >= md) a -= md;",
			"}",
			"inline void msb (int &a, int b) {",
			"\ta -= b; if (a < 0) a += md;",
			"}",
			"inline int vad (int a, int b) {",
			"\tmad(a, b); return a;",
			"}",
			"inline int vsb (int a, int b) {",
			"\tmsb(a, b); return a;",
			"}",
			"inline int mul (int a, int b) {",
			"\treturn (int)((long long)a * b % md);",
			"}",
			"inline int mow (int a, long long b) {",
			"\tint res = 1;",
			"\tfor (; b; b >>= 1) {",
			"\t\tif (b & 1) res = mul(res, a);",
			"\t\ta = mul(a, a);",
			"\t}",
			"\treturn res;",
			"}",
			"inline int inv (int a) {",
			"\ta %= md;",
			"\tif(a < 0) a += md;",
			"\tint b = md, u = 0, v = 1;",
			"\twhile (a) {",
			"\t\tint t = b / a;",
			"\t\tb -= a * t; swap(a, b);",
			"\t\tu -= v * t; swap(u, v);",
			"\t}",
			"\tassert(b == 1);",
			"\tif(u < 0) u += md;",
			"\treturn u;",
			"}"
		],
		"description": "none"
	},
	"sieve of eratosthenes": {
		"prefix": "sieve of eratosthenes",
		"body": [
			"class sieve_of_eratosthenes {",
			"\tconst int n;",
			"\tvector<bool> is_prm;",
			"\tvector<int> prm;",
			"\tvector<vector<int>> pdv;",
			"\tvector<vector<int>> div;",
			"",
			"\tpublic:",
			"\t\tsieve_of_eratosthenes(",
			"\t\t\t\tint n",
			"\t\t\t):",
			"\t\t\t\tn(n),",
			"\t\t\t\tis_prm(vector<bool>(n)),",
			"\t\t\t\tprm(vector<int>(0)), ",
			"\t\t\t\tpdv(vector<vector<int>>(n)),",
			"\t\t\t\tdiv(vector<vector<int>>(n))",
			"\t\t\t{",
			"\t\t\t\tfor (int i = 1; i < n; i++) {",
			"\t\t\t\t\tif (is_prm[i] = div[i].size() == 1) prm.push_back(i);",
			"\t\t\t\t\tfor (int j = i; j < n; j += i) {",
			"\t\t\t\t\t\tdiv[j].push_back(i);",
			"\t\t\t\t\t\tif (is_prm[i]) pdv[j].push_back(i);",
			"\t\t\t\t\t}",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t",
			"\t\tbool is_prime (int x) const {assert(x < n); return is_prime[x];}",
			"\t\tauto prime_divisors (int x) const {assert(x < n); return pdv[x];}",
			"\t\tauto divisors (int x) const {assert(x < n); return div[x];}",
			"",
			"\t\tauto factorize (",
			"\t\t\tint x ",
			"\t\t) -> map<int, int> ",
			"\t\t{",
			"\t\t\tmap<int, int> mp;",
			"\t\t\tfor (int p : prm) {",
			"\t\t\t\twhile (!(x % p)) {",
			"\t\t\t\t\tmp[p]++;",
			"\t\t\t\t\tx /= p;",
			"\t\t\t\t}",
			"\t\t\t\tif (x == 1 || p * p > x) break;",
			"\t\t\t}",
			"\t\t\tif (x != 1) mp[x] = 1;",
			"\t\t\treturn mp;",
			"\t\t}",
			"};"
		],
		"description": "none"
	},
	"1sin": {
		"prefix": "1sin",
		"body": [
			"${1:int} $2;",
			"cin >> $2;"
		],
		"description": "none"
	},
	"2sin": {
		"prefix": "2sin",
		"body": [
			"${1:int} $2, $3;",
			"cin >> $2 >> $3;"
		],
		"description": "none"
	},
	"3sin": {
		"prefix": "3sin",
		"body": [
			"${1:int} $2, $3, $4;",
			"cin >> $2 >> $3 >> $4;"
		],
		"description": "none"
	},
	"4sin": {
		"prefix": "4sin",
		"body": [
			"${1:sin} $2, $3, $4, $5;",
			"cin >> $2 >> $3 >> $4 >> $5;"
		],
		"description": "none"
	},
	"adjacency input": {
		"prefix": "adjacency input",
		"body": [
			"int ${1:n}, ${2:m};",
			"cin >> $1 >> $2;",
			"constexpr ${3:long long} inf = 1LL << 60;",
			"vector<vector<$3>> adj(n, vector<$3>(n, inf));",
			"for (int i = 0; i < $1; i++) adj[i][i] = 0;",
			"for (int i = 0; i < m; i++) {",
			"\t$3 d; int s, t;",
			"\tcin >> s >> t >> d;",
			"\tchmin(adj[s][t], d);",
			"}"
		],
		"description": "none"
	},
	"edge input": {
		"prefix": "edge input",
		"body": [
			"int ${1:n}, ${2:m};",
			"cin >> $1 >> $2;",
			"vector<tuple<${3:long long}, int, int>> edg($2);",
			"for (int i = 0; i < m; i++) {",
			"\t$3 d;",
			"\tint s, t;",
			"\tcin >> s >> t >> d;",
			"\tedg[i] = decltype(edg)::value_type(d, ${4:--}s, $4t);",
			"}"
		],
		"description": "none"
	},
	"err": {
		"prefix": "err",
		"body": [
			"void err() {",
			"\tcout << $0 << endl;",
			"\texit(0);",
			"}"
		],
		"description": "none"
	},
	"graph input": {
		"prefix": "graph input",
		"body": [
			"vector<vector<int>> grh(${1:n});",
			"for (int i = 0; i < ${2:n - 1}; i++) {",
			"\tint s, t;",
			"\tcin >> s >> t;",
			"\tgrh[${3:--}s].push_back($3t);",
			"\tgrh[t].push_back(s);",
			"}"
		],
		"description": "none"
	},
	"graph pair input": {
		"prefix": "graph pair input",
		"body": [
			"vector<vector<pair<${3:long long}, int>>> grh(${1:n});",
			"for (int i = 0; i < ${2:m}; i++) {",
			"\tint s, t; $3 d;",
			"\tcin >> s >> t >> d;",
			"\tgrh[${4:--}s].emplace_back(d, $4t);",
			"\tgrh[t].emplace_back(d, s);",
			"}"
		],
		"description": "none"
	},
	"grid input": {
		"prefix": "grid input",
		"body": [
			"int ${1:h}, ${2:w}, ${3:si}, ${4:sj}, ${5:gi}, ${6:gj};",
			"cin >> $1 >> $2 >> $3 >> $4 >> $5 >> $6;",
			"$3--, $4--, $5--, $6--;",
			"vector<vector<int>> ${7:grd}($1, vector<int>($2));",
			"for (int i = 0; i < $1; i++) {",
			"\tfor (int j = 0; j < $2; j++) {",
			"\t\tchar c;",
			"\t\tcin >> c;",
			"\t\t$7[i][j] = c == '#';",
			"\t}",
			"}"
		],
		"description": "none"
	},
	"optional value": {
		"prefix": "optional value",
		"body": [
			"(${1:dst[i]} == ${2:inf} ? \"${3:INF}\" : to_string($1))"
		],
		"description": "none"
	},
	"sout": {
		"prefix": "sout",
		"body": [
			"cout << $0 << endl;"
		],
		"description": "none"
	},
	"space or newline": {
		"prefix": "space or newline",
		"body": [
			"(${1:i} == ${2:n - 1} ? \" \" : \"\\n\")"
		],
		"description": "none"
	},
	"ternary": {
		"prefix": "ternary",
		"body": [
			"($1 ? $2 : $3)"
		],
		"description": "none"
	},
	"tin": {
		"prefix": "tin",
		"body": [
			"${1:int} ${2:tmp};",
			"cin >> $2;",
			"$0;"
		],
		"description": "none"
	},
	"this_is_to_be_deleted": "foo"
}
