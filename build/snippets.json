{
	"all": {
		"prefix": "all",
		"body": [
			"${1:name}.begin(), $1.end()"
		],
		"description": "none"
	},
	"fors": {
		"prefix": "fors",
		"body": [
			"for (int ${1:i} = ${2:0}; ${1:i} < ${3:n}; ${1:i}++) {",
			"\t$0",
			"}"
		],
		"description": "none"
	},
	"for const": {
		"prefix": "for const",
		"body": [
			"for (auto const & ${1:e}: ${2:name}) {",
			"\t$0",
			"}"
		],
		"description": "none"
	},
	"for iterator": {
		"prefix": "for iterator",
		"body": [
			"for (auto ${1:it} = ${2:name}.begin(); $1 != $2.end(); it++) {",
			"\t$0",
			"}"
		],
		"description": "none"
	},
	"for range": {
		"prefix": "for range",
		"body": [
			"for (auto const& ${1:e} : ${2:name}) {",
			"\t$0",
			"}"
		],
		"description": "none"
	},
	"for reverse": {
		"prefix": "for reverse",
		"body": [
			"for (int ${1:i} = ${2:n - 1}; $1 >= ${3:0}; $1--) {",
			"\t$0",
			"}"
		],
		"description": "none"
	},
	"inf": {
		"prefix": "inf",
		"body": [
			"constexpr int inf = 1 << 30;"
		],
		"description": "none"
	},
	"interval dp": {
		"prefix": "interval dp",
		"body": [
			"for (int d = 1; d <= ${1:n}; d++) {",
			"\tfor (int l = 0, r = d; r <= $1; l++, r++) {",
			"\t\t$0",
			"\t}",
			"}"
		],
		"description": "none"
	},
	"lambda": {
		"prefix": "lambda",
		"body": [
			"auto ${1:name} = [&] ($2) {",
			"\t$0",
			"};"
		],
		"description": "none"
	},
	"long inf": {
		"prefix": "long inf",
		"body": [
			"constexpr long long inf = 1LL << 60;"
		],
		"description": "none"
	},
	"lower bound": {
		"prefix": "lower bound",
		"body": [
			"std::lower_bound(${1:name}.begin(), ${1:name}.end(), ${2:きじゅんち});"
		],
		"description": "none"
	},
	"output stream": {
		"prefix": "output stream",
		"body": [
			"copy(${1:a}.begin(), $1.end(), ostream_iterator<${2:int}>(std::cout, \" \"));",
			"$0"
		],
		"description": "none"
	},
	"pair": {
		"prefix": "pair",
		"body": [
			"std::pair<${1:int}, ${2:int}> ${3:name}(${4:0}, ${5:0})$0;"
		],
		"description": "none"
	},
	"reverse": {
		"prefix": "reverse",
		"body": [
			"reverse(${1:name}.begin(), ${1:name}.end());"
		],
		"description": "none"
	},
	"reverse priority queue": {
		"prefix": "reverse priority queue",
		"body": [
			"priority_queue<",
			"\t${1:std::pair<int, int>},",
			"\tstd::vector<$1>,",
			"\tgreater<$1>",
			"> ${2:que};",
			"$2.emplace($0);"
		],
		"description": "none"
	},
	"sort": {
		"prefix": "sort",
		"body": [
			"sort(${1:name}.begin(), ${1:name}.end());"
		],
		"description": "none"
	},
	"sort reverse": {
		"prefix": "sort reverse",
		"body": [
			"sort(${1:name}.begin(), ${1:name}.end(), greater<${2:int}>());"
		],
		"description": "none"
	},
	"stemp": {
		"prefix": "stemp",
		"body": [
			"#include <bits/stdc++.h>",
			"int main() {",
			"\tstd::cin.tie(0); std::cin.sync_with_stdio(false);",
			"\t$0",
			"\treturn 0;",
			"}"
		],
		"description": "none"
	},
	"upper bound": {
		"prefix": "upper bound",
		"body": [
			"std::upper_bound(${1:name}.begin(), ${1:おname.end(), ${2:きじゅんち});"
		],
		"description": "none"
	},
	"vec": {
		"prefix": "vec",
		"body": [
			"std::vector<${1:int}> ${2:name}(${3:n});$0"
		],
		"description": "none"
	},
	"vecpair": {
		"prefix": "vecpair",
		"body": [
			"std::vector<std::pair<${1:int}, ${2:int}>> ${3:name}(${4:n}, {${5:0}, ${6:0}})$0;"
		],
		"description": "none"
	},
	"vecvec": {
		"prefix": "vecvec",
		"body": [
			"std::vector<std::vector<${1:int}>> ${2:grh}($0);"
		],
		"description": "none"
	},
	"vecvecpair": {
		"prefix": "vecvecpair",
		"body": [
			"std::vector<std::vector<std::pair<${1:int}, ${2:int}>>> ${3:name}(${4:h}, std::vector<std::pair<${1:int}, ${2:int}>>(${5:w}, {${6:0}, ${7:0}}))$0;"
		],
		"description": "none"
	},
	"binary indexed tree": {
		"prefix": "binary indexed tree",
		"body": [
			"template <typename T>",
			"class binary_indexed_tree {",
			"\t\tsize_t sz;",
			"\t\tstd::vector<T> tr;",
			"\t\tstd::function<T(T, T)> sum;",
			"\t\tstd::function<T(T, T)> dif;",
			"\t\tT id;",
			"\tpublic:",
			"\t\tbinary_indexed_tree (",
			"\t\t\t\tsize_t n,",
			"\t\t\t\tstd::function<T(T, T)> sum,",
			"\t\t\t\tstd::function<T(T, T)> dif,",
			"\t\t\t\tT id",
			"\t\t\t) :",
			"\t\t\tsz(n), tr(n, id),",
			"\t\t\tsum(sum), dif(dif), id(id)",
			"\t\t\t{}",
			"\t\tauto cum (size_t r) const -> T {",
			"\t\t\tassert(0 <= r && r <= sz);",
			"\t\t\tint k = (int)r;",
			"\t\t\tk--;",
			"\t\t\tT ret = 0;",
			"\t\t\tfor (; k >= 0; k &= k + 1, k--) ret = sum(ret, tr[k]);",
			"\t\t\treturn ret;",
			"\t\t}",
			"\t\tauto query (size_t l, size_t r) const -> T {",
			"\t\t\tassert(0 <= l && l <= r && r <= sz);",
			"\t\t\treturn dif(query(0, r), query(0, l));",
			"\t\t}",
			"\t\tauto operator[] (size_t i) const -> T {",
			"\t\t\tassert(0 <= i && i < sz);",
			"\t\t\treturn query(i, i + 1);",
			"\t\t}",
			"\t\tauto at (size_t i) const -> T {",
			"\t\t\treturn operator[](i);",
			"\t\t}",
			"\t\tvoid add (size_t i, T x) {",
			"\t\t\tfor (; i < sz; i |= i + 1) tr[i] = sum(tr[i], x);",
			"\t\t}",
			"\t\tvoid print(std::string name = \"bit\") {",
			"\t\t\tstd::cout << name << \": \";",
			"\t\t\tfor (size_t i = 0; i < sz; i++) {",
			"\t\t\t\tif (i) std::cout << \" \";",
			"\t\t\t\tstd::cout << operator[](i);",
			"\t\t\t}",
			"\t\t\tstd::cout << std::endl;",
			"\t\t}",
			"}"
		],
		"description": "none"
	},
	"compressed segment tree": {
		"prefix": "compressed segment tree",
		"body": [
			"template<typename T, typename U>",
			"class compressed_segment_tree {",
			"\tconst std::vector<T> a;",
			"\tconst size_t sz, Sz;",
			"\tstd::vector<U> seg;",
			"\tconst std::function<U(U, U)> o;",
			"\tconst U id;",
			"\tinline auto find (T k) const {",
			"\t\tauto it = std::lower_bound(a.begin(), a.end(), k);",
			"\t\tassert(it != a.end() && *it == k);",
			"\t\treturn it - a.begin() + sz;",
			"\t}",
			"\tpublic:",
			"\t\tcompressed_segment_tree (",
			"\t\t\t\tconst std::vector<T> a,",
			"\t\t\t\tconst std::function<U(U, U)> o,",
			"\t\t\t\tconst U id",
			"\t\t\t) :",
			"\t\t\ta(a),",
			"\t\t\tsz([&](){",
			"\t\t\t\t\tsize_t ret = 1;",
			"\t\t\t\t\tfor (; ret < a.size(); ret <<= 1) {}",
			"\t\t\t\t\treturn ret;",
			"\t\t\t\t}()),",
			"\t\t\tSz(sz << 1),",
			"\t\t\tseg(Sz, id),",
			"\t\t\to(o),",
			"\t\t\tid(id)",
			"\t\t\t{",
			"\t\t\t}",
			"\t\tvoid update (T x, const U& y) {",
			"\t\t\tauto k = find(x);",
			"\t\t\tseg[k] = y;",
			"\t\t\twhile(k >>= 1) {",
			"\t\t\t\tseg[k] = o(seg[2 * k], seg[2 * k + 1]);",
			"\t\t\t}",
			"\t\t}",
			"\t\tvoid add (T x, const U& y) {",
			"\t\t\tupdate(x, at(x) + y);",
			"\t\t}",
			"\t\tU query (T l, T r) {",
			"\t\t\tl = std::lower_bound(a.begin(), a.end(), l) - a.begin();",
			"\t\t\tr = std::lower_bound(a.begin(), a.end(), r) - a.begin();",
			"\t\t\tU L = id, R = id;",
			"\t\t\tfor(l += sz, r += sz; l < r; l >>= 1, r >>= 1) {",
			"\t\t\t\tif(l & 1) L = o(L, seg[l++]);",
			"\t\t\t\tif(r & 1) R = o(seg[--r], R);",
			"\t\t\t}",
			"\t\t\treturn o(L, R);",
			"\t\t}",
			"\t\tU at (T x) const {",
			"\t\t\treturn seg[find(x)];",
			"\t\t}",
			"\t\tvoid print () const {",
			"\t\t\tint n = a.size();",
			"\t\t\tstd::cout << std::setw(4) << \"----\"; for (int i = 0; i < n; i++) std::cout << std::setw(4) << \"----\" ; std::cout << std::endl;",
			"\t\t\tstd::cout << std::setw(4) << \"\"; for (auto const& e : a) std::cout << std::setw(4) << e; std::cout << std::endl;",
			"\t\t\tstd::cout << std::setw(4) << \"----\"; for (int i = 0; i < n; i++) std::cout << std::setw(4) << \"----\" ; std::cout << std::endl;",
			"\t\t\tstd::cout << std::setw(4) << \"val\"; for (auto const& e : a) std::cout << std::setw(4) << at(e); std::cout << std::endl;",
			"\t\t\tstd::cout << std::setw(4) << \"----\"; for (int i = 0; i < n; i++) std::cout << std::setw(4) << \"----\" ; std::cout << std::endl;",
			"\t\t}",
			"};"
		],
		"description": "none"
	},
	"disjoint set": {
		"prefix": "disjoint set",
		"body": [
			"class disjoint_set {",
			"\tint n;",
			"\tstd::vector<int> prt;",
			"\tpublic:",
			"\t\tdisjoint_set (int n)",
			"\t\t\t: n(n), prt(n, -1)",
			"\t\t\t{",
			"\t\t\t}",
			"\t\t\tinline bool is_root (int x) const {",
			"\t\t\t\treturn prt[x] < 0;",
			"\t\t\t}",
			"\t\t\tinline int size (int x) {",
			"\t\t\t\treturn -prt[find(x)];",
			"\t\t\t}",
			"\t\t\tinline bool equiv (int x, int y) {",
			"\t\t\t\treturn find(x) == find(y);",
			"\t\t\t}",
			"\t\t\tint find (int x) {",
			"\t\t\t\treturn (is_root(x) ? x : (prt[x] = find(prt[x])));",
			"\t\t\t}",
			"\t\t\tinline bool unite (int x, int y) {",
			"\t\t\t\tx = find(x); y = find(y);",
			"\t\t\t\tif (x == y) return false;",
			"\t\t\t\tif (size(x) < size(y)) std::swap(x, y);",
			"\t\t\t\tprt[x] += prt[y];",
			"\t\t\t\tprt[y] = x;",
			"\t\t\t\treturn true;",
			"\t\t\t}",
			"};"
		],
		"description": "none"
	},
	"disjoint sparse table": {
		"prefix": "disjoint sparse table",
		"body": [
			"template <typename T>",
			"class disjoint_sparse_table {",
			"\tconst int n, ht;",
			"\tconst std::vector<int> msb;",
			"\tconst std::function<T(T, T)> o;",
			"\tconst std::vector<std::vector<T>> tab;",
			"\tpublic:",
			"\t\tdisjoint_sparse_table (",
			"\t\t\t\tconst std::vector<T> a,",
			"\t\t\t\tconst std::function<T(T, T)> o",
			"\t\t\t) :",
			"\t\t\tn(a.size()),",
			"\t\t\tht([&](){",
			"\t\t\t\t\tint ret = 1;",
			"\t\t\t\t\tfor (int b = 2; b < n; b <<= 1) ret++;",
			"\t\t\t\t\treturn ret;",
			"\t\t\t\t}()),",
			"\t\t\tmsb([&](){",
			"\t\t\t\t\tint N = 1 << ht;",
			"\t\t\t\t\tauto ret = std::vector<int>(N, 0); ret[0] = -1;",
			"\t\t\t\t\tfor (int i = 2; i < N; i++) ret[i] = ret[i >> 1] + 1;",
			"\t\t\t\t\treturn ret;",
			"\t\t\t\t}()),",
			"\t\t\to(o),",
			"\t\t\ttab([&](){",
			"\t\t\t\t\tauto ret = std::vector<std::vector<T>>(ht, a);",
			"\t\t\t\t\tfor (int i = 1; i < ht; i++) {",
			"\t\t\t\t\t\tint p = 1 << i; int P = p << 1;",
			"\t\t\t\t\t\tfor (int s = 0; s < n; s += P) {",
			"\t\t\t\t\t\t\tint t = min(s + p, n);",
			"\t\t\t\t\t\t\tfor (int j = t - 2; j >= s; j--) ret[i][j] = o(a[j], ret[i][j + 1]);",
			"\t\t\t\t\t\t\tfor (int j = t + 1; j < min(s + P, n); j++) ret[i][j] = o(ret[i][j - 1], a[j]);",
			"\t\t\t\t\t\t}",
			"\t\t\t\t\t}",
			"\t\t\t\t\treturn ret;",
			"\t\t\t\t}())",
			"\t\t\t{",
			"\t\t\t}",
			"\t\tauto query (",
			"\t\t\t\tint l,",
			"\t\t\t\tint r",
			"\t\t\t) -> T",
			"\t\t\t{",
			"\t\t\t\tassert(l <= --r);",
			"\t\t\t\tint m = msb[l ^ r];",
			"\t\t\t\treturn m == -1 ? tab[0][l] : o(tab[m][l], tab[m][r]);",
			"\t\t\t}",
			"};"
		],
		"description": "none"
	},
	"lazy segment tree": {
		"prefix": "lazy segment tree",
		"body": [
			"template<typename T, typename U>",
			"struct range_minimum_query {",
			"\tconst T id;",
			"\tconst std::function<T(T, T)> merge_function;",
			"\tconst std::function<void(U&)> twice;",
			"\tconst std::function<U(U)> half;",
			"\trange_minimum_query(T id):",
			"\t\tid(id),",
			"\t\tmerge_function ([](T a, T b) {return min(a, b);}),",
			"\t\ttwice ([](U& a) {}),",
			"\t\thalf ([](U a) {return a;})",
			"\t\t{",
			"\t\t}",
			"};",
			"template<typename T, typename U>",
			"struct range_maximum_query {",
			"\tconst T id;",
			"\tconst std::function<T(T, T)> merge_function;",
			"\tconst std::function<void(U&)> twice;",
			"\tconst std::function<U(U)> half;",
			"\trange_maximum_query(T id):",
			"\t\tid(id),",
			"\t\tmerge_function ([](T a, T b) {return max(a, b);}),",
			"\t\ttwice ([](U& a) {}),",
			"\t\thalf ([](U a) {return a;})",
			"\t\t{",
			"\t\t}",
			"};",
			"template<typename T, typename U>",
			"struct range_sum_query {",
			"\tconst T id;",
			"\tconst std::function<T(T, T)> merge_function;",
			"\tconst std::function<void(U&)> twice;",
			"\tconst std::function<U(U)> half;",
			"\trange_sum_query(T id = 0):",
			"\t\tid(id),",
			"\t\tmerge_function ([](T a, T b) {return a + b;}),",
			"\t\ttwice ([](U& a) {a *= 2;}),",
			"\t\thalf ([](U a) {return a / 2;})",
			"\t\t{",
			"\t\t}",
			"};",
			"template<typename T, typename U>",
			"struct range_update_query {",
			"\t\tconst U id;",
			"\t\tconst std::function<void(T&, U)> action;",
			"\t\tconst std::function<void(U&, U)> composition;",
			"\tpublic:",
			"\t\trange_update_query(U id = 0):",
			"\t\t\tid(id),",
			"\t\t\taction ([](T& a, U b) {a = b;}),",
			"\t\t\tcomposition ([](U& a, U b) {a = b;})",
			"\t\t\t{",
			"\t\t\t}",
			"};",
			"template<typename T, typename U>",
			"struct range_add_query {",
			"\t\tconst U id;",
			"\t\tconst std::function<void(T&, U)> action;",
			"\t\tconst std::function<void(U&, U)> composition;",
			"\tpublic:",
			"\t\trange_add_query(U id = 0):",
			"\t\t\tid(id),",
			"\t\t\taction ([](T& a, U b) {a += b;}),",
			"\t\t\tcomposition ([](U& a, U b) {a += b;})",
			"\t\t\t{",
			"\t\t\t}",
			"};",
			"template<typename T, typename U>",
			"class lazy_segment_tree {",
			"\tint sz;",
			"\tint Sz;",
			"\tint ht;",
			"\tstd::vector<T> seg;",
			"\tstd::vector<U> act;",
			"\tstd::vector<bool> has_act;",
			"\tconst std::function<T(T, T)> o;",
			"\tconst std::function<void(T&, U)> oo;",
			"\tconst std::function<void(U&, U)> ooo;",
			"\tconst std::function<void(U&)> twice;",
			"\tconst std::function<U(U)> half;",
			"\tconst T tid;",
			"\tconst U uid;",
			"\t",
			"\tpublic:",
			"\t\tlazy_segment_tree(",
			"\t\t\t\tint n,",
			"\t\t\t\tconst std::function<T(T, T)> merge_function,",
			"\t\t\t\tconst std::function<void(T&, U)> action,",
			"\t\t\t\tconst std::function<void(U&, U)> composition,",
			"\t\t\t\tconst std::function<void(U&)> twice,",
			"\t\t\t\tconst std::function<U(U)> half,",
			"\t\t\t\tconst T seg_id,",
			"\t\t\t\tconst U act_id",
			"\t\t\t)",
			"\t\t\t\t: o(merge_function)",
			"\t\t\t\t, oo(action)",
			"\t\t\t\t, ooo(composition)",
			"\t\t\t\t, twice(twice)",
			"\t\t\t\t, half(half)",
			"\t\t\t\t, tid(seg_id)",
			"\t\t\t\t, uid(act_id)",
			"\t\t\t{",
			"\t\t\t\tht = 1, sz = 1;",
			"\t\t\t\twhile(sz < n) ht++, sz <<= 1;",
			"\t\t\t\tSz = sz << 1;",
			"\t\t\t\tseg.assign(Sz, tid);",
			"\t\t\t\tact.resize(Sz, act_id);",
			"\t\t\t\thas_act.assign(Sz, false);",
			"\t\t\t}",
			"\t\t",
			"\t\tlazy_segment_tree(",
			"\t\t\t\tconst std::vector<T>& data,",
			"\t\t\t\tconst std::function<T(T, T)> merge_function,",
			"\t\t\t\tconst std::function<void(T&, U)> action,",
			"\t\t\t\tconst std::function<void(U&, U)> composition,",
			"\t\t\t\tconst std::function<void(U&)> twice,",
			"\t\t\t\tconst std::function<U(U)> half,",
			"\t\t\t\tconst T seg_id,",
			"\t\t\t\tconst U act_id",
			"\t\t\t)",
			"\t\t\t\t: lazy_segment_tree(",
			"\t\t\t\t\t\tdata.size(),",
			"\t\t\t\t\t\tmerge_function,",
			"\t\t\t\t\t\taction,",
			"\t\t\t\t\t\tcomposition,",
			"\t\t\t\t\t\ttwice,",
			"\t\t\t\t\t\thalf,",
			"\t\t\t\t\t\tseg_id,",
			"\t\t\t\t\t\tact_id",
			"\t\t\t\t\t)",
			"\t\t\t{",
			"\t\t\t\tcopy(data.begin(), data.end(), seg.begin() + sz);",
			"\t\t\t\tfor (int i = sz - 1; i >= 1; i--) seg[i] = o(seg[i << 1], seg[(i << 1) + 1]);",
			"\t\t\t}",
			"\t\t",
			"\t\ttemplate<typename V, typename M, typename A>",
			"\t\tlazy_segment_tree(",
			"\t\t\t\tconst V n_or_v,",
			"\t\t\t\tconst M& merge_instance,",
			"\t\t\t\tconst A& action_instance",
			"\t\t\t)",
			"\t\t\t\t: lazy_segment_tree(",
			"\t\t\t\t\tn_or_v,",
			"\t\t\t\t\tmerge_instance.merge_function,",
			"\t\t\t\t\taction_instance.action,",
			"\t\t\t\t\taction_instance.composition,",
			"\t\t\t\t\tmerge_instance.twice,",
			"\t\t\t\t\tmerge_instance.half,",
			"\t\t\t\t\tmerge_instance.id,",
			"\t\t\t\t\taction_instance.id",
			"\t\t\t\t)",
			"\t\t\t{",
			"\t\t\t}",
			"\t\t",
			"\t\tinline int lft (int i) {return i << 1;}",
			"\t\tinline int rgt (int i) {return (i << 1) + 1;}",
			"\t\tinline int upp (int i) {return i >> 1;}",
			"",
			"\t\tinline void propagate (",
			"\t\t\t\tint k,",
			"\t\t\t\tint L,",
			"\t\t\t\tint R",
			"\t\t\t)",
			"\t\t\t{",
			"\t\t\t\tif (has_act[k]) {",
			"\t\t\t\t\too(seg[k], act[k]);",
			"\t\t\t\t\tif (k < sz) {",
			"\t\t\t\t\t\tooo(act[lft(k)], half(act[k]));",
			"\t\t\t\t\t\tooo(act[rgt(k)], half(act[k]));",
			"\t\t\t\t\t\thas_act[lft(k)] = has_act[rgt(k)] = true;",
			"\t\t\t\t\t}",
			"\t\t\t\t\tact[k] = uid, has_act[k] = false;",
			"\t\t\t\t}",
			"\t\t\t}",
			"",
			"\t\tvoid update (",
			"\t\t\t\tint l,",
			"\t\t\t\tint r,",
			"\t\t\t\tT x,",
			"\t\t\t\tint k = 1,",
			"\t\t\t\tint L = 0,",
			"\t\t\t\tint R = -1",
			"\t\t\t)",
			"\t\t\t{",
			"\t\t\t\tif (R == -1) R = sz;",
			"\t\t\t\tif (k == 1) for (int i = 0; i < ht - 1; i++) twice(x);",
			"\t\t\t\tpropagate(k, L, R);",
			"\t\t\t\tif (R <= l || r <= L) return;",
			"\t\t\t\tif (l <= L && R <= r) {",
			"\t\t\t\t\tooo(act[k], x), has_act[k] = true;",
			"\t\t\t\t\tpropagate(k, L, R);",
			"\t\t\t\t} else {",
			"\t\t\t\t\tint C = (L + R) >> 1;",
			"\t\t\t\t\tupdate(l, r, half(x), lft(k), L, C);",
			"\t\t\t\t\tupdate(l, r, half(x), rgt(k), C, R);",
			"\t\t\t\t\tseg[k] = o(seg[lft(k)], seg[rgt(k)]);",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t",
			"\t\tT query (",
			"\t\t\t\tint l,",
			"\t\t\t\tint r,",
			"\t\t\t\tint k = 1,",
			"\t\t\t\tint L = 0,",
			"\t\t\t\tint R = -1",
			"\t\t\t)",
			"\t\t\t{",
			"\t\t\t\tif (R == -1) R = sz;",
			"\t\t\t\tpropagate(k, L, R);",
			"\t\t\t\tif (R <= l || r <= L) return tid;",
			"\t\t\t\tif (l <= L && R <= r) {",
			"\t\t\t\t\tpropagate(k, L, R);",
			"\t\t\t\t\treturn seg[k];",
			"\t\t\t\t} else {",
			"\t\t\t\t\tint C = (L + R) >> 1;",
			"\t\t\t\t\tT lv = query(l, r, lft(k), L, C);",
			"\t\t\t\t\tT rv = query(l, r, rgt(k), C, R);",
			"\t\t\t\t\tseg[k] = o(seg[lft(k)], seg[rgt(k)]);",
			"\t\t\t\t\treturn o(lv, rv);",
			"\t\t\t\t}",
			"\t\t\t}",
			"",
			"\t\tvoid print(int w = 4) {",
			"\t\t\tfor (int i(1), last(2), output_size(w << ht); last <= Sz; last <<= 1, output_size >>= 1) {",
			"\t\t\t\tfor (; i < last; i++) {",
			"\t\t\t\t\tstd::cout << std::right << std::setw(w);",
			"\t\t\t\t\tstd::cout << (seg[i] != tid ? to_string(seg[i]) : \"\");",
			"\t\t\t\t\tstd::cout << std::setw(2) <<\t\"<\";",
			"\t\t\t\t\tstd::cout << left << std::setw(output_size - w - 2);",
			"\t\t\t\t\tstd::cout << (has_act[i] ? to_string(act[i]) : \"\");",
			"\t\t\t\t}",
			"\t\t\t\tstd::cout << std::endl;",
			"\t\t\t}",
			"\t\t}",
			"};"
		],
		"description": "none"
	},
	"potential disjoint set": {
		"prefix": "potential disjoint set",
		"body": [
			"class potential_disjoint_set {",
			"\tpublic:",
			"\tstd::vector<int> rank, prt, ptl;",
			"\tpotential_disjoint_set (int size) {",
			"\t\trank.resize(size);",
			"\t\tprt.resize(size);",
			"\t\tptl.resize(size);",
			"\t\tfor (int i = 0; i < size; i++) {",
			"\t\t\tprt[i] = i;",
			"\t\t\trank[i] = 0;",
			"\t\t\tptl[i] = 0;",
			"\t\t}",
			"\t}",
			"\tint find (int x) {",
			"\t\tif (x == prt[x]){",
			"\t\t\treturn x;",
			"\t\t} else {",
			"\t\t\tint r = find(prt[x]);",
			"\t\t\tptl[x] += ptl[prt[x]];",
			"\t\t\treturn prt[x] = r;",
			"\t\t}",
			"\t}",
			"\tbool is_equiv (int x, int y) {",
			"\t\treturn find(x) == find(y);",
			"\t}",
			"\tbool unite (int x, int y, int w) {",
			"\t\tif (find(x) == find(y)) {",
			"\t\t\treturn false;",
			"\t\t}",
			"\t\tw += ptl[x];",
			"\t\tw -= ptl[y];",
			"\t\tx = find(x);",
			"\t\ty = find(y);",
			"\t\tif (rank[x] < rank[y]) {",
			"\t\t\tstd::swap(x, y);",
			"\t\t\tw *= -1;",
			"\t\t}",
			"\t\tprt[y] = x;",
			"\t\tptl[y] = w;",
			"\t\tif (rank[x] == rank[y]) {",
			"\t\t\trank[x]++;",
			"\t\t}",
			"\t\treturn true;",
			"\t}",
			"\tint diff (int x, int y) {",
			"\t\tfind(x);",
			"\t\tfind(y);",
			"\t\treturn ptl[y] - ptl[x];",
			"\t}",
			"};"
		],
		"description": "none"
	},
	"segment tree": {
		"prefix": "segment tree",
		"body": [
			"template<typename T>",
			"class segment_tree {",
			"\tconst size_t n, sz, Sz;",
			"\tstd::vector<T> seg;",
			"\tconst std::function<T(T, T)> o;",
			"\tconst T id;",
			"\tpublic:",
			"\t\tsegment_tree (",
			"\t\t\t\tconst size_t n,",
			"\t\t\t\tconst std::function<T(T, T)> o,",
			"\t\t\t\tconst T id",
			"\t\t\t) :",
			"\t\t\tn(n),",
			"\t\t\tsz([&](){",
			"\t\t\t\t\tsize_t p = 1;",
			"\t\t\t\t\tfor (; p < n; p <<= 1) {}",
			"\t\t\t\t\treturn p;",
			"\t\t\t\t}()),",
			"\t\t\tSz(sz << 1),",
			"\t\t\tseg(Sz, id),",
			"\t\t\to(o),",
			"\t\t\tid(id)",
			"\t\t\t{",
			"\t\t\t}",
			"\t\tvoid update (size_t k, const T& x) {",
			"\t\t\tk += sz;",
			"\t\t\tseg[k] = x;",
			"\t\t\twhile(k >>= 1) {",
			"\t\t\t\tseg[k] = o(seg[2 * k], seg[2 * k + 1]);",
			"\t\t\t}",
			"\t\t}",
			"\t\tvoid add (size_t x, const T& y) {",
			"\t\t\tupdate(x, at(x) + y);",
			"\t\t}",
			"\t\tT query (size_t l, size_t r) {",
			"\t\t\tT L = id, R = id;",
			"\t\t\tfor(l += sz, r += sz; l < r; l >>= 1, r >>= 1) {",
			"\t\t\t\tif(l & 1) L = o(L, seg[l++]);",
			"\t\t\t\tif(r & 1) R = o(seg[--r], R);",
			"\t\t\t}",
			"\t\t\treturn o(L, R);",
			"\t\t}",
			"\t\tT at (const size_t &x) const {",
			"\t\t\treturn seg[x + sz];",
			"\t\t}",
			"\t\tvoid print() {",
			"\t\t\tstd::cout << std::setw(4) << \"----\"; for (size_t i = 0; i < n; i++) std::cout << std::setw(4) << \"----\" ; std::cout << std::endl;",
			"\t\t\tstd::cout << std::setw(4) << \"\"; for (size_t i = 0; i < n; i++) std::cout << std::setw(4) << i; std::cout << std::endl;",
			"\t\t\tstd::cout << std::setw(4) << \"----\"; for (size_t i = 0; i < n; i++) std::cout << std::setw(4) << \"----\" ; std::cout << std::endl;",
			"\t\t\tstd::cout << std::setw(4) << \"val\"; for (size_t i = 0; i < n; i++) std::cout << std::setw(4) << seg[i + sz]; std::cout << std::endl;",
			"\t\t\tstd::cout << std::setw(4) << \"----\"; for (size_t i = 0; i < n; i++) std::cout << std::setw(4) << \"----\" ; std::cout << std::endl;",
			"\t\t}",
			"};"
		],
		"description": "none"
	},
	"sparse table": {
		"prefix": "sparse table",
		"body": [
			"template <typename T>",
			"class sparse_table {",
			"\tconst int n, ht;",
			"\tconst std::vector<int> msb;",
			"\tconst std::function<T(T, T)> o;",
			"\tconst std::vector<std::vector<T>> tab;",
			"\tpublic:",
			"\t\tsparse_table (",
			"\t\t\t\tstd::vector<T> a,",
			"\t\t\t\tstd::function<T(T, T)> o",
			"\t\t\t) :",
			"\t\t\tn(a.size()),",
			"\t\t\tht([&](){",
			"\t\t\t\t\tint ret = 1;",
			"\t\t\t\t\tfor (int b = 2; b < n; b <<= 1) ret++;",
			"\t\t\t\t\treturn ret;",
			"\t\t\t\t}()),",
			"\t\t\tmsb([&](){",
			"\t\t\t\t\tint N = 1 << ht;",
			"\t\t\t\t\tauto ret = std::vector<int>(N, 0); ret[0] = -1;",
			"\t\t\t\t\tfor (int i = 2; i < N; i++) ret[i] = ret[i >> 1] + 1;",
			"\t\t\t\t\treturn ret;",
			"\t\t\t\t}()),",
			"\t\t\to(o),",
			"\t\t\ttab([&](){",
			"\t\t\t\t\tauto ret = std::vector<std::vector<T>>(ht, a);",
			"\t\t\t\t\tfor (int i = 1, p = 1; i < ht; i++, p <<= 1) {",
			"\t\t\t\t\t\tfor (int j = 0; j < n; j++) {",
			"\t\t\t\t\t\t\tret[i][j] = o(ret[i - 1][j], ret[i - 1][min(j + p, n - 1)]);",
			"\t\t\t\t\t\t}",
			"\t\t\t\t\t}",
			"\t\t\t\t\treturn ret;",
			"\t\t\t\t}())",
			"\t\t\t{",
			"\t\t\t}",
			"\t\tauto query (",
			"\t\t\t\tint l,",
			"\t\t\t\tint r",
			"\t\t\t) -> T",
			"\t\t\t{",
			"\t\t\t\tassert(0 <= l && l < r && r <= n);",
			"\t\t\t\tint i = msb[r - l];",
			"\t\t\t\treturn o(tab[i][l], tab[i][r - (1 << i)]);",
			"\t\t\t}",
			"};"
		],
		"description": "none"
	},
	"-pdbg": {
		"prefix": "-pdbg",
		"body": [
			"std::cout << \"(\" << ${1:name}${2:->}first << \", \" << $1$2second << \")\";"
		],
		"description": "none"
	},
	"-ppdbg": {
		"prefix": "-ppdbg",
		"body": [
			"std::cout << \"(\" << get<0>(${1:*it}) << \", \" << get<1>($1) << \", \" << get<2>($1) << \")\";"
		],
		"description": "none"
	},
	"-sdbg": {
		"prefix": "-sdbg",
		"body": [
			"std::cout << ${1:name};"
		],
		"description": "none"
	},
	"1dbg": {
		"prefix": "1dbg",
		"body": [
			"{ // debug",
			"\tstd::cout << \"${1:a} = \" << $1 << std::endl;",
			"} //"
		],
		"description": "none"
	},
	"1prompt": {
		"prefix": "1prompt",
		"body": [
			"std::cout << \"${2:a} > \";",
			"${1:int} $2;",
			"std::cin >> $2;"
		],
		"description": "none"
	},
	"1vdebug": {
		"prefix": "1vdebug",
		"body": [
			"{ // debug",
			"\tint n = 0;",
			"\tif (n < (int)${1:name}.size()) n = $1.size();",
			"\tstd::cout << std::setw(4) << \"----\"; for (int i = 0; i < n; i++) std::cout << std::setw(4) << \"----\" ; std::cout << std::endl;",
			"\tstd::cout << std::setw(4) << \"\"; for (int i = 0; i < n; i++) std::cout << std::setw(4) << i; std::cout << std::endl;",
			"\tstd::cout << std::setw(4) << \"----\"; for (int i = 0; i < n; i++) std::cout << std::setw(4) << \"----\" ; std::cout << std::endl;",
			"\tstd::cout << std::setw(4) << \"$1\"; for (auto const& e : $1) std::cout << std::setw(4) << e; std::cout << std::endl;",
			"\tstd::cout << std::setw(4) << \"----\"; for (int i = 0; i < n; i++) std::cout << std::setw(4) << \"----\" ; std::cout << std::endl;",
			"} //"
		],
		"description": "none"
	},
	"2dbg": {
		"prefix": "2dbg",
		"body": [
			"{ // debug",
			"\tstd::cout",
			"\t\t<< \"${1:a} = \" << $1 << \", \"",
			"\t\t<< \"${2:b} = \" << $2",
			"\t\t<< std::endl;",
			"} //"
		],
		"description": "none"
	},
	"2prpmpt": {
		"prefix": "2prpmpt",
		"body": [
			"std::cout << \"${2:a}, ${3:b} > \";",
			"${1:int} $2, $3;",
			"std::cin >> $2 >> $3;"
		],
		"description": "none"
	},
	"2vdebug": {
		"prefix": "2vdebug",
		"body": [
			"{ // debug",
			"\tint n = 0;",
			"\tif (n < (int)${1:name}.size()) n = $1.size();",
			"\tif (n < (int)${2:name}.size()) n = $2.size();",
			"\tstd::cout << std::setw(4) << \"----\"; for (int i = 0; i < n; i++) std::cout << std::setw(4) << \"----\" ; std::cout << std::endl;",
			"\tstd::cout << std::setw(4) << \"\"; for (int i = 0; i < n; i++) std::cout << std::setw(4) << i; std::cout << std::endl;",
			"\tstd::cout << std::setw(4) << \"----\"; for (int i = 0; i < n; i++) std::cout << std::setw(4) << \"----\" ; std::cout << std::endl;",
			"\tstd::cout << std::setw(4) << \"$1\"; for (auto const& e : $1) std::cout << std::setw(4) << e; std::cout << std::endl;",
			"\tstd::cout << std::setw(4) << \"$2\"; for (auto const& e : $2) std::cout << std::setw(4) << e; std::cout << std::endl;",
			"\tstd::cout << std::setw(4) << \"----\"; for (int i = 0; i < n; i++) std::cout << std::setw(4) << \"----\" ; std::cout << std::endl;",
			"} //"
		],
		"description": "none"
	},
	"3dbg": {
		"prefix": "3dbg",
		"body": [
			"{ // debug",
			"\tstd::cout",
			"\t\t<< \"${1:a} = \" << $1 << \", \"",
			"\t\t<< \"${2:b} = \" << $2 << \", \"",
			"\t\t<< \"${3:c} = \" << $3",
			"\t\t<< std::endl;",
			"} //"
		],
		"description": "none"
	},
	"3prompt": {
		"prefix": "3prompt",
		"body": [
			"std::cout << \"${2:a}, ${3:b}, ${4:c} > \";",
			"${1:int} $2, $3, $4;",
			"std::cin >> $2 >> $3 >> $4;"
		],
		"description": "none"
	},
	"3vdebug": {
		"prefix": "3vdebug",
		"body": [
			"{ // debug",
			"\tint n = 0;",
			"\tif (n < (int)${1:name}.size()) n = $1.size();",
			"\tif (n < (int)${2:name}.size()) n = $2.size();",
			"\tif (n < (int)${3:name}.size()) n = $3.size();",
			"\tstd::cout << std::setw(4) << \"----\"; for (int i = 0; i < n; i++) std::cout << std::setw(4) << \"----\" ; std::cout << std::endl;",
			"\tstd::cout << std::setw(4) << \"\"; for (int i = 0; i < n; i++) std::cout << std::setw(4) << i; std::cout << std::endl;",
			"\tstd::cout << std::setw(4) << \"----\"; for (int i = 0; i < n; i++) std::cout << std::setw(4) << \"----\" ; std::cout << std::endl;",
			"\tstd::cout << std::setw(4) << \"$1\"; for (auto const& e : $1) std::cout << std::setw(4) << e; std::cout << std::endl;",
			"\tstd::cout << std::setw(4) << \"$2\"; for (auto const& e : $2) std::cout << std::setw(4) << e; std::cout << std::endl;",
			"\tstd::cout << std::setw(4) << \"$3\"; for (auto const& e : $3) std::cout << std::setw(4) << e; std::cout << std::endl;",
			"\tstd::cout << std::setw(4) << \"----\"; for (int i = 0; i < n; i++) std::cout << std::setw(4) << \"----\" ; std::cout << std::endl;",
			"} //"
		],
		"description": "none"
	},
	"4dbg": {
		"prefix": "4dbg",
		"body": [
			"{ // debug",
			"\tstd::cout",
			"\t\t<< \"${1:a} = \" << $1 << \", \"",
			"\t\t<< \"${2:b} = \" << $2 << \", \"",
			"\t\t<< \"${3:c} = \" << $3 << \", \"",
			"\t\t<< \"${4:d} = \" << $4",
			"\t\t<< std::endl;",
			"} //"
		],
		"description": "none"
	},
	"4vdebug": {
		"prefix": "4vdebug",
		"body": [
			"{ // debug",
			"\tint n = 0;",
			"\tif (n < (int)${1:name}.size()) n = $1.size();",
			"\tif (n < (int)${2:name}.size()) n = $2.size();",
			"\tif (n < (int)${3:name}.size()) n = $3.size();",
			"\tstd::cout << std::setw(4) << \"----\"; for (int i = 0; i < n; i++) std::cout << std::setw(4) << \"----\" ; std::cout << std::endl;",
			"\tstd::cout << std::setw(4) << \"\"; for (int i = 0; i < n; i++) std::cout << std::setw(4) << i; std::cout << std::endl;",
			"\tstd::cout << std::setw(4) << \"----\"; for (int i = 0; i < n; i++) std::cout << std::setw(4) << \"----\" ; std::cout << std::endl;",
			"\tstd::cout << std::setw(4) << \"$1\"; for (auto const& e : $1) std::cout << std::setw(4) << e; std::cout << std::endl;",
			"\tstd::cout << std::setw(4) << \"$2\"; for (auto const& e : $2) std::cout << std::setw(4) << e; std::cout << std::endl;",
			"\tstd::cout << std::setw(4) << \"$3\"; for (auto const& e : $3) std::cout << std::setw(4) << e; std::cout << std::endl;",
			"\tstd::cout << std::setw(4) << \"$4\"; for (auto const& e : $4) std::cout << std::setw(4) << e; std::cout << std::endl;",
			"\tstd::cout << std::setw(4) << \"----\"; for (int i = 0; i < n; i++) std::cout << std::setw(4) << \"----\" ; std::cout << std::endl;",
			"} //"
		],
		"description": "none"
	},
	"bug": {
		"prefix": "bug",
		"body": [
			"/* ↓ 消し忘れないで！！！ ↓ */",
			"$0",
			"/* ↑ いや振りじゃないから ↑ */"
		],
		"description": "none"
	},
	"check": {
		"prefix": "check",
		"body": [
			"printf(\"/%d\\n\", ${1:crr});",
			"printf(\"\\\\\\\\%d\\n\", ${1:crr});"
		],
		"description": "none"
	},
	"interval debug": {
		"prefix": "interval debug",
		"body": [
			"{ // debug",
			"\tstd::cout",
			"\t\t<< \"[\" << $1 << \", \" << $2 << \")\" << std::endl;",
			"} //"
		],
		"description": "none"
	},
	"map debug": {
		"prefix": "map debug",
		"body": [
			"{ // debug",
			"\tfor (auto ${2:it} = ${1:mp}.begin(); $2 != $1.end(); $2++) {",
			"\t\tstd::cout << \"mp[\";",
			"\t\tstd::cout << $0$2->first;",
			"\t\tstd::cout << \"] = \";",
			"\t\tstd::cout << $2->second;",
			"\t\tstd::cout << \"\" << (next($2) == $1.end() ? \"\\n\" : \", \");",
			"\t}",
			"} //"
		],
		"description": "none"
	},
	"ndbg": {
		"prefix": "ndbg",
		"body": [
			"std::cout << \"$0\" << std::endl;"
		],
		"description": "none"
	},
	"new line": {
		"prefix": "new line",
		"body": [
			"{ // debug",
			"\tstd::cout << std::endl;",
			"} //"
		],
		"description": "none"
	},
	"pdbg": {
		"prefix": "pdbg",
		"body": [
			"{ // debug",
			"\tstd::cout << \"${1:name} = (\" << $1${2:.}first << \", \" <<\t$1$2second << \")\" << std::endl;",
			"} //"
		],
		"description": "none"
	},
	"pretty debug": {
		"prefix": "pretty debug",
		"body": [
			"#define LOCAL",
			"using std::to_string;",
			"auto to_string(std::string s) -> std::string {",
			"\treturn '\"' + s + '\"';",
			"}",
			"auto to_string(const char* s) -> std::string {",
			"\treturn to_string((std::string) s);",
			"}",
			"auto to_string(bool b) -> std::string {",
			"\treturn (b ? \"true\" : \"false\");",
			"}",
			"template <typename T, typename U>",
			"auto to_string(std::pair<T, U> p) -> std::string {",
			"\treturn \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";",
			"}",
			"template <typename T>",
			"auto to_string(T v) -> std::string {",
			"\tbool flg = false;",
			"\tstd::string res = \"{\";",
			"\tfor (auto const&x : v) {",
			"\t\tif (flg) res += \", \";",
			"\t\telse flg = true;",
			"\t\tres += to_string(x);",
			"\t}",
			"\tres += \"}\";",
			"\treturn res;",
			"}",
			"void debug_out() { std::cerr << std::endl; }",
			"template <typename Head, typename... Tail>",
			"void debug_out(Head H, Tail... T) {",
			"\tstd::cerr << \" \" << to_string(H);",
			"\tdebug_out(T...);",
			"}",
			"#ifdef LOCAL",
			"#define debug(...) std::cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)",
			"#else",
			"#define debug(...) 42",
			"#endif"
		],
		"description": "none"
	},
	"vpdebug": {
		"prefix": "vpdebug",
		"body": [
			"{ // debug",
			"\tstd::cout << \"${1:name}: \";",
			"\tfor (auto ${2:it} = $1.begin(); $2 != $1.end(); $2++) {",
			"\t\tstd::cout << \"(\";",
			"\t\tstd::cout << $2->first;",
			"\t\tstd::cout << \", \";",
			"\t\tstd::cout << $2->second;",
			"\t\tstd::cout << \")\" << (next($2) == $1.end() ? \"\\n\" : \", \");",
			"\t}",
			"\tstd::cout << std::endl;",
			"} //"
		],
		"description": "none"
	},
	"vvdbg": {
		"prefix": "vvdbg",
		"body": [
			"{ // debug",
			"\tint h = ${1:name}.size(); int w = 0;",
			"\tint name_length = ${2:3}; int output_length = ${3:4};",
			"\tfor (int i = 0; i < h; i++) if (w < (int)$1[i].size()) w = $1[i].size();",
			"\tstd::cout << std::string(name_length, '-') << \"--\";",
			"\tfor (int j = 0; j < w; j++) std::cout << std::setw(${3:output length}) << \"----\";",
			"\tstd::cout << std::endl;",
			"\tstd::cout << std::setw(name_length) << std::right << \"$1\" << \"| \";",
			"\tfor (int j = 0; j < w; j++) std::cout << std::setw(output_length) << std::right <<\tj;",
			"\tstd::cout << std::endl;",
			"\tstd::cout << std::string(name_length, '-') << \"+-\";",
			"\tfor (int j = 0; j < w; j++) std::cout << std::string(output_length, '-');",
			"\tstd::cout << std::endl;",
			"\tfor (int i = 0; i < h; i++) {",
			"\t\tstd::cout << std::setw(name_length) << std::right << i << \"| \";",
			"\t\tfor (auto const& e : $1[i]) std::cout << std::setw(output_length) << std::right << (e == ${4:0} ? \"0\" : to_string(e));",
			"\t\tstd::cout << std::endl;",
			"\t}",
			"\tstd::cout << std::string(name_length, '-') << \"--\";",
			"\tfor (int j = 0; j < w; j++) std::cout << std::string(output_length, '-');",
			"\tstd::cout << std::endl;",
			"} //"
		],
		"description": "none"
	},
	"bellman ford": {
		"prefix": "bellman ford",
		"body": [
			"template <typename T>",
			"class bellman_ford {",
			"\tusing edge_t = tuple<T, int, int>;",
			"\tconst int n, r;",
			"\tconst std::vector<edge_t>& edg;",
			"\tbool flg;",
			"\tstd::vector<long long> dst;",
			"\tvoid cal () {",
			"\t\t\tdst[r] = 0;",
			"\t\t\tfor (int q = n; q--;) {",
			"\t\t\t\tflg = false;",
			"\t\t\t\tfor (auto const& e : edg) {",
			"\t\t\t\t\tT d; int s, t; std::tie(d, s, t) = e;",
			"\t\t\t\t\tif (dst[s] == inf) continue;",
			"\t\t\t\t\tif (cmn(dst[t], dst[s] + d)) flg = true;",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t}",
			"\tpublic:",
			"\t\tconst T inf;",
			"\t\tbellman_ford (",
			"\t\t\t\tconst int n, const int r,",
			"\t\t\t\tconst std::vector<edge_t>& edg,",
			"\t\t\t\tconst T inf = numeric_limits<T>::max()",
			"\t\t\t) :",
			"\t\t\tn(n), r(r), edg(edg), ",
			"\t\t\tflg(false), dst(n, inf), inf(inf)",
			"\t\t\t{",
			"\t\t\t\tcal();",
			"\t\t\t}",
			"\t\tbellman_ford (",
			"\t\t\t\tconst int n, const int r,",
			"\t\t\t\tconst std::vector<edge_t>& edg",
			"\t\t\t) :",
			"\t\t\tbellman_ford(n, r, edg, numeric_limits<T>::max())",
			"\t\t\t{",
			"\t\t\t}",
			"\t\tbool has_negative_cycle () const {return flg;}",
			"\t\tauto& result () {return dst;}",
			"};"
		],
		"description": "none"
	},
	"bipartite matching": {
		"prefix": "bipartite matching",
		"body": [
			"class bipartite_matching {",
			"\tint x, y;",
			"\tdinic<int> dnc;",
			"\tpublic:",
			"\t\tbipartite_matching(int x, int y) :",
			"\t\t\tx(x), y(y), dnc([x, y]{",
			"\t\t\t\tdinic<int> dnc(1 + x + y + 1, 0, 1 + x + y);",
			"\t\t\t\tfor (int i = 0; i < x; i++) dnc.insert(0, 1 + i, 1);",
			"\t\t\t\tfor (int j = 0; j < y; j++) dnc.insert(1 + x + j, 1 + x + y, 1);",
			"\t\t\t\treturn dnc;",
			"\t\t\t}())",
			"\t\t\t{}",
			"\t\tvoid insert (int i, int j) {",
			"\t\t\tdnc.insert(1 + i, 1 + x + j, 1);",
			"\t\t}",
			"\t\tint cal () {return dnc.cal();}",
			"};"
		],
		"description": "none"
	},
	"centroid": {
		"prefix": "centroid",
		"body": [
			"class centroid_tree {",
			"\tconst int n;",
			"\tconst std::vector<std::vector<int>> grh;",
			"\tstd::vector<bool> ckd;",
			"\tstd::vector<std::vector<int>> ctr;",
			"\tqueue<tuple<int, int, int>> que;",
			"\tint rt = -1;",
			"\tvoid build ()",
			"\t\t{",
			"\t\t\tstd::vector<int> sz(n);",
			"\t\t\tque.emplace(-1, 0, n);",
			"\t\t\twhile (!que.empty()) {",
			"\t\t\t\tint prv_ctr, start, bkt; std::tie(prv_ctr, start, bkt) = que.front(); que.pop();",
			"\t\t\t\tint new_ctr = -1;",
			"\t\t\t\tmake_fixed_point ([&](auto dfs, int crr, int prt) -> void {",
			"\t\t\t\t\t\tsz[crr] = 1;",
			"\t\t\t\t\t\tfor (auto const& nxt : grh[crr]) if (nxt != prt && !ckd[nxt]) {",
			"\t\t\t\t\t\t\tdfs(nxt, crr); if (new_ctr != -1) return;",
			"\t\t\t\t\t\t\tsz[crr] += sz[nxt];",
			"\t\t\t\t\t\t}",
			"\t\t\t\t\t\tif (sz[crr] * 2 >= bkt) {",
			"\t\t\t\t\t\t\tfor (auto const& nxt : grh[crr]) if (!ckd[nxt]) {",
			"\t\t\t\t\t\t\t\tif (nxt != prt) que.emplace(crr, nxt, sz[nxt]);",
			"\t\t\t\t\t\t\t\telse que.emplace(crr, nxt, bkt - sz[crr]);",
			"\t\t\t\t\t\t\t}",
			"\t\t\t\t\t\t\tckd[crr] = true;",
			"\t\t\t\t\t\t\tnew_ctr = crr;",
			"\t\t\t\t\t\t}",
			"\t\t\t\t\t})(start, start);",
			"\t\t\t\tif (prv_ctr == -1) rt = new_ctr;",
			"\t\t\t\telse ctr[prv_ctr].push_back(new_ctr);",
			"\t\t\t}",
			"\t\t}",
			"\tpublic:",
			"\t\tcentroid_tree (",
			"\t\t\t\tstd::vector<std::vector<int>> grh",
			"\t\t\t) :",
			"\t\t\tn(grh.size()),",
			"\t\t\tgrh(grh), ckd(n, false),",
			"\t\t\tctr(n)",
			"\t\t\t{",
			"\t\t\t\tbuild();",
			"\t\t\t}",
			"\t\tauto const centroid () const {return rt;}",
			"\t\tauto const& result () const {return ctr;}",
			"\t\tauto const& operator [] (int i) const {return ctr[i];}",
			"\t\tauto const size () const {return n;}",
			"};"
		],
		"description": "none"
	},
	"dfs1": {
		"prefix": "dfs1",
		"body": [
			"fix ([&](auto dfs, int crr, int prt) -> void {",
			"\tfor (auto const& nxt : grh[crr]) if (nxt != prt) {",
			"\t\tdfs(nxt, crr);",
			"\t}",
			"})(${1:0}, $1);"
		],
		"description": "none"
	},
	"dfs2": {
		"prefix": "dfs2",
		"body": [
			"std::vector<bool> ckd(${1:n}, false);",
			"fix ([&](auto dfs, int crr) -> void {",
			"\tif (ckd[crr]) return;",
			"\tckd[crr] = true;",
			"\tfor (auto const& nxt : grh[crr]) {",
			"\t\tdfs(nxt);",
			"\t}",
			"})(${2:0});"
		],
		"description": "none"
	},
	"diameter": {
		"prefix": "diameter",
		"body": [
			"template<typename T>",
			"class diameter {",
			"\tconst int n;",
			"\tconst std::vector<std::vector<std::pair<T, int>>>& grh;",
			"\tT diam;",
			"\tint ex, fx;",
			"\tvoid cal () {",
			"\t\tfor (int t = 0; t < 2; t++) {",
			"\t\t\tdiam = 0;",
			"\t\t\tfix ([&](auto dfs, int crr, int prt, T dpt = 0) -> void {",
			"\t\t\t\tif (cmx(diam, dpt)) fx = crr;",
			"\t\t\t\tfor (auto const& e : grh[crr]) {",
			"\t\t\t\t\tT w; int nxt; std::tie(w, nxt) = e;",
			"\t\t\t\t\tif (nxt == prt) continue;",
			"\t\t\t\t\tdfs(nxt, crr, dpt + w);",
			"\t\t\t\t}",
			"\t\t\t})(ex, ex);",
			"\t\t\tstd::swap(ex, fx);",
			"\t\t}",
			"\t\tif (ex > fx) std::swap(ex, fx);",
			"\t}",
			"\tpublic:",
			"\t\tdiameter (std::vector<std::vector<std::pair<T, int>>>& grh) :",
			"\t\t\tn(grh.size()), grh(grh),",
			"\t\t\tdiam(0), ex(0), fx(0)",
			"\t\t\t{",
			"\t\t\t\tcal();",
			"\t\t\t}",
			"\t\tT result () const {return diam;}",
			"\t\tauto extremals () const -> std::pair<int, int> {return {ex, fx};}",
			"};"
		],
		"description": "none"
	},
	"dijkstra": {
		"prefix": "dijkstra",
		"body": [
			"template <typename T>",
			"class dijkstra {",
			"\tconst int n, r;",
			"\tconst std::vector<std::vector<std::pair<T, int>>>& grh;",
			"\tstd::vector<T> dst;",
			"\tvoid cal () {",
			"\t\tpriority_queue<",
			"\t\t\tstd::pair<T, int>, std::vector<std::pair<T, int>>, greater<std::pair<T, int>>",
			"\t\t\t> que;",
			"\t\tque.emplace(0, r);",
			"\t\twhile (!que.empty()) {",
			"\t\t\tT crd; int crr; std::tie(crd, crr) = que.top(), que.pop();",
			"\t\t\tif (!cmn(dst[crr], crd)) continue;",
			"\t\t\tfor (auto e : grh[crr]) {",
			"\t\t\t\tT w; int nxt; std::tie(w, nxt) = e;",
			"\t\t\t\tT nxd = crd + w;",
			"\t\t\t\tif (nxd < dst[nxt]) que.emplace(nxd, nxt);",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"\tpublic:",
			"\t\tconst T inf;",
			"\t\tdijkstra (",
			"\t\t\t\tconst int r,",
			"\t\t\t\tconst std::vector<std::vector<std::pair<T, int>>>& grh,",
			"\t\t\t\tconst T inf = numeric_limits<T>::max()",
			"\t\t\t) :",
			"\t\t\tn(grh.size()), r(r),",
			"\t\t\tgrh(grh), dst(n, inf), inf(inf)",
			"\t\t\t{",
			"\t\t\t\tcal();",
			"\t\t\t}",
			"\t\tauto result () const {return dst;}",
			"};"
		],
		"description": "none"
	},
	"dinic": {
		"prefix": "dinic",
		"body": [
			"template <typename T>",
			"class dinic {",
			"\tstruct edge {",
			"\t\tint to; T cap;",
			"\t\tweak_ptr<edge> rev;",
			"\t};",
			"\tconst int n, source, sink;",
			"\tstd::vector<bool> ckd;",
			"\tstd::vector<int> dst;",
			"\tstd::vector<std::vector<shared_ptr<edge>>> grh;",
			"\tstatic constexpr T inf = numeric_limits<T>::max();",
			"\tvoid bfs () {",
			"\t\tqueue<int> que;",
			"\t\tque.emplace(source); dst[source] = 0;",
			"\t\twhile (!que.empty()) {",
			"\t\t\tint crr = que.front(); que.pop();",
			"\t\t\tfor (auto const& e : grh[crr]) {",
			"\t\t\t\tif (e->cap == 0) continue;",
			"\t\t\t\tint nxt = e->to;",
			"\t\t\t\tif (dst[nxt] != -1) continue;",
			"\t\t\t\tque.push(nxt); dst[nxt] = dst[crr] + 1;",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"\tT dfs () {",
			"\t\treturn fix ([&](auto dfs, int crr, int f = inf) -> T {",
			"\t\t\tif (crr == sink) return f;",
			"\t\t\tckd[crr] = true;",
			"\t\t\tfor (auto& e : grh[crr]) {",
			"\t\t\t\tint nxt = e->to;",
			"\t\t\t\tif (ckd[nxt] || e->cap == 0 || dst[crr] >= dst[nxt]) continue;",
			"\t\t\t\tT d = dfs(nxt, min(f, e->cap));",
			"\t\t\t\tif (d > 0) {",
			"\t\t\t\t\te->cap -= d;",
			"\t\t\t\t\te->rev.lock()->cap += d;",
			"\t\t\t\t\treturn d;",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t\tdst[crr] = -1;",
			"\t\t\treturn 0;",
			"\t\t})(source);",
			"\t}",
			"\tpublic:",
			"\t\tdinic (int n, int source, int sink) :",
			"\t\t\tn(n), source(source), sink(sink), grh(n)",
			"\t\t\t{}",
			"\t\tvoid insert(int u, int v, T c) {",
			"\t\t\tauto e = make_shared<edge>(edge{v, c});",
			"\t\t\tauto r = make_shared<edge>(edge{u, 0});",
			"\t\t\te->rev = r;",
			"\t\t\tr->rev = e;",
			"\t\t\tgrh[u].push_back(e);",
			"\t\t\tgrh[v].push_back(r);",
			"\t\t}",
			"\t\tT cal() {",
			"\t\t\tT ret = 0;",
			"\t\t\twhile (true) {",
			"\t\t\t\tdst.assign(n, -1);",
			"\t\t\t\tbfs();",
			"\t\t\t\tif (dst[sink] == -1) return ret;",
			"\t\t\t\tckd.assign(n, false);",
			"\t\t\t\twhile (true) {",
			"\t\t\t\t\tT f = dfs();",
			"\t\t\t\t\tif (f == 0) break;",
			"\t\t\t\t\tret += f;",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t}",
			"};"
		],
		"description": "none"
	},
	"floyd warshall": {
		"prefix": "floyd warshall",
		"body": [
			"template<typename T>",
			"struct floyd_warshall {",
			"\tconst int n;",
			"\tconst T inf;",
			"\tstd::vector<std::vector<T>> dst;",
			"\tvoid cal () {",
			"\t\tfor (int k = 0; k < n; k++) {",
			"\t\t\tfor (int i = 0; i < n; i++) {",
			"\t\t\t\tfor (int j = 0; j < n; j++) {",
			"\t\t\t\t\tif (dst[i][k] != inf && dst[k][j] != inf) {",
			"\t\t\t\t\t\tcmn(dst[i][j], dst[i][k] + dst[k][j]);",
			"\t\t\t\t\t}",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"\tfloyd_warshall (",
			"\t\t\tconst std::vector<std::vector<T>> adj,",
			"\t\t\tconst T inf",
			"\t\t) :",
			"\t\tn(adj.size()), inf(inf), dst(adj)",
			"\t\t{",
			"\t\t\tcal();",
			"\t\t}",
			"\tauto& result () {return dst;}",
			"\tbool has_negative_cycle () {",
			"\t\tfor (int i = 0; i < n; i++) if (dst[i][i] < 0) return true;",
			"\t\treturn false;",
			"\t}",
			"};"
		],
		"description": "none"
	},
	"ford fulkerson": {
		"prefix": "ford fulkerson",
		"body": [
			"template <typename T>",
			"class ford_fulkerson {",
			"\tstruct edge {",
			"\t\tint to; T cap;",
			"\t\tweak_ptr<edge> rev;",
			"\t\tedge(int to, T cap) : to(to), cap(cap) {}",
			"\t};",
			"\tconst int n, source, sink;",
			"\tstd::vector<bool> ckd;",
			"\tstd::vector<std::vector<shared_ptr<edge>>> grh;",
			"\tstatic constexpr T inf = numeric_limits<T>::max();",
			"\tT dfs () {",
			"\t\treturn fix ([&](auto dfs, int crr, int f = inf) -> T {",
			"\t\t\tif (crr == sink) return f;",
			"\t\t\tckd[crr] = true;",
			"\t\t\tfor (auto& e : grh[crr]) {",
			"\t\t\t\tif (ckd[e->to] || !e->cap) continue;",
			"\t\t\t\tT d = dfs(e->to, min(f, e->cap));",
			"\t\t\t\tif (d) {",
			"\t\t\t\t\te->cap -= d;",
			"\t\t\t\t\te->rev.lock()->cap += d;",
			"\t\t\t\t\treturn d;",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t\treturn 0;",
			"\t\t})(source);",
			"\t}",
			"\tpublic:",
			"\t\tford_fulkerson (int n, int source, int sink) :",
			"\t\t\tn(n), source(source), sink(sink), grh(n)",
			"\t\t\t{}",
			"\t\tvoid insert(int u, int v, T c) {",
			"\t\t\tauto e = make_shared<edge>(v, c);",
			"\t\t\tauto r = make_shared<edge>(u, 0);",
			"\t\t\te->rev = r;",
			"\t\t\tr->rev = e;",
			"\t\t\tgrh[u].push_back(e);",
			"\t\t\tgrh[v].push_back(r);",
			"\t\t}",
			"\t\tT cal() {",
			"\t\t\tT ret = 0;",
			"\t\t\twhile (true) {",
			"\t\t\t\tckd.assign(n, false);",
			"\t\t\t\tT f = dfs();",
			"\t\t\t\tif (!f) return ret;",
			"\t\t\t\tret += f;",
			"\t\t\t}",
			"\t\t}",
			"};"
		],
		"description": "none"
	},
	"grid bfs": {
		"prefix": "grid bfs",
		"body": [
			"std::vector<std::vector<${1:long long}>> dst(h, std::vector<$1>(w, ${4:-1}));",
			"queue<std::pair<int, int>> que;",
			"dst[${2:si}][${3:sj}] = 0, que.emplace($2, $3);",
			"while (!que.empty()) {",
			"\tint cri, crj;",
			"\tstd::tie(cri, crj) = que.front(), que.pop();",
			"\tfor (int k = 0; k < 4; k++) {",
			"\t\tint nxi = cri + di[k];",
			"\t\tint nxj = crj + dj[k];",
			"\t\tif (",
			"\t\t\t\t0 <= nxi && nxi < h &&",
			"\t\t\t\t0 <= nxj && nxj <= w &&",
			"\t\t\t\tdst[nxi][nxj] == $4 &&",
			"\t\t\t\t!grd[nxi][nxj]",
			"\t\t\t) dst[nxi][nxj] = dst[cri][crj] + 1, que.emplace(nxi, nxj);",
			"\t}",
			"}"
		],
		"description": "none"
	},
	"heights": {
		"prefix": "heights",
		"body": [
			"template<typename T>",
			"class calculate_heights {",
			"\tconst int n;",
			"\tconst std::vector<std::vector<std::pair<T, int>>>& grh;",
			"\tstd::vector<T> dp, ep;",
			"",
			"\tvoid dfs (",
			"\t\t\tint crr = 0,",
			"\t\t\tint prt = 0",
			"\t\t) {",
			"\t\t\tfor (auto const& e : grh[crr]) {",
			"\t\t\t\tT w; int nxt; std::tie(w, nxt) = e;",
			"\t\t\t\tif (nxt == prt) continue;",
			"\t\t\t\tdfs(nxt, crr);",
			"\t\t\t\tchmax(dp[crr], dp[nxt] + w);",
			"\t\t\t}",
			"\t\t}",
			"",
			"\tvoid efs (",
			"\t\t\tint crr = 0,",
			"\t\t\tint prt = 0",
			"\t\t) {",
			"\t\t\tstd::vector<T> cld = {ep[crr]};",
			"\t\t\tfor (auto const& e : grh[crr]) {",
			"\t\t\t\tT w; int nxt; std::tie(w, nxt) = e;",
			"\t\t\t\tif (nxt == prt) continue;",
			"\t\t\t\tcld.push_back(dp[nxt] + w);",
			"\t\t\t}",
			"\t\t\tsort(cld.begin(), cld.end(), greater<T>());",
			"\t\t\tfor (auto const& e : grh[crr]) {",
			"\t\t\t\tT w; int nxt; std::tie(w, nxt) = e;",
			"\t\t\t\tif (nxt == prt) continue;",
			"\t\t\t\tep[nxt] = dp[nxt] + w == cld[0] ?",
			"\t\t\t\t\t\tcld[1] + w : cld[0] + w;",
			"\t\t\t}",
			"\t\t\tfor (auto const& e : grh[crr]) {",
			"\t\t\t\tT w; int nxt; std::tie(w, nxt) = e;",
			"\t\t\t\tif (nxt == prt) continue;",
			"\t\t\t\tefs(nxt, crr);",
			"\t\t\t}",
			"\t\t\tchmax(dp[crr], ep[crr]);",
			"\t\t}",
			"",
			"\tpublic:",
			"\t\tcalculate_heights(",
			"\t\t\t\tstd::vector<std::vector<std::pair<T, int>>>& grh",
			"\t\t\t) :",
			"\t\t\tn(grh.size()),",
			"\t\t\tgrh(grh),",
			"\t\t\tdp(n, 0),",
			"\t\t\tep(n, 0)",
			"\t\t\t{",
			"\t\t\t\tdfs();",
			"\t\t\t\tefs();",
			"\t\t\t}",
			"\t\t",
			"\t\tauto operator[] (int i) const -> const T {return dp[i];}",
			"};"
		],
		"description": "none"
	},
	"inner dfs1": {
		"prefix": "inner dfs1",
		"body": [
			"\tvoid dfs (",
			"\t\t\tint crr = 0,",
			"\t\t\tint prt = 0",
			"\t\t) {",
			"\t\t\tfor (int const& nxt : grh[crr]) {",
			"\t\t\t\t${2:T} w; int nxt; std::tie(w, nxt) = e;",
			"\t\t\t\tif (nxt == prt) continue;",
			"\t\t\t\tdfs(nxt, crr);",
			"\t\t\t\tchmax(dp[crr], dp[nxt] + w);",
			"\t\t\t}",
			"\t\t}"
		],
		"description": "none"
	},
	"kruskal": {
		"prefix": "kruskal",
		"body": [
			"template<typename T>",
			"struct kruskal {",
			"\tusing edge_type = tuple<T, int, int>;",
			"\tconst int n;",
			"\tstd::vector<edge_type> edg;",
			"\tstd::vector<edge_type> mst;",
			"\tT weight_of_mst;",
			"\tkruskal (",
			"\t\t\tint n,",
			"\t\t\tstd::vector<edge_type> edg",
			"\t\t) :",
			"\t\tn(n),",
			"\t\tedg(edg),",
			"\t\tmst(n - 1),",
			"\t\tweight_of_mst(0)",
			"\t\t{",
			"\t\t\tsort(edg.begin(), edg.end());",
			"\t\t\tdisjoint_set djs(n);",
			"\t\t\tint cnt = 0;",
			"\t\t\tfor (auto e : edg) {",
			"\t\t\t\tT w; int s, t; std::tie(w, s, t) = e;",
			"\t\t\t\tif (djs.unite(s, t)) {",
			"\t\t\t\t\tweight_of_mst += w;",
			"\t\t\t\t\tmst[cnt] = {w, s, t};",
			"\t\t\t\t\tif (++cnt == n - 1) break;",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t\tif (cnt < n - 1) assert(false);",
			"\t\t}\t\t",
			"};"
		],
		"description": "none"
	},
	"least common ancestor": {
		"prefix": "least common ancestor",
		"body": [
			"class least_common_ancestor {",
			"\tconst int n, r;",
			"\tint ht;",
			"\tstd::vector<int> dpt;",
			"\tstd::vector<std::vector<int>> prt;",
			"\tconst std::vector<std::vector<int>> grh;",
			"",
			"\tvoid dfs (",
			"\t\t\tconst std::vector<std::vector<int>>& grh,",
			"\t\t\tstd::vector<int>& dpt,",
			"\t\t\tint crr, int prt",
			"\t\t) {",
			"\t\t\tfor (int const& nxt : grh[crr]) {",
			"\t\t\t\tif (nxt == prt) continue;",
			"\t\t\t\tdpt[nxt] = dpt[crr] + 1;",
			"\t\t\t\tdfs(grh, dpt, nxt, crr);",
			"\t\t\t}",
			"\t\t}",
			"\t\tvoid climb (int& x, int b) const {",
			"\t\t\tfor (int i = 0; b; i++, b >>= 1) {",
			"\t\t\t\tif (b & 1) x = prt[i][x];",
			"\t\t\t}",
			"\t\t}",
			"",
			"\tpublic:",
			"\t\tleast_common_ancestor (",
			"\t\t\t\tconst std::vector<std::vector<int>>& grh,",
			"\t\t\t\tconst std::vector<int>& direct_prt,",
			"\t\t\t\tconst int root",
			"\t\t\t) :",
			"\t\t\tn(direct_prt.size()), r(root),",
			"\t\t\tht([&, i = 0]() mutable {",
			"\t\t\t\t\tfor (int p = 1; p < n; p <<= 1) i++;",
			"\t\t\t\t\treturn i;",
			"\t\t\t\t}()),",
			"\t\t\tdpt([&](){",
			"\t\t\t\t\tstd::vector<int> ret(n, 0);",
			"\t\t\t\t\tdfs(grh, ret, r, r);",
			"\t\t\t\t\treturn ret;",
			"\t\t\t\t}()),",
			"\t\t\tprt([&](){",
			"\t\t\t\t\tstd::vector<std::vector<int>> ret(ht, direct_prt);",
			"\t\t\t\t\tfor (int i = 1; i < ht; i++) {",
			"\t\t\t\t\t\tfor (int j = 0; j < n; j++) {",
			"\t\t\t\t\t\t\tprt[i][j] = prt[i - 1][prt[i - 1][j]];",
			"\t\t\t\t\t\t}",
			"\t\t\t\t\t}",
			"\t\t\t\t\treturn ret;",
			"\t\t\t\t}()),",
			"\t\t\tgrh(grh)",
			"\t\t\t{",
			"\t\t\t}",
			"",
			"\t\tint higher_prt (int x, int b) const {climb(x, b); return x;}",
			"\t\tint depth (int x) const {return dpt[x];}",
			"\t\tint lca (int x, int y) {",
			"\t\t\tif (dpt[x] < dpt[y]) climb(y, dpt[y] - dpt[x]);",
			"\t\t\telse if (dpt[y] < dpt[x]) climb(x, dpt[x] - dpt[y]);",
			"\t\t\tif (x == y) return x;",
			"\t\t\tfor (int i = ht - 1; i >= 0; i--) {",
			"\t\t\t\tif (prt[i][x] != prt[i][y]) {",
			"\t\t\t\t\tx = prt[i][x];",
			"\t\t\t\t\ty = prt[i][y];",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t\treturn prt[0][x];",
			"\t\t}",
			"};"
		],
		"description": "none"
	},
	"low link tree": {
		"prefix": "low link tree",
		"body": [
			"struct low_link_tree {",
			"\tconst int n;",
			"\tconst int r = 0;",
			"\tint tmr = 0;",
			"\tstd::vector<int> ord;",
			"\tstd::vector<int> low;",
			"\tset<int> art;",
			"\tset<std::pair<int, int>> bdg;",
			"\tstd::vector<std::vector<int>> grh;",
			"public:",
			"\tlow_link_tree (",
			"\t\tstd::vector<std::vector<int>> const& grh,",
			"\t\tconst int root",
			"\t)",
			"\t: n(grh.size())",
			"\t, r(root)",
			"\t, ord(n, -1)",
			"\t, low(n, -1)",
			"\t, grh(grh)",
			"\t{",
			"\t\tdfs(r, r);",
			"\t}",
			"\tvoid dfs (",
			"\t\tint crr",
			"\t,\tint prt",
			"\t) {",
			"\t\tint cnt = 0;",
			"\t\tord[crr] = low[crr] = tmr++;",
			"\t\tfor (int nxt : grh[crr]) {",
			"\t\t\tif (ord[nxt] == -1) {",
			"\t\t\t\tcnt++;",
			"\t\t\t\tdfs(nxt, crr);",
			"\t\t\t\tchmin(low[crr], low[nxt]);",
			"\t\t\t\tif (crr != r && ord[crr] <= low[nxt]) art.insert(crr);",
			"\t\t\t\tif (ord[crr] < low[nxt]) bdg.emplace(min(crr, nxt), max(crr, nxt));",
			"\t\t\t}",
			"\t\t\tif (nxt != prt) chmin(low[crr], ord[nxt]);",
			"\t\t}",
			"\t\tif (crr == r && cnt > 1) art.insert(crr);",
			"\t}",
			"};"
		],
		"description": "none"
	},
	"minimum cost flow": {
		"prefix": "minimum cost flow",
		"body": [
			"template <typename T, typename U>",
			"class minimum_cost_flow {",
			"\tpublic:",
			"\t\tconst T max_flow = numeric_limits<T>::max();",
			"\t\tconst U max_dist\t= numeric_limits<U>::max();",
			"\tprivate:",
			"\t\tstruct edge {",
			"\t\t\tint to; T cap; U cost;",
			"\t\t\tweak_ptr<edge> rev;",
			"\t\t};",
			"\t\tconst int n, source, sink;",
			"\t\tstd::vector<U> dst;",
			"\t\tstd::vector<std::vector<shared_ptr<edge>>> grh;",
			"\t\tvoid bf () {",
			"\t\t\tdst.assign(n, max_dist); dst[source] = 0;",
			"\t\t\tfor (int t = 0; t < n; t++) {",
			"\t\t\t\tbool flg = false;",
			"\t\t\t\tfor (int i = 0; i < n; i++) {",
			"\t\t\t\t\tfor (auto const& e : grh[i]) {",
			"\t\t\t\t\t\tif (e->cap == 0) continue;",
			"\t\t\t\t\t\tint crr = i;\t\t U crd = dst[crr];",
			"\t\t\t\t\t\tint nxt = e->to; U nxd = crd + e->cost;",
			"\t\t\t\t\t\tif (crd == max_dist) continue;",
			"\t\t\t\t\t\tif (cmn(dst[nxt], nxd)) flg = true;",
			"\t\t\t\t\t}",
			"\t\t\t\t}",
			"\t\t\t\tif (!flg) break;",
			"\t\t\t\tif (t == n - 1 && flg) assert(false);",
			"\t\t\t}",
			"\t\t}",
			"\t\tU flush () {",
			"\t\t\tstd::vector<bool> ckd(n, false);",
			"\t\t\treturn fix([&] (auto dfs, int crr, U f) -> U {",
			"\t\t\t\tif (ckd[crr]) return 0;",
			"\t\t\t\tckd[crr] = true;",
			"\t\t\t\tif (crr == sink) return f;",
			"\t\t\t\tfor (auto const& e : grh[crr]) {",
			"\t\t\t\tif (e->cap == 0) continue;",
			"\t\t\t\t\tU crd = dst[crr];",
			"\t\t\t\t\tint nxt = e->to; U nxd = dst[nxt];",
			"\t\t\t\t\tif (crd + e->cost != nxd) continue;",
			"\t\t\t\t\tU d = dfs(nxt, min(f, e->cap));",
			"\t\t\t\t\tif (d > 0) {",
			"\t\t\t\t\t\te->cap -= d;",
			"\t\t\t\t\t\te->rev.lock()->cap += d;",
			"\t\t\t\t\t\treturn d;",
			"\t\t\t\t\t}",
			"\t\t\t\t}",
			"\t\t\t\treturn 0;",
			"\t\t\t})(source, max_flow);",
			"\t\t}",
			"\tpublic:",
			"\t\tminimum_cost_flow (int n, int source, int sink) :",
			"\t\t\tn(n), source(source), sink(sink), grh(n)",
			"\t\t\t{}",
			"\t\tvoid insert(int u, int v, T cap, U cost) {",
			"\t\t\tauto e = make_shared<edge>(edge{v, cap, cost});",
			"\t\t\tauto r = make_shared<edge>(edge{u, 0, -cost});",
			"\t\t\te->rev = r;",
			"\t\t\tr->rev = e;",
			"\t\t\tgrh[u].push_back(e);",
			"\t\t\tgrh[v].push_back(r);",
			"\t\t}",
			"\t\tT cal(U required_flow) {",
			"\t\t\tT ret = 0;",
			"\t\t\twhile (true) {",
			"\t\t\t\tbf();",
			"\t\t\t\tif (dst[sink] == max_dist) break;",
			"\t\t\t\tT d = dst[sink]; U f = flush();",
			"\t\t\t\tif (f >= required_flow) {",
			"\t\t\t\t\tret += d * required_flow;",
			"\t\t\t\t\treturn ret;",
			"\t\t\t\t} else {",
			"\t\t\t\t\tret += d * f;",
			"\t\t\t\t\trequired_flow -= f;",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t\treturn -1;",
			"\t\t}",
			"};"
		],
		"description": "none"
	},
	"prim": {
		"prefix": "prim",
		"body": [
			"template <typename T>",
			"struct prim {",
			"\tconst int n;",
			"\tstd::vector<std::vector<std::pair<T, int>>> grh;",
			"\tT weight_of_mst;",
			"\tprim (",
			"\t\t\tstd::vector<std::vector<std::pair<T, int>>> grh",
			"\t\t) :",
			"\t\tn(grh.size()),",
			"\t\tgrh(grh),",
			"\t\tweight_of_mst(0)",
			"\t\t{",
			"\t\t\tstd::vector<bool> ckd(n, false);",
			"\t\t\tpriority_queue<",
			"\t\t\t\tstd::pair<T, int>,",
			"\t\t\t\tstd::vector<std::pair<T, int>>,",
			"\t\t\t\tgreater<std::pair<T, int>>",
			"\t\t\t> que;",
			"\t\t\tque.emplace(0, 0);",
			"\t\t\twhile (!que.empty()) {",
			"\t\t\t\tT w; int t;",
			"\t\t\t\tstd::tie(w, t) = que.top(), que.pop();",
			"\t\t\t\tif (ckd[t]) continue;",
			"\t\t\t\tweight_of_mst += w, ckd[t] = true;",
			"\t\t\t\tfor (auto p : grh[t]) que.push(p);",
			"\t\t\t}",
			"\t\t}",
			"};"
		],
		"description": "none"
	},
	"topological sort 1": {
		"prefix": "topological sort 1",
		"body": [
			"class topological_sort {",
			"\tconst int n;",
			"\tconst std::vector<std::vector<int>>& grh;",
			"\tstd::vector<int> srd;",
			"\tstd::vector<int> ckd;",
			"\tbool flg;",
			"",
			"\tbool dfs (int crr) {",
			"\t\tif (ckd[crr] == 1) return true;",
			"\t\tif (ckd[crr] == 2) return false;",
			"\t\tbool ret = false;",
			"\t\tckd[crr] = 1;",
			"\t\tfor (int nxt : grh[crr]) {",
			"\t\t\tret |= dfs(nxt);",
			"\t\t}",
			"\t\tckd[crr] = 2;",
			"\t\tsrd.insert(srd.begin(), crr);",
			"\t\treturn ret;",
			"\t}",
			"",
			"\tpublic:",
			"\t\ttopological_sort (",
			"\t\t\t\tconst std::vector<std::vector<int>>& grh",
			"\t\t\t) :",
			"\t\t\tn(grh.size()),",
			"\t\t\tgrh(grh),",
			"\t\t\tsrd(),",
			"\t\t\tckd(n, 0),",
			"\t\t\tflg(",
			"\t\t\t\t\t[&](){",
			"\t\t\t\t\t\tbool ret = false;",
			"\t\t\t\t\t\tfor (int i = 0; i < n; i++) {",
			"\t\t\t\t\t\t\tflg |= (ckd[i] == 0 && dfs(i));",
			"\t\t\t\t\t\t}",
			"\t\t\t\t\t\treturn ret;",
			"\t\t\t\t\t}()",
			"\t\t\t\t)",
			"\t\t\t{",
			"\t\t\t}",
			"\t\tbool has_cycle () {return flg;}",
			"\t\tauto sorted() const -> const std::vector<int>& {return srd;}",
			"\t\tauto operator [] (int i) const -> int {return srd[i];}",
			"};"
		],
		"description": "none"
	},
	"topological sort 2": {
		"prefix": "topological sort 2",
		"body": [
			"// none (tail)"
		],
		"description": "none"
	},
	"binary serch": {
		"prefix": "binary serch",
		"body": [
			"${1:int} ok = ${2:0}, ng = ${3:inf}, md;",
			"while (abs(ok - ng) > 1) {",
			"\tmd = (ok + ng) >> 1;",
			"\tif (${4:ck(md)}) ok = md;",
			"\telse ng = md;",
			"}"
		],
		"description": "none"
	},
	"lis": {
		"prefix": "lis",
		"body": [
			"std::vector<${1:int}> lis;",
			"for (auto crr : ${2:name}) {",
			"\tauto lb = std::lower_bound(lis.begin(), lis.end(), crr);",
			"\tif (lb == lis.end()) lis.push_back(crr);",
			"\telse *lb = crr;",
			"}"
		],
		"description": "none"
	},
	"run length encoding": {
		"prefix": "run length encoding",
		"body": [
			"template<typename T>",
			"class run_length_encoding {",
			"\tstd::vector<std::pair<int, T>> rle;",
			"\tpublic:",
			"\t\trun_length_encoding(",
			"\t\t\t\tstd::vector<T> input",
			"\t\t\t) :",
			"\t\t\trle(0)",
			"\t\t\t{",
			"\t\t\t\tint cnt = 0;",
			"\t\t\t\tfor (auto it = input.begin(); it != input.end(); it++) {",
			"\t\t\t\t\tauto jt = next(it); cnt++;",
			"\t\t\t\t\tif (jt == input.end() || *it != *jt) {",
			"\t\t\t\t\t\trle.emplace_back(cnt, *it);",
			"\t\t\t\t\t\tcnt = 0;",
			"\t\t\t\t\t}",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\tauto const& code () const {return rle;}",
			"};"
		],
		"description": "none"
	},
	"slide minimum": {
		"prefix": "slide minimum",
		"body": [
			"template <typename T, class Compare = less<T>>",
			"class slide_minimum {",
			"\tpublic:",
			"\tconst std::vector<T> a;",
			"\tCompare cmp;",
			"\tdeque<int> que;",
			"\tint l, r;",
			"\t\tslide_minimum(",
			"\t\t\t\tconst std::vector<T>& a",
			"\t\t\t) :",
			"\t\t\ta(a), cmp(Compare()), l(0), r(0)",
			"\t\t\t{",
			"\t\t\t}",
			"\t\tinline void luc () {",
			"\t\t\tif (que.front() == l++) {",
			"\t\t\t\tque.pop_front();",
			"\t\t\t}",
			"\t\t}",
			"\t\tinline void ruc () {",
			"\t\t\twhile (!que.empty() && !cmp(a[que.back()], a[r])) {",
			"\t\t\t\tque.pop_back();",
			"\t\t\t}",
			"\t\t\tque.push_back(r++);",
			"\t\t}",
			"\t\tinline auto query () const -> T {",
			"\t\t\tassert(!que.empty());",
			"\t\t\treturn a[que.front()];",
			"\t\t}",
			"\t\tinline auto query_index () const -> int {",
			"\t\t\tassert(!que.empty());",
			"\t\t\treturn que.front();",
			"\t\t}",
			"};"
		],
		"description": "none"
	},
	"sliding window": {
		"prefix": "sliding window",
		"body": [
			"/* init crr, ret */",
			"for (int l = 0, r = 0; l < n; l++) {",
			"\tif (r <= l) {",
			"\t\tr = l;",
			"\t\t/* re-init crr */;",
			"\t}",
			"\tfor (; r < n; r++) {",
			"\t\tif (/* cannot push r */) break;",
			"\t\t/* push r */;",
			"\t}",
			"\tret += r - l;",
			"\t/* pop l */",
			"}"
		],
		"description": "none"
	},
	"factorize": {
		"prefix": "factorize",
		"body": [
			"class factorize {",
			"\tint x;",
			"\tmap<int, int> mp;",
			"\tstd::vector<int> pdv;",
			"\tstd::vector<int> pdv_m;",
			"",
			"\tpublic:",
			"\t\tfactorize(",
			"\t\t\t\tconst int x",
			"\t\t\t) :",
			"\t\t\tx(x), mp(), pdv()",
			"\t\t\t{",
			"\t\t\t\tfor (int p = 2; p * p <= x; p++) {",
			"\t\t\t\t\twhile (!(x % p)) {",
			"\t\t\t\t\t\tmp[p]++;",
			"\t\t\t\t\t\tpdv.push_back(p);",
			"\t\t\t\t\t\tx /= p;",
			"\t\t\t\t\t}",
			"\t\t\t\t}",
			"\t\t\t\tif (x != 1) mp[x] = 1;",
			"\t\t\t\tpdv.push_back(x);",
			"\t\t\t\tpdv_m = pdv.resize(unique(pdv.begin(), pdv.end()) - pdv.begin());",
			"\t\t\t}",
			"\t\t",
			"\t\tconst auto& factorize () const {return pdv;}",
			"\t\tconst auto& prime_divisors () const {return pdv_m;}",
			"\t\tconst auto& multiplicities () const {return mp;}",
			"}"
		],
		"description": "none"
	},
	"gcd": {
		"prefix": "gcd",
		"body": [
			"template<typename T>",
			"T gcd (T a, T b) {",
			"\tif (a < 0) a = -a;",
			"\tif (b < 0) b = -b;",
			"\tif (a < b) std::swap(a, b);",
			"\twhile (b) {",
			"\t\ta %= b;",
			"\t\tstd::swap(a, b);",
			"\t}",
			"\treturn a;",
			"}"
		],
		"description": "none"
	},
	"mint": {
		"prefix": "mint",
		"body": [
			"namespace mint {",
			"\tint md;",
			"\tinline void add (int &a, int b) {",
			"\t\tassert(0 <= a && a < md && 0 <= b && b < md);",
			"\t\ta += b; if (a >= md) a -= md;",
			"\t}",
			"\tinline void sub (int &a, int b) {",
			"\t\tassert(0 <= a && a < md && 0 <= b && b < md);",
			"\t\ta -= b; if (a < 0) a += md;",
			"\t}",
			"\tinline int sum (int a, int b) {",
			"\t\tassert(0 <= a && a < md && 0 <= b && b < md);",
			"\t\tadd(a, b); return a;",
			"\t}",
			"\tinline int dif (int a, int b) {",
			"\t\tassert(0 <= a && a < md && 0 <= b && b < md);",
			"\t\tsub(a, b); return a;",
			"\t}",
			"\ttemplate<class... A>",
			"\tinline int prod (A... args) {",
			"\t\tlong long ret = 1;",
			"\t\tfor (int a :\tstd::initializer_list<int>{args...}) {",
			"\t\t\tassert(0 <= a && a < md);",
			"\t\t\tret *= a;",
			"\t\t\tret %= md;",
			"\t\t}",
			"\t\treturn (int)(ret % md);",
			"\t}",
			"\tinline void mul (int &a, int b) {",
			"\t\tassert(0 <= a && a < md && 0 <= b && b < md);",
			"\t\ta = prod(a, b);",
			"\t}",
			"\tinline int inv (int a) {",
			"\t\tassert(0 <= a && a < md);",
			"\t\ta %= md;",
			"\t\tif(a < 0) a += md;",
			"\t\tint b = md, u = 0, v = 1;",
			"\t\twhile (a) {",
			"\t\t\tint t = b / a;",
			"\t\t\tb -= a * t; std::swap(a, b);",
			"\t\t\tu -= v * t; std::swap(u, v);",
			"\t\t}",
			"\t\tassert(b == 1);",
			"\t\tif(u < 0) u += md;",
			"\t\treturn u;",
			"\t}",
			"\tinline int quot (int a, int b) {",
			"\t\tassert(0 <= a && a < md && 0 <= b && b < md);",
			"\t\treturn prod(a, inv(b));",
			"\t}",
			"\tinline void div (int& a, int b) {",
			"\t\tassert(0 <= a && a < md && 0 <= b && b < md);",
			"\t\ta = quot(a, b);",
			"\t}",
			"\tinline int pow (int a, long long b) {",
			"\t\tassert(0 <= a && a < md);",
			"\t\tint res = 1;",
			"\t\tfor (; b; b >>= 1) {",
			"\t\t\tif (b & 1) mul(res, a);",
			"\t\t\tmul(a, a);",
			"\t\t}",
			"\t\treturn res;",
			"\t}",
			"\tnamespace factorials {",
			"\t\tint sz;",
			"\t\tstd::vector<int> fact, finv;",
			"\t\tvoid init (int n) {",
			"\t\t\tsz = n;",
			"\t\t\tfact.resize(n); finv.resize(n);",
			"\t\t\tfact[0] = 1;",
			"\t\t\tfor (int i = 1; i < n; i++) fact[i] = prod(fact[i - 1], i);",
			"\t\t\tfinv[n - 1] = inv(fact[n - 1]);",
			"\t\t\tfor (int i = n - 2; i >= 0; i--) finv[i] = prod(finv[i + 1], i + 1);",
			"\t\t}",
			"\t}",
			"\tinline int fct (int i) {",
			"\t\tusing namespace factorials;",
			"\t\tassert(0 <= i && i < sz);",
			"\t\treturn fact[i];",
			"\t}",
			"\tinline int fnv (int i) {",
			"\t\tusing namespace factorials;",
			"\t\tassert(0 <= i && i < sz);",
			"\t\treturn finv[i];",
			"\t}",
			"\tinline int binom (int n, int k) {",
			"\t\tusing namespace factorials;",
			"\t\tassert(0 <= n && n < sz);",
			"\t\tif (0 < k || n < k) return 0;",
			"\t\treturn prod(fact[n], finv[k], finv[n - k]);",
			"\t}",
			"}"
		],
		"description": "none"
	},
	"pretty mint": {
		"prefix": "pretty mint",
		"body": [
			"template <typename T>",
			"class Modular {",
			" public:",
			"\tusing Type = typename decay<decltype(T::value)>::type;",
			"",
			"\tconstexpr Modular() : value() {}",
			"\ttemplate <typename U>",
			"\tModular(const U& x) {",
			"\t\tvalue = normalize(x);",
			"\t}",
			"",
			"\ttemplate <typename U>",
			"\tstatic Type normalize(const U& x) {",
			"\t\tType v;",
			"\t\tif (-mod() <= x && x < mod()) v = static_cast<Type>(x);",
			"\t\telse v = static_cast<Type>(x % mod());",
			"\t\tif (v < 0) v += mod();",
			"\t\treturn v;",
			"\t}",
			"",
			"\tconst Type& operator()() const { return value; }",
			"\ttemplate <typename U>",
			"\texplicit operator U() const { return static_cast<U>(value); }",
			"\tconstexpr static Type mod() { return T::value; }",
			"",
			"\tModular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }",
			"\tModular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }",
			"\ttemplate <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }",
			"\ttemplate <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }",
			"\tModular& operator++() { return *this += 1; }",
			"\tModular& operator--() { return *this -= 1; }",
			"\tModular operator++(int) { Modular result(*this); *this += 1; return result; }",
			"\tModular operator--(int) { Modular result(*this); *this -= 1; return result; }",
			"\tModular operator-() const { return Modular(-value); }",
			"",
			"\ttemplate <typename U = T>",
			"\ttypename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {",
			"#ifdef _WIN32",
			"\t\tuint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);",
			"\t\tuint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;",
			"\t\tasm(",
			"\t\t\t\"divl %4; \\n\\t\"",
			"\t\t\t: \"=a\" (d), \"=d\" (m)",
			"\t\t\t: \"d\" (xh), \"a\" (xl), \"r\" (mod())",
			"\t\t);",
			"\t\tvalue = m;",
			"#else",
			"\t\tvalue = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));",
			"#endif",
			"\t\treturn *this;",
			"\t}",
			"\ttemplate <typename U = T>",
			"\ttypename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type& operator*=(const Modular& rhs) {",
			"\t\tint64_t q = static_cast<int64_t>(static_cast<long double>(value) * rhs.value / mod());",
			"\t\tvalue = normalize(value * rhs.value - q * mod());",
			"\t\treturn *this;",
			"\t}",
			"\ttemplate <typename U = T>",
			"\ttypename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {",
			"\t\tvalue = normalize(value * rhs.value);",
			"\t\treturn *this;",
			"\t}",
			"",
			"\tModular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }",
			"",
			"\ttemplate <typename U>",
			"\tfriend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);",
			"",
			"\ttemplate <typename U>",
			"\tfriend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);",
			"",
			"\ttemplate <typename U>",
			"\tfriend std::istream& operator>>(std::istream& stream, Modular<U>& number);",
			"",
			" private:",
			"\tType value;",
			"};",
			"",
			"template <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }",
			"template <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }",
			"template <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }",
			"",
			"template <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }",
			"template <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }",
			"template <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }",
			"",
			"template <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }",
			"",
			"template <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }",
			"template <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }",
			"template <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }",
			"",
			"template <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }",
			"template <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }",
			"template <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }",
			"",
			"template <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }",
			"template <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }",
			"template <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }",
			"",
			"template <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }",
			"template <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }",
			"template <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }",
			"",
			"template<typename T, typename U>",
			"Modular<T> power(const Modular<T>& a, const U& b) {",
			"\tassert(b >= 0);",
			"\tModular<T> x = a, res = 1;",
			"\tU p = b;",
			"\twhile (p > 0) {",
			"\t\tif (p & 1) res *= x;",
			"\t\tx *= x;",
			"\t\tp >>= 1;",
			"\t}",
			"\treturn res;",
			"}",
			"",
			"template <typename T>",
			"string to_string(const Modular<T>& number) {",
			"\treturn to_string(number());",
			"}",
			"",
			"template <typename T>",
			"std::ostream& operator<<(std::ostream& stream, const Modular<T>& number) {",
			"\treturn stream << number();",
			"}",
			"",
			"template <typename T>",
			"std::istream& operator>>(std::istream& stream, Modular<T>& number) {",
			"\ttypename common_type<typename Modular<T>::Type, int64_t>::type x;",
			"\tstream >> x;",
			"\tnumber.value = Modular<T>::normalize(x);",
			"\treturn stream;",
			"}",
			"",
			"/*",
			"using ModType = int;",
			"",
			"struct VarMod { static ModType value; };",
			"ModType VarMod::value;",
			"ModType& md = VarMod::value;",
			"using Mint = Modular<VarMod>;",
			"*/",
			"constexpr int md = (int) 1e9 + 7;",
			"using Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;"
		],
		"description": "none"
	},
	"sieve of eratosthenes": {
		"prefix": "sieve of eratosthenes",
		"body": [
			"class sieve_of_eratosthenes {",
			"\tconst int n;",
			"\tstd::vector<bool> is_prm;",
			"\tstd::vector<int> prm;",
			"\tstd::vector<std::vector<int>> pdv;",
			"\tstd::vector<std::vector<int>> div;",
			"",
			"\tpublic:",
			"\t\tsieve_of_eratosthenes(",
			"\t\t\t\tint n",
			"\t\t\t):",
			"\t\t\t\tn(n),",
			"\t\t\t\tis_prm(std::vector<bool>(n)),",
			"\t\t\t\tprm(std::vector<int>(0)), ",
			"\t\t\t\tpdv(std::vector<std::vector<int>>(n)),",
			"\t\t\t\tdiv(std::vector<std::vector<int>>(n))",
			"\t\t\t{",
			"\t\t\t\tfor (int i = 1; i < n; i++) {",
			"\t\t\t\t\tif (is_prm[i] = div[i].size() == 1) prm.push_back(i);",
			"\t\t\t\t\tfor (int j = i; j < n; j += i) {",
			"\t\t\t\t\t\tdiv[j].push_back(i);",
			"\t\t\t\t\t\tif (is_prm[i]) pdv[j].push_back(i);",
			"\t\t\t\t\t}",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t",
			"\t\tbool is_prime (int x) const {assert(x < n); return is_prime[x];}",
			"\t\tauto prime_divisors (int x) const {assert(x < n); return pdv[x];}",
			"\t\tauto divisors (int x) const {assert(x < n); return div[x];}",
			"",
			"\t\tauto factorize (",
			"\t\t\tint x ",
			"\t\t) -> map<int, int> ",
			"\t\t{",
			"\t\t\tmap<int, int> mp;",
			"\t\t\tfor (int p : prm) {",
			"\t\t\t\twhile (!(x % p)) {",
			"\t\t\t\t\tmp[p]++;",
			"\t\t\t\t\tx /= p;",
			"\t\t\t\t}",
			"\t\t\t\tif (x == 1 || p * p > x) break;",
			"\t\t\t}",
			"\t\t\tif (x != 1) mp[x] = 1;",
			"\t\t\treturn mp;",
			"\t\t}",
			"};"
		],
		"description": "none"
	},
	"square matrix": {
		"prefix": "square matrix",
		"body": [
			"namespace mats {",
			"\ttemplate <typename T, size_t N>",
			"\tclass square_matrix {",
			"\t\t\tusing mat_t = array<array<int, N>, N>;",
			"\t\t\tmat_t mat;",
			"\t\tpublic:",
			"\t\t\tsquare_matrix() = default;",
			"\t\t\tsquare_matrix(const square_matrix&) = default;",
			"\t\t\tsquare_matrix(square_matrix&&) = default;",
			"\t\t\tsquare_matrix& operator=(const square_matrix&) = default;",
			"\t\t\tsquare_matrix& operator=(square_matrix&&) = default;",
			"\t\t\t~square_matrix() = default;",
			"\t\t\tsquare_matrix(std::initializer_list<std::initializer_list<int>> il)",
			"\t\t\t\t: mat([il]{",
			"\t\t\t\t\tmat_t mat;",
			"\t\t\t\t\tassert(il.size() == N);",
			"\t\t\t\t\tauto it = il.begin();",
			"\t\t\t\t\tfor (size_t i = 0; i < N; i++, it++) {",
			"\t\t\t\t\t\tassert(it->size() == N);",
			"\t\t\t\t\t\tauto jt = it->begin();",
			"\t\t\t\t\t\tfor (size_t j = 0; j < N; j++) {",
			"\t\t\t\t\t\t\tmat[i][j] = *jt;",
			"\t\t\t\t\t\t}",
			"\t\t\t\t\t}",
			"\t\t\t\t\treturn mat;",
			"\t\t\t\t}()){}",
			"\t\t\tauto size () const {return N;}",
			"\t\t\tdecltype(auto) at\t\t\t\t (size_t i) const {return mat[i];}",
			"\t\t\tdecltype(auto) at\t\t\t\t (size_t i)\t\t\t {return at(i);}",
			"\t\t\tdecltype(auto) operator[] (size_t i) const {return at(i);}",
			"\t\t\tdecltype(auto) operator[] (size_t i)\t\t\t {return at(i);}",
			"\t};",
			"\tconstexpr size_t N = 3;",
			"\tusing T = int;",
			"\tT elem_0 = 0;",
			"\tT elem_1 = 1;",
			"\tstd::function<void(T&, T)> elem_add\t= mint::add;",
			"\tstd::function<T(T, T)>\t\t elem_prod = mint::prod<int, int>;",
			"\tusing mat = array<array<int, N>, N>;",
			"\tauto zero = [&] () {",
			"\t\tmat zero;",
			"\t\tfor (size_t i = 0; i < N; i++) {",
			"\t\t\tfor (size_t j = 0; j < N; j++) {",
			"\t\t\t\tzero[i][j] = elem_0;",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn zero;",
			"\t};",
			"\tauto id = [&] () {",
			"\t\tauto id = zero();",
			"\t\tfor (size_t i = 0; i < N; i++) {",
			"\t\t\tid[i][i] = elem_1;",
			"\t\t}",
			"\t\treturn id;",
			"\t};",
			"\tauto prod = [&] (const mat& a, const mat& b) {",
			"\t\tauto c = zero();",
			"\t\tfor (size_t i = 0; i < N; i++) {",
			"\t\t\tfor (size_t j = 0; j < N; j++) {",
			"\t\t\t\tfor (size_t k = 0; k < N; k++) {",
			"\t\t\t\t\telem_add(c[i][k], elem_prod(a[i][j], b[j][k]));",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn c;",
			"\t};",
			"\tauto pow = [&] (mat a, long long b) {",
			"\t\tauto ret = id();",
			"\t\tfor (; b; b /= 2) {",
			"\t\t\tif (b % 2 == 1) {",
			"\t\t\t\tret = prod(ret, a);",
			"\t\t\t}",
			"\t\t\ta = prod(a, a);",
			"\t\t}",
			"\t\treturn ret;",
			"\t};",
			"}"
		],
		"description": "none"
	},
	"affine group": {
		"prefix": "affine group",
		"body": [
			"\tauto apply = [&] (std::pair<int, int>p, int& ret) -> void {",
			"\t\tint coeff, a; std::tie(coeff, a) = p;",
			"\t\tmint::mul(ret, coeff);",
			"\t\tmint::add(ret, a);",
			"\t};",
			"\tauto cmp = [&] (std::pair<int, int> p, std::pair<int, int> q) -> std::pair<int, int> {",
			"\t\tint a, b; std::tie(a, b) = p;",
			"\t\tint c, d; std::tie(c, d) = q;",
			"\t\treturn {mint::prod(a, c), mint::sum(mint::prod(a, d), b)};",
			"\t};",
			"\tauto cmp_pow = [&] (std::pair<int, int> p, int k) -> std::pair<int, int> {",
			"\t\tstd::pair<int, int> ret = {1, 0};",
			"\t\twhile (k) {",
			"\t\t\tif (k & 1) ret = cmp(ret, p);",
			"\t\t\tk /= 2;",
			"\t\t\tp = cmp(p, p);",
			"\t\t}",
			"\t\treturn ret;",
			"\t};"
		],
		"description": "none"
	},
	"convolution": {
		"prefix": "convolution",
		"body": [
			"template<typename T>",
			"class convolution {",
			"\tconst T id;",
			"\tconst std::function<void(T&, T)> add;",
			"\tconst std::function<T(T, T)> mul;",
			"\tpublic:",
			"\t\tconvolution (",
			"\t\t\t\tT id,",
			"\t\t\t\tstd::function<void(T&, T)> add,",
			"\t\t\t\tstd::function<T(T, T)> mul",
			"\t\t\t) :",
			"\t\t\tid(id),",
			"\t\t\tadd(add),",
			"\t\t\tmul(mul)",
			"\t\t\t{",
			"\t\t\t}",
			"\t\tauto operator () (",
			"\t\t\t\tstd::vector<T> a,",
			"\t\t\t\tstd::vector<T> b",
			"\t\t\t) -> std::vector<T>",
			"\t\t\t{",
			"\t\t\t\tint l = a.size();",
			"\t\t\t\tint m = b.size();",
			"\t\t\t\tint n = l + m - 1;",
			"\t\t\t\tassert(l && m);",
			"\t\t\t\tstd::vector<T> c(n, id);",
			"\t\t\t\tfor (int i = 0; i < l; i++) {",
			"\t\t\t\t\tfor (int j = 0; j < m; j++) {",
			"\t\t\t\t\t\tadd(c[i + j], mul(a[i], b[j]));",
			"\t\t\t\t\t}",
			"\t\t\t\t}",
			"\t\t\t\treturn c;",
			"\t\t\t}",
			"};",
			"convolution<${1:long long}> cnv(",
			"\t\t${2:id},",
			"\t\t${3:add},",
			"\t\t${4:mul}",
			"\t);",
			"\t"
		],
		"description": "none"
	},
	"free group": {
		"prefix": "free group",
		"body": [
			"class free_group {",
			"\tpublic:",
			"\tstatic inline auto mul(std::string s, std::string t) {",
			"\t\twhile (",
			"\t\t\t\t!s.empty() && !t.empty() &&",
			"\t\t\t\tabs(s.back() - t.front()) == 32",
			"\t\t\t)",
			"\t\t\t{",
			"\t\t\t\ts.erase(s.end() - 1); t.erase(t.begin());",
			"\t\t\t}",
			"\t\t\treturn s + t;",
			"\t}",
			"\tstatic inline auto inv (std::string s) {",
			"\t\tauto opp = [&] (char& c) {",
			"\t\t\t\tif (0 <= c - 'a' && c - 'a' < 26) c -= 32;",
			"\t\t\t\telse if (0 <= c - 'A' && c - 'A' < 26) c += 32;",
			"\t\t\t\telse assert(false);",
			"\t\t\t};",
			"\t\treverse(s.begin(), s.end());",
			"\t\tfor_each(s.begin(), s.end(), opp);",
			"\t\treturn s;",
			"\t}",
			"};"
		],
		"description": "none"
	},
	"gauss jordan int": {
		"prefix": "gauss jordan int",
		"body": [
			"class gauss_jordan {",
			"\tconst int h, w;",
			"\tint rk;",
			"\tstd::vector<bool> ckd;",
			"\tstd::vector<int> p, a;",
			"\tvoid init () {",
			"\t\tfor (int j = 0; j < w; j++) {",
			"\t\t\tfor (int pvt = 0; pvt < h; pvt++) {",
			"\t\t\t\tif (ckd[pvt]) continue;",
			"\t\t\t\tif (a[j] >> pvt & 1) {",
			"\t\t\t\t\tckd[pvt] = true; rk++;",
			"\t\t\t\t\tint comb = a[j] ^ 1 << pvt;",
			"\t\t\t\t\tfor (int i = 0; i < h; i++) if (p[i] >> pvt & 1) p[i] ^= comb;",
			"\t\t\t\t\tfor (int k = j; k < w; k++) if (a[k] >> pvt & 1) a[k] ^= comb;",
			"\t\t\t\t\tbreak;",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"\tinline int transform (int y) const {",
			"\t\tint z = 0;",
			"\t\tfor (int i = 0; i < h; i++) {",
			"\t\t\tif (y >> i & 1) z |= p[i];",
			"\t\t}",
			"\t\treturn z;",
			"\t}",
			"\tpublic:",
			"\t\tgauss_jordan (",
			"\t\t\t\tstd::vector<int> a,",
			"\t\t\t\tint h",
			"\t\t\t) :",
			"\t\t\th(h), w(a.size()), rk(0),",
			"\t\t\tckd(h, false),",
			"\t\t\tp([&]{",
			"\t\t\t\tstd::vector<int> p(h); ",
			"\t\t\t\tfor (int i = 0, x = 1; i < h; i++, x *= 2) p[i] = x;",
			"\t\t\t\treturn p;",
			"\t\t\t}()),",
			"\t\t\ta(a)",
			"\t\t\t{",
			"\t\t\t\tinit();",
			"\t\t\t}",
			"\t\tinline int rank () const {return rk;}",
			"\t\tinline int kernel () const {return w - rk;}",
			"\t\tinline int image () const {return h - rk;}",
			"\t\tinline bool solvable (int y) const {",
			"\t\t\tassert (!(y >> h));",
			"\t\t\tint acm = accumulate(a.begin(), a.end(), 0, [](int x, int y){return x | y;});",
			"\t\t\tint z = transform(y);",
			"\t\t\treturn !(~acm & z);",
			"\t\t}",
			"};"
		],
		"description": "none"
	},
	"1sin": {
		"prefix": "1sin",
		"body": [
			"${1:int} $2; std::cin >> $2;"
		],
		"description": "none"
	},
	"2sin": {
		"prefix": "2sin",
		"body": [
			"${1:int} $2, $3; std::cin >> $2 >> $3;"
		],
		"description": "none"
	},
	"3sin": {
		"prefix": "3sin",
		"body": [
			"${1:int} $2, $3, $4;",
			"std::cin >> $2 >> $3 >> $4;"
		],
		"description": "none"
	},
	"4sin": {
		"prefix": "4sin",
		"body": [
			"${1:int} $2, $3, $4, $5;",
			"std::cin >> $2 >> $3 >> $4 >> $5;"
		],
		"description": "none"
	},
	"5sin": {
		"prefix": "5sin",
		"body": [
			"${1:int} $2, $3, $4, $5, $6;",
			"std::cin >> $2 >> $3 >> $4 >> $5 >> $6;"
		],
		"description": "none"
	},
	"adjacency input": {
		"prefix": "adjacency input",
		"body": [
			"int ${1:n}, ${2:m};",
			"std::cin >> $1 >> $2;",
			"constexpr ${3:long long} inf = 1LL << 60;",
			"std::vector<std::vector<$3>> adj(n, std::vector<$3>(n, inf));",
			"for (int i = 0; i < $1; i++) adj[i][i] = 0;",
			"for (int i = 0; i < m; i++) {",
			"\t$3 d; int s, t;",
			"\tstd::cin >> s >> t >> d;",
			"\tchmin(adj[s][t], d);",
			"}"
		],
		"description": "none"
	},
	"edge input": {
		"prefix": "edge input",
		"body": [
			"int ${1:n}, ${2:m};",
			"std::cin >> $1 >> $2;",
			"std::vector<tuple<${3:long long}, int, int>> edg;",
			"for (int i = 0; i < $2; i++) {",
			"\t$3 d;",
			"\tint s, t;",
			"\tstd::cin >> s >> t >> d;",
			"\tedg.emplace_back(d, ${4:--}s, $4t);",
			"}"
		],
		"description": "none"
	},
	"err": {
		"prefix": "err",
		"body": [
			"auto err = [&] {",
			"\tstd::cout << $0 << std::endl;",
			"\texit(0);",
			"};"
		],
		"description": "none"
	},
	"graph input": {
		"prefix": "graph input",
		"body": [
			"std::vector<std::vector<int>> grh(${1:n});",
			"for (int i = 0; i < ${2:n - 1}; i++) {",
			"\tint s, t;",
			"\tstd::cin >> s >> t;",
			"\tgrh[${3:--}s].push_back($3t);",
			"\tgrh[t].push_back(s);",
			"}"
		],
		"description": "none"
	},
	"graph pair input": {
		"prefix": "graph pair input",
		"body": [
			"std::vector<std::vector<std::pair<${3:long long}, int>>> grh(${1:n});",
			"for (int i = 0; i < ${2:m}; i++) {",
			"\tint s, t; $3 d;",
			"\tstd::cin >> s >> t >> d;",
			"\tgrh[${4:--}s].emplace_back(d, $4t);",
			"\tgrh[t].emplace_back(d, s);",
			"}"
		],
		"description": "none"
	},
	"grid input": {
		"prefix": "grid input",
		"body": [
			"int ${1:h}, ${2:w};",
			"std::cin >> $1 >> $2;",
			"std::vector<std::vector<int>> grd($1, std::vector<int>($2));",
			"for (int i = 0; i < $1; i++) {",
			"\tfor (int j = 0; j < $2; j++) {",
			"\t\tchar c;",
			"\t\tstd::cin >> c;",
			"\t\tgrd[i][j] = c == '#';",
			"\t}",
			"}"
		],
		"description": "none"
	},
	"optional value": {
		"prefix": "optional value",
		"body": [
			"(${1:dst[i]} == ${2:inf} ? \"${3:INF}\" : to_string($1))"
		],
		"description": "none"
	},
	"sout": {
		"prefix": "sout",
		"body": [
			"std::cout << $0 << std::endl;"
		],
		"description": "none"
	},
	"space or newline": {
		"prefix": "space or newline",
		"body": [
			"(${1:i} == ${2:n - 1} ? \" \" : \"\\n\")"
		],
		"description": "none"
	},
	"ternary": {
		"prefix": "ternary",
		"body": [
			"($1 ? $2 : $3)"
		],
		"description": "none"
	},
	"tin": {
		"prefix": "tin",
		"body": [
			"${1:int} ${2:tmp};",
			"std::cin >> $2;",
			"$0;"
		],
		"description": "none"
	},
	"cmn cmx": {
		"prefix": "cmn cmx",
		"body": [
			"template<typename T1, typename T2>",
			"inline bool cmn (T1& a, T2 b) {",
			"\tif (a > b) {",
			"\t\ta = b;",
			"\t\treturn true;",
			"\t}",
			"\treturn false;",
			"}",
			"template<typename T1, typename T2>",
			"inline bool cmx (T1& a, T2 b) {",
			"\tif (a < b) {",
			"\t\ta = b;",
			"\t\treturn true;",
			"\t}",
			"\treturn false;",
			"}"
		],
		"description": "none"
	},
	"combinator": {
		"prefix": "combinator",
		"body": [
			"template<typename T>",
			"class fixed_point : T {",
			"\tpublic:",
			"\t\texplicit constexpr fixed_point (",
			"\t\t\t\tT&& t",
			"\t\t\t) noexcept",
			"\t\t\t: T(std::forward<T>(t))",
			"\t\t\t{",
			"\t\t\t}",
			"\t\ttemplate<typename... Args>",
			"\t\tconstexpr decltype(auto)",
			"\t\toperator()(",
			"\t\t\t\tArgs&&... args",
			"\t\t\t) const",
			"\t\t\t{",
			"\t\t\t\treturn T::operator()(*this, std::forward<Args>(args)...);",
			"\t\t\t}",
			"};",
			"template<typename T>",
			"static inline constexpr decltype(auto) fix (T&& t) noexcept {",
			"\treturn fixed_point<T>{std::forward<T>(t)};",
			"}"
		],
		"description": "none"
	},
	"didj": {
		"prefix": "didj",
		"body": [
			"int d${1:i}[4] = {-1, +1, 0, 0};",
			"int d${2:j}[4] = {0, 0, -1, +1};"
		],
		"description": "none"
	},
	"fix define": {
		"prefix": "fix define",
		"body": [
			"auto ${1:cal} = fix ([&](auto $1, $0) -> ${2:int} {",
			"\t",
			"});"
		],
		"description": "none"
	},
	"fix do": {
		"prefix": "fix do",
		"body": [
			"fix ([&](auto ${1:dfs}, $0) -> ${2:void} {",
			"\t",
			"})();"
		],
		"description": "none"
	},
	"guess": {
		"prefix": "guess",
		"body": [
			"struct rational {int n, d;};",
			"ostream& operator << (ostream& os, rational r){",
			"\tif (r.d == 1) {",
			"\t\tos << r.n;",
			"\t} else {",
			"\t\tos << r.n << \"/\" << r.d;",
			"\t}",
			"\treturn os;",
			"}",
			"rational guess (int k) {",
			"\tconst int dmx = 1000;",
			"\tconst int nmx = 1000;",
			"\tfor (int d = 1; d < dmx; d++) {",
			"\t\tint n = mint::prod(k, d);",
			"\t\tif (n < nmx) {",
			"\t\t\treturn {n, d};",
			"\t\t}",
			"\t}",
			"\treturn {-1, -1};",
			"}"
		],
		"description": "none"
	},
	"remove bit insert bit": {
		"prefix": "remove bit insert bit",
		"body": [
			"int remove_bit(int x, int j) {",
			"\tint low = x & ((1 << j) - 1);",
			"\treturn ((x >> (j + 1)) << j) + low;",
			"}",
			"int insert_bit(int x, int j, int v) {",
			"\tint low = x & ((1 << j) - 1);",
			"\treturn ((x >> j) << (j + 1)) + (v << j) + low;",
			"}"
		],
		"description": "none"
	},
	"this_is_to_be_deleted": "foo"
}
